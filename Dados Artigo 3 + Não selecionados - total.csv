Título;Resumo;Selecionado
scone A Requirements Management Tool for the Specification and Variability-Based Analysis of Product Lines;Nowadays, industrial products as well as software applications are expected to be tailored to the user’s needs in an increasingly distinct manner. This often makes it necessary to design a vast number of customized variants, which leads to complex and error prone analysis and development processes. Generally, requirements engineering is considered to be one of the most significant activities in software and system development. Variant management has proven to play an important role in handling the complexity arising from mass-customization of products. However, there are only a few, often rather complex-to-use, applications which allow adding variance information directly to requirements. Especially in case of small and medium sized enterprises, approaches to meet this challenge often result in isolated solutions that are not driven by state of the art analysis methods and do not cope with future requirements. This paper introduces a lightweight requirements management tool called scone, which will be embedded into an overall variability management methodology. Scone enables the user to create and manage requirement specifications and augment them with variability information. Based on this specification, the requirements can be analyzed in a formal way with respect to their variability using the variability management tool Glencoe. Scone was created as a single page web application to eliminate the need for installation and allow it to run on many devices, while offering the experience of working with a native application, rather than a website. Both tools are designed to provide a proof of concept for the seamless integration of variability information within a system development process as well as to show how variability can be handled in an easy-to-use way from the very beginning within this process.;1
Mapping features to automatically identified object-oriented variability implementations: the case of ArgoUML-SPL;In Software Product Line (SPL) engineering, mapping domain features to existing code assets is essential for variability management. When variability is already implemented through Object-Oriented (OO) techniques, it is too costly and error-prone to refactor assets in terms of features or to use feature annotations. In this work, we delve into the possible usage of automatically identified variation points with variants in an OO code base to enable feature mapping from the domain level. We report on an experiment conducted over ArgoUML-SPL, using its code as input for automatic detection through the symfinder toolchain, and the previously devised domain features as a ground truth. We analyse the relevance of the identified variation points with variants w.r.t. domain features, adapting precision and recall measures. This shows that the approach is feasible, that an automatic mapping can be envisaged, and also that the symfinder visualization is adapted to this process with some slight additions.;1
Software Product Line Configuration and Traceability: An Empirical Study on SMarty Class and Component Diagrams;"A Software Product Line (SPL) represents a set of systems sharing common and variable features. The varying features and respective elements (variability) enable differentiating products of a certain domain. Thus, managing variability is a crucial activity for the success of SPL engineering, especially those based on UML due to a large amount of variability representation in different diagrams. There are few experiments in the literature to evaluate and to compare UML-based variability management approaches. In this paper, we analyze a subset of such approaches: SMarty (our approach), PLUS, and Razavian and Khosravi. We empirically compared them by conducting an experiment with more than 50 participants in terms of configuring SPL products and variability traceability among class and component diagram variable elements. We also analyzed the influence of the participants knowledge on the use of each approach and the amount of material consultation required for each variability management approach. In addition, we checked whether participants comprehend traceability capabilities of approaches. Results pointed out: SMarty is as effective as other studied approaches to configuring SPL specific products; the number of consultations on each approach instructional material did not influence effectiveness; and SMarty needs more participants previous knowledge on UML to configure SPL products.";1
REM4DSPL: A Requirements Engineering Method for Dynamic Software Product Lines;Dynamic Software Product Line (DSPL) is a set of software products capable of self-adapt and configure in run-time. DSPL products have common features (commonalities) and varying features (managed in run-time according to context changes). Objective: DSPL requirements engineering is challenging. Requirements engineers have to carefully plan self-adaptation while eliciting, modeling, and managing variability requirements. This paper introduces a method for DSPL requirements engineering. Method: We relied on empirically-derived activities of DSPL requirements engineering to build our method. We selected techniques and templates used in other domains such as SPL for refinement and incorporation into the method. We asked DSPL experts via a survey on the method applicability. Result: We introduced the Requirements Engineering Method for DSPL (REM4DSPL). Elicitation is guided by supervised discussions. Modeling relies on feature models. Variability Management is tool-assisted and validated via feature model inspection. DSPL experts agreed on the method applicability and suggested improvements. Conclusion: REM4DSPL relies on empirically-derived activities, techniques that have been successfully used by previous work, and templates adapted to the DSPL context. We expect our method to guide requirements engineers in practice.;1
RESDEC: Online Management Tool for Implementation Components Selection in Software Product Lines Using Recommender Systems;Software product lines (SPL) management is one of the most important activities for the software engineer and it represents one of the key pieces of software product line engineering. When a software system grow fast, configuring a product becomes a costly and error-prone activity due to the amount of features available for configuration. This process becomes more complex when for each feature, there is more than one component that implements it. Currently the tools available for configuration management do not have automated mechanisms to facilitate the optimal components selection that meet the functions required by a given product. In this paper, we introduce a prototype component-based recommender system called RESDEC (REcommender System that suggest implementation Components from selecteD fEatures) designed to manage the best implementation components alternatives. Our tool is validated using WordPress-based websites where the implementation components are represented by plugins and the recommendations generated by RESDEC help interested parties in the search and efficient plugins selection to configure websites.;1
Managing product lines variability in rich internet applications ;Rich Internet Applications refers to Web applications resembling desktop solutions with sophisticated user interactions, client-side processing, and asynchronous communications. Rich Internet applications have been evolved from traditional multi-page Web applications to single page applications which handle users' interactions without the need of full-refresh at each interaction. Although many techniques, methodologies, and technologies have been proposed in the rich Internet applications literature, the need for managing variability has not yet been conveniently addressed in this domain. According to software product lines research and practice, handling variability and commonality plays an important role in decreasing the development time and improving the quality of nal products. To this end, in this paper, we aim at employing the variability management techniques in the domain of rich Internet applications. We propose a variability modeling technique based on well-known feature modeling approach and provide a method for annotating rich Internet applications with variability and deriving final application based the given con guration. The proposed method is implemented in a tool named Varion which can be used along with existing rich Internet application tools and approaches. We applied the proposed approach on Angular, a well-known Model-View-Controller framework for developing rich Internet applications.;1
Configuring software product line specific products with smarty and plus: An experimental study on use case diagrams;Software Product Line (SPL) represents a set of systems that share common and variable elements, to meet the specific needs of a particular market segment, providing the necessary flexibility for product customization and diversification. The adoption of SPL provides several benefits, such as, the decreasing in time for building a system and reducing its cost. One of the main SPL development activities is variability management. To manage variabilities, there are several approaches widely known in literature, such as, PLUS and SMarty. Literature has no reports of experimental evaluations comparing existing approaches. With the creation of the SMarty approach, a continuous experimental evaluation process was started in relation to other approaches with the same purpose. Thus, experimental studies have been developed in recent years to demonstrate the effectiveness of SMarty in relation to other similar approaches. Thus, in this paper, we continue the process of continuous experimentation and evolution of SMarty comparing it with the PLUS method with regard to the ability to configure SPL specifics products from use case diagrams. The results did not point to the advantages of the SMarty approach over PLUS, but point out discussion points and improvements for SMarty and the experimentation process followed.;1
Variant management solution for large scale software product lines;Application lifecycle management for large scale software product lines (SPL) comes with the challenge to integrate distributed development activities across different parts of an organization and the engineering process in a tool landscape. Variant management is a cross-cutting concern that has interaction points with many of those integrated solutions. At Bosch, two different tools are used for variant management: pure::variants, a feature modeling tool for describing the feature-oriented product decomposition, and the custom tool MIC that offers a more comprehensive set of fine-grained variability management mechanisms. These include parameters, automated configurations or constraints. In turn, it is more suitable for component selection that is done close to the technology. In this experience report, we present a methodological approach on how to use the two tools with a technical integration solution we developed. Its purpose is to serve as an example for establishing successful variant management in large scale product lines with respect to methodology and tools.;1
Ontology-based automatically hidden web portal index;Many valuable databases on the Web have non-crawlable contents that are hidden behind the search forms. Information is available only by filling out HTML forms manually to query the underlying databases. For accessing data behind forms by automated agents, the critical task is having the corresponding query interfaces of the hidden databases that can be understood by machine. This paper presents an automatic approach of hidden Web portal index for various domains. It discovers and scrapes the query forms from Web pages based the tag-tree presentation, and then interpret them into the uniform mediate interfaces with the aid of domain ontology definition. To achieve high transformation accuracy, the domain ontology is also used to filter out the interfaces that are not related to the specific domain. The query interfaces gained finally represented with common concepts can automatically be indexed and retrieved by program. The experiments indicate that the algorithms used are efficient and the system is materially useful for information system or personalized Web search system to retrieval contents from hidden Web.;1
Automated Constraint-Based Multi-tenant SaaS Configuration Support Using XML Filtering Techniques ;The use of cloud computing is on the rise because of the cost effectiveness in providing the same resources to different tenants. Highly customizable Software-as-a-Service (SaaS) provide high scalability and lower cost as a result of multitenant nature of its cloud applications. However, there are several challenges that make its adoption difficult. Some of the weaknesses of current cloud offerings are complex configuration, development, deployment and management. This paper, investigates the different techniques and methods such as adaptation and variation management used to address these challenges. In addition, the details about how techniques from Software Product Line Engineering and Service Oriented Architecture are applied are addressed. Therefore, the paper extends an existing framework for constraint-based configuration management for cloud applications by integrating existing feature modeling tools with a XML filtering tool –Yfilter. The objective of the integration is to automate the process to identify matched tenant-specific requirements with the SaaS cloud application feature model. The automated process results in lower manual efforts and possible errors, and as a result less complex deployment and management of the SaaS application.;1
A Classification of Variation Control Systems;Version control systems are an integral part of today's software and systems development processes. They facilitate the management of revisions (sequential versions) and variants (concurrent versions) of a system under development and enable collaboration between developers. Revisions are commonly maintained either per file or for the whole system. Variants are supported via branching or forking mechanisms that conceptually clone the whole system under development. It is known that such cloning practices come with disadvantages. In fact, while short-lived branches for isolated development of new functionality (a.k.a. feature branches) are well supported, dealing with long-term and fine-grained system variants currently requires employing additional mechanisms, such as preprocessors, build systems or custom configuration tools. Interestingly, the literature describes a number of variation control systems, which provide a richer set of capabilities for handling fine-grained system variants compared to the version control systems widely used today. In this paper we present a classification and comparison of selected variation control systems to get an understanding of their capabilities and the advantages they can offer. We discuss problems of variation control systems, which may explain their comparably low popularity. We also propose research activities we regard as important to change this situation.;1
Configuration Management Model in Evolutionary Software Product Line;In Software Product Line (SPL), Configuration Management (CM) is a multi-dimensional problem. On the one hand, the Core Assets that constitute a configuration need to be managed, and on the other hand, each product in the product line that is built using a configuration must be managed, and furthermore, the management of all these configurations must be coordinated under a single process. Therefore, CM for product lines is more complex than for single systems. The CM of any software system involves four closely related activities: Change Management (ChM), Version Management (VM), System Building (SB) and Release Management (RM) [I. Sommerville, Software Engineering, 9th edn. (Addison-Wesley, 2010)]. The aim of this paper is to provide ChM and VM models for evolutionary-based SPL system development and maintenance. The proposed models support any level of aggregation in SPLs and have been applied to Mobile SPL as a case study.;1
Comprehensive configuration management model for software product line;In Software Product Line (SPL), Configuration Management (CM) is a multi-dimensional problem. On the one hand, the Core Assets that constitute a configuration need to be managed, and on the other hand, each product in the product line that is built using a configuration must be managed, and furthermore, the management of all these configurations must be coordinated under a single process. Therefore, CM for product lines is more complex than for single systems. The CM of any software system involves four closely related activities: Change Management (ChM), Version Management (VM), Build Management (BM) and Release Management (RM). The aim of this paper is to provide a comprehensive CM model comprising four main sub-models for all CM-related activities required for evolutionary based SPL system development and maintenance. The proposed models support any level of aggregation in SPLs and have been applied to Mobile SPL as a case study.;1
Dynamic Variability Management Supporting Operational Modes of a Power Plant Product Line;Runtime variability is becoming an attractive technique to support those runtime scenarios for systems that demand some kind of autonomous reconfiguration or adaptive behavior. Nowadays, the challenge of many critical systems that need to handle different operational modes, often in an unattended mode, require specific solutions for which runtime variability mechanisms become relevant. This research describes the challenges of runtime variability to support multiple binding modes for handling the diversity of different operational modes and runtime reconfiguration needs. We validate our approach in a power plant control product line at Toshiba which advances previous work making the transition between the power plant operational modes more automatic and dynamic.;1
A systematic approach for configuration management in software product lines;Product lines achieve significant cost and effort reduction through large scale reuse of software product assets. Software Product Lines (SPL) consists of core assets and custom assets, which are shared among multiple products. Core assets, custom assets and products evolve independently. In single product the evolution of the product is in the time dimension, whereas the evolution of products in SPL is in both time and space dimension. Software Configuration Management (SCM) is a software engineering discipline that concerns the management of software evolution and change control. Available SCM systems are suitable for the single product evolution but inadequate for SPL systems. A software version management system is proposed to support product line engineering by supporting product line evolution, product derivation and change promulgation from core assets and custom assets to multiple products and vice versa. This approach supports twenty-three cases of amend promulgations.;1
Realizing a conceptual framework to integrate model-driven engineering, software product line engineering, and software configuration management ;Software engineering is a highly integrative computer science discipline, combining a plethora of different techniques to increase the quality of software development as well as the resulting software. The three sub-disciplines Model-Driven Software Engineering (MDSE), Software Product Line Engineering (SPLE) and Software Configuration Management (SCM) are well-explored, but literature still lacks an integrated solution. In this paper, we present the realization of a conceptual framework that integrates those three sub-disciplines uniformly based on a filtered editing model. The framework combines the check-out/modify/commit workflow known from SCM with the formalism of feature models and feature configurations known from SPLE. The implementation is model-driven and extensible with respect to different product and version space models. Important design decisions are formalized by means of Ecore metamodels. Furthermore, we propose several optimizations that increase the scalability of the conceptual framework.;1
Extending variability management to the next level;Danfoss Power Electronics is a centre with both extensive power electronics know-how and many competencies within frequency converters and solar inverters. Development of embedded controllers built in Danfoss products raises similar challenges found in many other companies: creation of product series with an increasing number of variants, while at the same time decreasing time-to-market and keeping development costs low. Introduction of a Software Product Line approach into product development is a challenge that Danfoss Power Electronics decided to take in order to reduce software development efforts few years ago. The approach has been successful allowing for development of a number of highly engineered products. However, the software product line is in a constant evolution. It grows over time as new functionality is added in the form of extra software artefacts and further products are configured from it. As a result, the overall complexity and maintenance of assets hinders further efficiency of the approach. This paper presents extension of the variability management that goes beyond the scope of software assets reuse previously introduced into the organization. A prototype of the technique linking multi-level variability management is further elaborated using pure variants.;1
Scalable variability management for enterprise applications with data model driven development;Unlike embedded systems, some of enterprise systems are evolved over the decades. The predictability of requirements is a key to success in building reusable assets however it is very hard to predict future business context changes, which are driving factors of requirements. Thus, both functional and context variability must be managed in order to satisfy ever-changing requirements. Scalability does matter for enterprise systems in two aspects. One aspect comes from data volume. Once data become big, it is difficult to maintain performance requirements without de-normalizing database schema. Since database de-normalization is driven by non-functional properties, a model driven approach is not feasible if the model cannot express such properties. Another aspect comes from the unpredictability of future functional requirements. A functional decomposition of enterprise systems usually introduces ever-increasing complexity among systems' interactions due to cross-cutting requirements across functional systems. This paper reflects our empirical studies in data intensive large enterprise systems such as retail and telecommunication industries with industry independent application framework to separate functional and non-functional concerns. Our variability management technique is based on database schema modeling, which can be evolved incrementally in scaling an enterprise system with both data and functional aspects.;1
Tested approach for variability management enhancing in software product line;The paper declares a novel approach for the process enhancing of managing Variability – the ability of a software system or artefact in Software Product Line (PL) to be extended, changed, customized or configured for use in a specific context – with the proper quality characteristics to mitigate its current limitations. New Variability Model and Management Functions to process its element are proposed as this process Core. The model consistently represents variabilities both in PL structure and artefacts across all PL development stages and stakeholders’ viewpoints along with the dedicated assessment submodel. The functions compose separate actions as to variability into the single cycle like Doeming Plan-Do-Check-Act one where decisions should be rational. Presented successful Case Study purposes at the Core proposed testing along with the dedicated Configurator implemented in instrumental and technological complex just developed in the Institute of Software Systems of NAS.;1
Variability management in software product line activity diagrams;The software product line (PL) approach aims at promoting the generation of specific products based on the reusing of its core assets. Such core assets contain similar elements as well as features which vary according to specific products. The variability management has been an intensive and essential activity for the PL development. Several approaches are mainly focused on managing UML-based PL variabilities, more specifically in use cases and classes models. Therefore, this paper presents a proposal for managing variabilities in PL activity diagrams. Thus, the SMarty approach has been extended allowing the evolution of its UML profile, the SMartyProfile, and its variability management process, the SMartyProcess. The SEI’s Arcade Game Maker (AGM) PL was used to illustrate the variability management in its main features activity diagrams.;1
Variation Management for Software Product Lines with Cumulative Coverage of Feature Interactions;In this paper we present a practical way for managing software product lines with respect to its feature interactions and illustrate how it works with the results from the real products in our previous experience. In front of this work, we have applied a software product line engineering and model driven development to our product line development, in which we have ever developed more than 30 products by assembling software components without hand coding. In this previous experience, we found that product developers tended to make excessive effort on verification and testing because of the fear of feature interaction problems. This prevented improving the productivity of software development. In order to address this issue, we propose accumulating the results of feature interactions that have ever appeared in the past products so that the product developers can focus their testing effort on interactions that first appear in their product without worrying about the implementation details. Then they will have confidence in their product configuration. We believe that the variation management with respect to the feature interactions will encourage the developers and promote the introduction of software product line engineering.;1
Variability management for software product-line architecture development;Software Product-Line Engineering (SPLE) is composed of two areas, namely domain engineering and application engineering. Domain engineering is associated with product line architecture, which is a core asset of the product-line. One of the key issues of the software product-line, especially in domain engineering, is handling the variability among product families. That is, variation management for the software product-line architecture determines the success of software development. Therefore, this paper proposes processes and artifacts to build the software product-line architecture and to manage uniform variability over the life cycle of software product-lines. Furthermore, a case study, namely, the Electronic Medical Record (EMR) system, is presented.;1
VML - A family of languages for variability management in software product lines;Managing variability is a challenging issue in software-product-line engineering. A key part of variability management is the ability to express explicitly the relationship between variability models (expressing the variability in the problem space, for example using feature models) and other artefacts of the product line, for example, requirements models and architecture models. Once these relations have been made explicit, they can be used for a number of purposes, most importantly for product derivation, but also for the generation of trace links or for checking the consistency of a product-line architecture. This paper bootstraps techniques from product-line engineering to produce a family of languages for variability management for easing the creation of new members of the family of languages. We show that developing such language families is feasible and demonstrate the flexibility of our language family by applying it to the development of two variability-management languages.;1
Combining Product Line Approach and Formal Specification for Product Family Modeling;The lack of systematic approach for product family modeling leads to difficulties in developing a series of high-quality software products simultaneously. This paper tackles this challenge by combining product line approach and formal specification technique. After constructing the feature model of the target family, our approach will start the formalization of the bottom-level features. For each feature, a formal model will be built according to its inner structure and function details. Any problem occurred during this process will cause the evolvement of the feature model under the guidance of a set of pre-defined evolution rules. The final product family model will be established when no problem can be found in both feature model and feature specification. This interleaving of feature model evolvement and feature formalization facilitates consistent and complete product family modeling from both abstract and concrete levels. A case study is given to illustrate the validity of the approach.;
Industry Trends in Systems and Software Product Line Engineering;For businesses to be competitive, today's product development organizations must deliver a product line a portfolio of similar products or systems with variations in features and functions rather than just an individual product. As a result, a new generation of innovative Systems and Software Product Line (SPL) engineering approaches has emerged to play an increasingly important role. This tutorial will spotlight how mainstream forces are driving SPL approaches to take a holistic perspective that is deeply integrated into the systems and software engineering lifecycle.;
An Initial Framework of Dynamic Software Product Line Engineering for Adaptive Service Robot;Service robot has its challenge to adapt on new tasks based on instruction or environment. Such conditions need to reconfigure or reorganize to obtain new system capabilities. However, most common service robot, especially the one that gives services to help human to deliver food or non medical stuffs in an elderly house, suffers on its task flexibility. Unlike a human, robot system needs to be reconfigured to have a new task which may interrupt its services because of this event. To this, we need a technique to handle adaptive tasks that is flexible to change the robot tasks that do not create delay. Dynamic software product line provides a mechanism to reconfigure a system to have different capabilities based on the core assets of the system, such as software that supports and controls the hardware components in a robotic system. In this work, we make use of the dynamic software product line to create a flexible method that enables a service robot to adapt on its new tasks. In order to define the change of tasks, we model the transformation of task using a transition state which has constraints as a trigger. Other than that, the request of change may also have resulted by forcing an interrupt mechanism. To demonstrate the capability of our approach, the proof of concept using Robotic Operating System will be presented.;
Behaviour-Driven Requirements Engineering for Agile Product Line Engineering;Due to the need of the software development community to integrate the flexibility and the high responsiveness of agile software development with the economic advantages, of reuse and mass customisation, offered by product lines, agile product line engineering has been gaining a momentum of attention from both researchers and practitioners. Developing and managing the different requirements engineering phases of product lines present is a dilemma that the efforts done in the literature was not able to effectively and efficiently resolve. To realise the full potential of agile product line engineering in practice, a complete, consistent, correct, and unambiguous user requirements must be produced without investing that huge amount of time in the upfront domain engineering phase of a traditional software product line. In this proposal, a behaviour-driven cloud-based framework is introduced to develop and maintain software product lines in an agile-based environment. The approach relies on upfront automated testing to derive and manage core assets and variations of an agile-based software product line. The model is validated through an empirical study and the preliminary results are very promising.;
Initiating layers architecture design for Software Product Line;Product Line Architecture is the key success of Software Product Line Engineering. Product Line Architecture prepares the design of architectures for members of product line. Architecture design is the most essential activities of a Product Line Architecture development. It prepares the corner stone of variability decision. The architecture design need to produce specific architecture from product members' assets in a Software Product Line. Representing variability explicitly is the most challenging one. Moreover, the architecture must cope to the diversity of products, and take the behaviour into account. This paper introduces some approaches to address the architecture design problems. Features' grouping with specific concern is the starting point. Then, models the component and interaction element composition, based on its capability. This paper also introduces logics that link the interaction element and component. Using layers, the product line architecture can be established.;
Introduction to Software Product Lines;This tutorial introduces the essential activities and underlying practice areas of software product line development. It reviews the basic concepts of software product lines, discusses the costs and benefits of product line adoption, introduces the SEI's Framework for Software Product Line Practice, and describes approaches to applying the practices of the framework.;
Search-Based Migration of Model Variants to Software Product Line Architectures;Software Product Lines (SPLs) are families of related software systems developed for specific market segments or domains. Commonly, SPLs emerge from sets of existing variants when their individual maintenance becomes infeasible. However, current approaches for SPL migration do not support design models, are partially automated, or do not reflect constraints from SPL domains. To tackle these limitations, the goal of this doctoral research plan is to propose an automated approach to the SPL migration process at the design level. This approach consists of three phases: detection, analysis and transformation. It uses as input the class diagrams and lists of features for each system variant, and relies on search-based algorithms to create a product line architecture that best captures the variability present in the variants. Our expected contribution is to support the adoption of SPL practices in companies that face the scenario of migrating variants to SPLs.;
Product Line Engineering at Siemens -- Challenges and Success Factors: A Report on Industrial Experiences in Product Line Engineering;Siemens is a global powerhouse in electronics and electrical engineering, operating in the sectors industry, energy and healthcare. Siemens holds leading market positions in all its business areas. The degree of innovation and the market success is significantly driven by software being an inherent element of most of the products. This makes Siemens one of the world's largest software companies. Only with systematic reuse Siemens is able to keep its market position for software intensive products. Therefore the company on the one hand invests in research activities and on the other hand top level management actively supports platform initiatives for exploiting reuse potential across different business units.;
Reengineering legacy software products into software product line based on automatic variability analysis;In order to deliver the various and short time-to-market software products to customers, the paradigm of Software Product Line (SPL) represents a new endeavor to the software development. To migrate a family of legacy software products into SPL for effective reuse, one has to understand commonality and variability among existing products variants. The existing techniques rely on manual identification and modeling of variability, and the analysis based on those techniques is performed at several mutually independent levels of abstraction. We propose a sandwich approach that consolidates feature knowledge from top-down domain analysis with bottom-up analysis of code similarities in subject software products. Our proposed method integrates model differencing, clone detection, and information retrieval techniques, which can provide a systematic means to reengineer the legacy software products into SPL based on automatic variability analysis.;
The Product Line Hall of Fame;Summary form only given. The Software Product Line Hall of Fame honors software product lines that can serve as examples to software product line developers.;
MBSE Product Line Engineering â€“ Variability Overview lost?;The article introduces an approach and framework that combines both variability in product line development and reuse of product line assets in customer projects using proven architecture frameworks with some enhancements in one approach.;
Catalysts and Inhibitors for Momentum in the Software Product Line Industry;For software product line engineering (SPLE) to become a standard and accepted practice in the industry, it must be widely embraced by large corporations, major software tool and service vendors, industry analysts, and technology press. We have seen steady but slow progress in all of these areas over the past few years. What can we do to better control or influence the future trends? Technology adoption at the industry scale is about building and sustaining momentum. Through a feedback loop comprising successes and failures, credible validation and invalidation, credible communication, leaps of faith, competitive opportunities, perceptions about perceptions, and so forth, momentum is gained or lost. Catalysts and inhibitors in the loop ultimately determine whether momentum will accelerate or be dampened. In this panel, we bring together an esteemed group of industry leaders from the key areas that impact momentum of new technology adoption, all of whom have been involved in the early stages of the industry's SPLE momentum. In this panel we will search for insights across a broad industry spectrum into the current catalysts and inhibitors, as well as opportunities for the Software Product Line Conference (SPLC) community to positively contribute to the momentum.;
Managing Variation: An Industrial Perspective on Product Line Engineering;If nothing endures but change, then to make the products of our labor enduring, we must build them to accommodate change. If they cannot, they will be cast aside. Change can be thought of as occupying a time window: A solution needs to do something different a year from now, and then something different from that six months later, and so forth. An extremely interesting special case is when that time window shrinks to zero: Our solution needs to do and be a dozen different things right now. In many sectors, that special case turns out to be, in fact, the most common case. The so-called general case, where a single solution evolves over time, turns out to be a less interesting special case. This talk will explore the foundations for the field of product line engineering, which is the engineering of a family of systems that are similar but vary from each other. We will explore various techniques for handling this need, from the earliest to the most up to date, and show how the approaches transcend just software but apply across all engineering disciplines and all levels of an enterprise. Finally, we relate how this concept is being applied in industry today, and show where it is saving companies tens to hundreds of millions of dollars annually.;
Tutorial: New Methods Behind the New Generation of Software Product Line Success Stories;A new generation of software product line success stories is being driven by a new generation of methods, tools and techniques. While early software product line case studies at the genesis of the field revealed some of the best software engineering improvement metrics seen in four decades, the latest generation of software product line success stories exhibit even greater improvements, extending benefits beyond product creation into maintenance and evolution, lowering the overall complexity of product line development, increasing the scalability of product line portfolios, and enabling organizations to make the transition to software product line practice with orders of magnitude less time, cost and effort. This tutorial explores some of the important new methods such as software mass customization sans application engineering, minimally invasive transitions, bounded product line combinatorics, and product line lifecycle management.;
The Role of Requirements and Specification in Product Line Engineering;Product line engineering dealing with software and system families for automotive systems needs a deeper structuring and understanding of systems, their functions, and operational modes than the engineering of individual systems, since the variability of the systems introduces an additional dimension and further complexity. In fact, the enormous complexity of systems today requires a much more structured approach to engineering anyhow. It will be demonstrated how to derive a better structuring of systems by three complementary views at the conceptual level including 1) the context view in terms of context models, 2) the functional view by function hierarchies and operational modes 3) component architecture models. These views bridge the gap between functional requirements and their technical realization. We show how such an approach leads to a more structured understanding of systems in terms of different views on their properties and their mutual logical relation and how this can be used as a basis for product line engineering. We introduce concepts, in particular, of logic to define logical dependencies between different levels of abstractions and perspectives of systems.;
Transforming Legacy Systems into Software Product Lines;This tutorial discusses many aspects of the migration process in an organization when existing software systems are used as starting point for a software product line. It is intended to provide food for thought as well as practical approaches for the migration.;
Managing evolution of software product line;In software product line engineering, core assets are shared among multiple products. Core assets and products generally evolve independently. Developers need to capture evolution in both contexts and to propagate changes in both directions between the core assets and the products. We propose a version control system to support product line engineering by supporting the evolution of product line, product derivation, and change propagation from core assets to products and vice versa.;
Evolving software requirements and architectures using software product line concepts;This paper proposes an evolutionary development approach, which uses software product line and feature modeling concepts for evolving software requirements and architectures. The different versions of an evolutionary system are considered a software product line, with each version of the system a product line member. Requirements are modeled using both use case and feature modeling. Evolution is built into the software development approach because variability in the software architecture is determined by considering the impact of each variable feature on the software architecture and evolving the architecture to address new features. Being feature based, the approach closely relates the evolution of the software architecture to the evolution of software requirements, as well as providing traceability between requirements and architecture.;
New methods in software product line development;A new generation of software product line success stories is being driven by a new generation of methods, tools and techniques. While early software product line case studies at the genesis of the field revealed some of the best software engineering improvement metrics seen in four decades, the latest generation of software product line success stories exhibit even greater improvements, extending benefits beyond product creation into maintenance and evolution, lowering the overall complexity of product line development, increasing the scalability of product line portfolios, and enabling organizations to make the transition to software product line practice with orders of magnitude less time, cost and effort. This paper describes some of the best methods from the industry's most recent software product line successes;
Hybrid ANP: Quality attributes decision modeling of a product line architecture design;Architecture design of a software product line includes a lot of decision of how the variability component will be implemented. The decision corresponds to the requirements of the architecture specifications. Furthermore, most of the decision may have dependency between components. However, only some research devoted to address the quality attributes. In this paper, we propose a new approach that hybrid the Analytical Network Process to model the decision, which addressed the quality attributes. In our method, first, the software component derives from the feature model by the domain expert. Then, groups the components to specific quality attributes. Subsequently, models the dependency of quality attributes in the ANP model. We use a eLearning Product Line Architecture to demonstrate the feasibility of our approach.;
Extractive Multi Product-Line Engineering;Cloning is a general approach to create new functionality within variants as well as new system variants. It is a fast, flexible, intuitive, and economical approach to evolve systems in the short run. However, in the long run, the maintenance effort increases. A common solution to this problem is the extraction of a product line from a set of cloned variants. This process requires a detailed analysis of variants to extract variability information. However, clones within a variant are usually not considered in the process, but are also a cause for unsustainable software. This thesis proposes an extractive multi product-line engineering approach to re-establish the sustainable development of software variants. We propose an approach to re-engineer intra-system and inter-system clones into reusable, configurable components stored in an integrated platform and synthesize a matching multi-layer feature model.;
Towards a Software Product Line Framework to Support Cross-domain Component Composition;Software product lines (SPL) are of great significance to the software development process as they rely on identifying commonalities within an application domain in order to facilitate component integration to build new software products. The main focus of SPL is the development of software systems in a single domain where some basic functionality is reused over the developed systems. However, when it comes to cross-domain component reuse, SPL development processes always encounter difficulties in integrating heterogeneous components due to different architectural assumptions. This paper establishes a significant distinction of component interfaces and utilises it to derive the building block of a SPL that can support developing cross-domain software reuse.;
Toward a software product line for affective-driven self-adaptive systems;One expected characteristic in modern systems is self-adaptation, the capability of monitoring and reacting to changes into the environment. A particular case of self-adaptation is affective-driven self-adaptation. Affective-driven self-adaptation is about having consciousness of user's affects (emotions) and drive self-adaptation reacting to changes in those affects. Most of the previous work around self-adaptive systems deals with performance, resources, and error recovery as variables that trigger a system reaction. Moreover, most effort around affect recognition has been put towards offline analysis of affect, and to date only few applications exist that are able to infer user's affect in real-time and trigger self-adaptation mechanisms. In response to this deficit, this work proposes a software product line approach to jump-start the development of affect-driven self-adaptive systems by offering the definition of a domain-specific architecture, a set of components (organized as a framework), and guidelines to tailor those components. Study cases with systems for learning and gaming will confirm the capability of the software product line to provide desired functionalities and qualities.;
Product Line Architecture Recovery: An Approach Proposal (Extended Abstract);The Product Line Architecture (PLA) is an important asset for the success of Software Product Line (SPL) projects. Due to the complexity of managing the architectural variability, maintain the PLA up-to-date and synchronized with the project source code is a hard problem. The systematic use of Software Architecture Recovery (SAR) techniques enables the PLA recovery and keeps the PLA aligned with the development. In this context, we present our initial proposal that consists of an approach to recover PLAs based on the use of (bottom-up) SAR techniques. We performed some studies (such as surveys, literature reviews, and exploratory studies) to investigate the relationship between SAR and PLA to identify gaps and define the research area state-of-the-art. The combination of SAR and PLA is an important strategy to address some issues of PLA design. We identified that few studies address architectural variability, PLA variability traceability, and empirical evaluation such as experiments, surveys, mixed-methods, and so on.;
Renewing the Product Line Vision;"Twenty years ago, an effort to build a reuse-based software generator led to the realization that a domain-specific focus was essential to achieving effective software reuse. This realization became the product line vision. However, reuse was never the primary focus of this vision but only a means to an end: achieving the ability to rapidly produce and evolve high-quality software. Although the spirit of this vision guides us still, much of current product line work assumes a formulation that is limited from the perspective of the original vision. A look back at neglected aspects of that vision will suggest opportunities for greater progress. Beyond that, consideration of an emerging ""producibility"" vision will provide a broader perspective for framing future product line efforts.";
The BigLever Software Gears Unified Software Product Line Engineering Framework;In this paper discusses that BigLever Software's Unified Software Product Line Engineering (SPLE) Framework enables the integration of tools, assets and processes across the full system and software product line development lifecycle. The Gears framework offers a simple and elegant integrated software product line solution - for requirements engineers, architects, modelers, developers, build engineers, document writers, configuration managers, test engineers and project managers. The unified SPLE framework has enabled mainstream organizations with some of the largest, most sophisticated and complex, safety-critical systems ever built to adopt the SPLE approach.;
Keynote Talk III: A formal methods perspective on product line engineering;Summary form only given. A product line is a family of similar products with variations in features and functions. Product Line Engineering (PLE) is an engineering discipline for product lines using a shared set of engineering assets, a managed set of features, and an efficient means of production. It takes advantage of the commonality shared across the family while efficiently and systematically managing the variation among the products. PLE can trace its roots in software back to the 1970s;
Modeling and Building Software Product Lines with Pure::Variants;Software product line development (SPLD) can reduce the overall software production costs, but imposes extra complexity on the development process. Dealing with the commonalities and variabilities of the product variants and with the flexible software archiecture makes SPLD a real challenge. The demonstration shows how flexible product line (PL) architectures can be build by using the modeling capabilities provided by pure::variants, a commercial tool for SPLD.;
Automated Migration Support for Software Product Line Co-evolution;The idea of automated migration support arises from the problems observed in practice and the missing solutions for software product line (SPL) co-evolution support. In practice it is common to realize new functionality via unsystematic code cloning: A product is separated from its related SPL and then modified. When a separated product and the SPL evolve over time, this is called SPL co-evolution. During this process, developers have to manually migrate, for example, features or bugfixes between the SPL and the product. Currently, there exist only partially automated solutions for this use case. The proposed approach is the first, which aims at using semantic merging to migrate arbitrary semantic units, like features or bugfixes, between a SPL and separated products.;
Pragmatic Methods for Commercial Software Product Line Engineering Practice;Summary form only given. The current generation of software product line (SPL) engineering success stories is being driven by a new generation of methods, tools and techniques. In this article, we explore the latest in the ongoing evolution of SPL best practices that make it easier to adopt an SPL engineering approach and that make it more efficient to achieve optimal benefits over the long term.The goal of the article is to enable attendees to gain a better and simpler understanding of SPL concepts and practice, based on the latest experiences and advances in the 3-tiered SPL methodology and the unified SPL lifecycle framework. These pragmatic SPL concepts represent current advances in SPL practice and are based on observations and firsthand experiences during deployments and operation of the latest generation of successful commercial SPL practices,including Lockheed Martin and HomeAway, as well as highly acclaimed Software Product Line Hall of Fame inductees Salion and LSI Logic/Engenio. The 3-Tiered SPL Methodology and Unified SPL Lifecycle Framework have supported full scale operational transitions to software product line practice, involving hundreds of software engineers, millions of lines of source code and requirements, and billions of dollars in commercial product lines.;
Safe Evolution Patterns for Software Product Lines;Despite a global recognition of the problem, and massive investment from researchers and practitioners, the evolution of complex software systems is still a major challenge for today's architects and developers. In the context of product lines, or highly configurable systems, variability in the implementation and design makes many of the pre-existing challenges even more difficult to tackle. Many approaches and tools have been designed, but developers still miss the tools and methods enabling safe evolution of complex, variable systems. In this paper, we present our research plans toward this goal: making the evolution of software product lines safer. We show, by use of two concrete examples of changes that occurred in Linux, that simple heuristics can be applied to facilitate change comprehension and avoid common mistakes, without relying on heavy tooling. Based on those observations, we present the steps we intend to take to build a framework to regroup and classify changes, run simple checks, and eventually increase the quality of code deliveries affecting the variability model, mapping and implementation of software product lines.;
Building Reusable Testing Assets for a Software Product Line;Testing consumes a significant percentage of the resources required to produce software intensive products. The exact impact on the project is often hard to evaluate because testing activities are distributed over the entire scope of the development effort. In this tutorial we take a comprehensive end-to-end view of the testing activities and roles that should be present in a software product line organization.;
Variability support for variability-rich software ecosystems;Lately, software ecosystems have generated a lot of attention as they are very important to modern software industry. Over the course of several research projects, we addressed the problem of variability-rich software ecosystems and their relation to software product lines in our research group. This paper summarizes some of the problems we identified and describes some solutions we created both on a conceptual level and implemented in a prototype tool environment.;
Dexmo Software Product Line and Product Composition Method;With the spread of service-based software, software product lines where software components are services or even microservices have started to emerge. In this paper, the Dexmo software product line approach developed in this way at Univera is explained. Dexmo software product line is different from the classical software product lines. A novel marketing engineering process and a control tower application are added on top of domain and application engineering. Moreover, Dexmo software product line approach offers significant changes in both domain and application engineering compared to the classics. The software product composition method, one of the most important of these, is also explained in detail.;
Search based design of software product lines architectures;The Product-Line Architecture (PLA) is the main artifact of a Software Product Line (SPL). However, obtaining a modular, extensible and reusable PLA is a people-intensive and non-trivial task, related to different and possible conflicting factors. Hence, the PLA design is a hard problem and to find the best architecture can be formulated as an optimization problem with many factors. Similar Software Engineering problems have been efficiently solved by search-based algorithms in the field known as Search-based Software Engineering. The existing approaches used to optimize software architecture are not suitable since they do not encompass specific characteristics of SPL. To easy the SPL development and to automate the PLA design this work introduces a multi-objective optimization approach to the PLA design. The approach is now being implemented by using evolutionary algorithms. Empirical studies will be performed to validate the neighborhood operators, SPL measures and search algorithms chosen. Finally, we intend to compare the results of the proposed approach with PLAs designed by human architects.;
Runtime Collaborative-Based Configuration of Software Product Lines;Software Product Line (SPL) configuration practices have been employed by industries as a mass customization process. However, the inherent variability of large SPLs leads to configuration spaces of exponential sizes. Thus, scalability and performance concerns start to be an issue when facing runtime environments, since it is usually infeasible to explore the entire configuration space exhaustively. In this context, the aim of my research is therefore to propose an efficient collaborative-based runtime approach that relies on recommender techniques to provide accurate and scalable configurations to users. To demonstrate the efficiency of the proposed approach, I conduct series of experiments on real-world SPLs. In addition, I plan empirically verify through a user case study the usability of the proposed approach. My expected contribution is to support the adoption of SPL configuration practices in industrial scenarios.;
Products as product lines;An argument is made that a product line approach can be beneficial for even single product development, particularly for products that support customers whose needs are likely to change over time. Furthermore, product line techniques for identifying requirements and design alternatives and documenting rationale for decisions would benefit any product development effort.;
Variability Management Case Study in Software Insurance Domain;Variability modeling and realization mechanism are suggested for software insurance product line what focused in domain technology features. Ontology-based modeling is applied in variability modeling for concepts, attributes, and constraints among the concepts. Ontology-based variability is modeled in XML since XML is very flexible for adding and ignoring the concepts and attributes. Ontology-based variability is realized with business rule management tools at run time. With software insurance product line, insurance company improve the quality and productivities in maintain the sales system.;
Using configuration management and product line software paradigms to support the experimentation process in software engineering;There is no empirical evidence whatsoever to support most of the beliefs on which software construction is based. We do not yet know the adequacy, limits, qualities, costs and risks of the technologies used to develop software. Experimentation helps to check and convert beliefs and opinions into facts. This research is concerned with the replication area. Replication is a key component for gathering empirical evidence on software development that can be used in industry to build better software more efficiently. Replication has not been an easy thing to do in software engineering (SE) because the experimental paradigm applied to software development is still immature. Nowadays, a replication is executed mostly using a traditional replication package. But traditional replication packages do not appear, for some reason, to have been as effective as expected for transferring information among researchers in SE experimentation. The trouble spot appears to be the replication setup, caused by version management problems with materials, instruments, documents, etc. This has proved to be an obstacle to obtaining enough details about the experiment to be able to reproduce it as exactly as possible. We address the problem of information exchange among experimenters by developing a schema to characterize replications. We will adapt configuration management and product line ideas to support the experimentation process. This will enable researchers to make systematic decisions based on explicit knowledge rather than assumptions about replications. This research will output a replication support web environment. This environment will not only archive but also manage experimental materials flexibly enough to allow both similar and differentiated replications with massive experimental data storage. The platform should be accessible to several research groups working together on the same families of experiments.;
Study on Product Family Structure Model Based on Visual Graph;Product family structure gives expression to the complicated relation among product family. It's rationality is a key factor to configuration design process. It can express generic discrete structure by visual graph. Structural describes a hierarchical structure of sets. Product family structure is constructed by structural visual graph in this paper. Configuration design algorithm is given. The algorithm is testified by an example.;
Using Documentation for Product Line Scoping;The introduction of product line engineering must be well planned. This planning phase, where the product line's characteristics are determined, is called scoping. Product line scoping is the process of identifying and delimiting capabilities (products and features) and areas (subdomains and existing assets) of the product line where investment into reuse would be economical and beneficial to product development. It aims to dispel doubts and uncertainty in decisions about which products will become part of the product line and whether to invest into reuse. Scoping is based heavily on expert knowledge and information from meetings and workshops.;
Product-line development requires sophisticated software configuration management;Software process technology as well as software configuration management (SCM) has focussed very much on supporting the development and evolution of a single software product rather than software product-lines. In the case of SCM this is particular harmful, because current SCM technology only provides very limited support to adjust a tool supporting SCM to the particular needs and requirements of a company producing product-line software. Usually such a tool has a built-in process and to the most provides a shell-script like language to define certain responsibilities or development status attributes for the artifacts produced during development and maintenance. There is virtually no support to adjust a tool to e.g. the definition of special workflows for change management and notification.;
Families (of Products) in Space;NASA is developing plans for innovative and novel approaches to future (unmanned) space exploration missions. Future missions involve sending spacecraft and robots to harsh environments, where resilience is necessary for the survival of the mission. In addition, distances and communication lead times between the spacecraft and Earth necessitate much of the mission operation being autonomous. We have been conducting research on the development of autonomous space exploration missions based on principles from Autonomic Computing (AC), whereby the mission is imbued with self-management capabilities. Such missions will involve several, rather than single, spacecraft, robots or other devices, operating in collaboration. We describe one such concept mission, ANTS (Autonomous Nano-Technology Swarm), which involves a number of sub-missions that are self-similar. Our work in this, and other future missions, has involved the use of techniques from AC for building in self-management, and ultimately self-governance. We have also explored the use of formal methods to gain confidence in the correct behavior of the mission. Since both the physical devices which will be used for exploration, and the software that is essential for their successful deployment, lend themselves to a product-line approach, we have been exploiting techniques from software product-line engineering, in particular Multi-Agent System Product Lines (MAS-PL) and Dynamic Software Product Lines (DSPL).;
Using social network analysis technique for supporting software product line process;Software Product Line (SPL) becomes a potential approach for software system engineering. Software artifacts based on different models and approaches are collected and deposited into repository in order to be reused for a new software product in the future. Otherwise, identifying of reusable software artifacts is still difficult and time-consuming. In particular, requirements management for SPL becomes more complex process that should take into account requirements value for customers, cost of implementation, available resources, requirements interdependencies, system architecture and dependencies to the code base. In this paper we propose a social network representing the software product line artifacts and relationships between those artifacts. We believe the social network can be analyzed in order to acquire the information representing the dependencies between software artifacts and stakeholders. This information can be applied in order to improve software requirements management for SPL.;
Variability Management with ACM (Adaptable Component Model) for Insurance Product Line;In insurance application, there are typical problems which can arise as complexity of products increases and reason for product line engineering required. For easy channel extension and new product release, insurance product line engineering was launched. In this paper, we describe experiences of product line engineering. Specially, this paper proposes ACM (adaptable component model) to deal with variability of component applying with rule concept. For component reuse, variability management is most important in product line engineering. It is a basic and essential principle to identify common elements as components and to make them assets of product line. But the problem is that it is not easy to identify what are the variable parts of components and to handle them. These days, business rule is getting more critical key for successful RTE (real time enterprise). It means separating rules can make easy change or fast adapt to new business context without modifying application. The elements of variability which change with each application are viewed as variability of business rules. Therefore, when there is need to change business requirements in product line;
Bottom-up Modeling for a Software Product Line: An Experience Report on Agile Modeling of Governmental Mobile Networks;Agile software development has been gaining increasing attention during the last decade. In agile process models, attention is paid to building the ability to respond to change. This is problematic in view of product line engineering and formal modeling, since traditionally these two require heavy up-front planning. We are presenting our experiences on combining these three in an industrial setting of building a telecommunication network provisioning product line. We avoided the up-front planning by building our modeling toolset in a bottom-up way and improving the toolset whenever required by the needs of the on-going iteration.;
Value-Based Portfolio Optimization for Software Product Lines;Software Product Lines are a mean to improve the economic performance of firms that offer several products to a market by systematically reusing software artifacts. In most cases the definitive company goal is profit maximization. That can be reached by increasing revenue or by reducing cost. Revenue is increased by offering products with a wide variety of features to an audience willing to pay. However, the fewer features are realized the fewer cost incur. Hence, a firm may ask what features are most important to realize. We approach this question by introducing Value-Based Portfolio Optimization as an addition to common Product Portfolio Scoping approaches that helps deciding on this question.;
A proposal for consistency checking in dynamic software product line models using OCL;Ubiquitous applications use context information to provide services and relevant information for their users. On the other hand, in Software Product Line approaches, commonality and variability of a system family should be identified and documented through variability modeling. Thus, one of the challenges to build Context-Aware Product Lines, called Dynamic Software Product Lines, is the consistent representation of context information that influences the variability model. This work proposes the use of UML profiles and OCL to formalize and represent variability and context concepts in a consistent manner.;
Configuration Management: Supporting Agile Methodology Development;In this course, developed by IEEE Educational Activities with the support of IEEE Computer Society, we will cover configuration management practices such as Agile SCM and will explain all those unique requirements of implementing SCM to support agile development. We will see how Configuration Management helps to manage and respond to critical incidents such as the Log4j breach in which IT engineers were scrambling to identify systems that contained the libraries that were known to be vulnerable. ;
Regression Test Selection and Product Line System Testing;Context: Software product lines (SPL) are used in industry to achieve more efficient software development. To test a SPL is complex and costly and often becomes a bottleneck in the product line organization. Objective: This research aims to develop and evaluate strategies for improving system test selection in a SPL. Method: Initially industrial practices and research in both SPL testing and traditional regression test selection have been surveyed. Two systematic literature reviews, two industrial exploratory surveys and one industrial evaluation of a pragmatic test selection approach have been conducted. Results: There is a lack of industrial evaluations as well as of useful solutions, both regarding regression test selection and SPL testing. Test selection is an activity of varying scope and preconditions, strongly dependent on the context in which it is applied. Conclusions: Continued research will be done in close cooperation with industry with the goal to define a tool for visualizing system test coverage in a product line and the delta between a product and the covered part of the product line.;
Configuration Management: Emerging Practices and Applications;In this course, developed by IEEE Educational Activities with the support of IEEE Computer Society, we examine configuration management practices including SCM in the supply chain. Applicable industries include banking and financial services, medical systems and hospitals, engineering, and automotive, aerospace and defense. The course will also cover how CM enables the implementation of supply chains through the emerging best practice known as the Software Bill of Materials (SBOM) that is now required for government contractors. Some real-world examples will include building medical devices that are safe, secure, and reliable that cannot be compromised. Identifying defects in the software and enabling rapid building, packaging, and deployment of desired changes.;
Configuration Management: Best Practices for Systems Engineering;This course developed by IEEE Educational Activities with the support of IEEE Computer Society will examine essential configuration management or CM, best practices starting with effective source code management including branching patterns, pull requests, and tagging releases. We will also discuss how to determine and understand code history and traceability. Build engineering and release management are essential CM best practices that include build engineering, automation, continuous integration, and release coordination and release management. We will discuss the different kinds of change management and change control boards and then deployment automation, baselines, and systems and applications monitoring.;
Leveraging Model Driven Engineering in Software Product Lines;Model Driven Engineering (MDE) is a new innovation in the software industry that has proven to work synergistically with Software Product Line Architectures (SPLA). It provides the tools necessary to fully harness the power of Software Product Line Architectures.;
(CSDP) Software Configuration Management (Archived);This course is part of our eLearning Archive, which includes older courses that may not be current or as user-friendly as courses designed more recently.;
This course is part of a series of eLearning courses designed to help you prepare for the examination to become a Certified Software Development Professional (CSDP) or to learn more about specific software engineering topics. Courses in this series address one or more of the fifteen Knowledge Areas that comprise the Software Engineering Body of Knowledge - or SWEBOK; software configuration and control;
Managing Variability for Software Product Lines: Working with Variability Mechanisms;This work describes a workshop that is intended to fill the void between variability requirements visible to those who deal with features and other product-level concerns, and the variability mechanisms visible to creators and consumers of a product line's core assets. The goal of the workshop is to begin to codify a body of knowledge for the informed and purposeful selection of variability mechanisms to use in a software product line's core assets.;
Software Configuration Management and IEEE Standards Bundle (Archived);This course is part of our eLearning Archive, which includes older courses that may not be current or as user-friendly as courses designed more recently.;
Configuration Management: Core Concepts for Building Reliable Software;In this course, developed by IEEE Educational Activities with the support of IEEE Computer Society, we learn how to be a change agent choosing the right practices to help organizations develop and implement secure and reliable code. We will learn about effective strategies for assessing and improving existing practices beginning with identifying what is working well and what needs to be improved. This course examines how to use existing industry best practices as part of the assessment process and focus on starting with small improvements and then building momentum to bring about significant improvement. We will consider how to demonstrate value and that change can happen while considering the impact of corporate culture and history. We will also examine both internal and external forces in driving the assessment and improvement of organizational practices.;
Configuration Management: Organizational Assessment and Improvement;This course developed by IEEE Educational Activities with the support of IEEE Computer Society we explain how to be a change agent choosing the right practices to help organizations develop and implement secure and reliable code. We will learn about effective strategies for assessing and improving existing practices beginning with identifying what is working well and what needs to be improved. This course examines how to use existing industry best practices as part of the assessment process and focus on starting with small improvements and then building momentum to bring about significant improvement. We will consider how to demonstrate value and that change can happen while considering the impact of corporate culture and history. We will also examine both internal and external forces in driving the assessment and improvement of organizational practices.;
Introduction to Product Line Requirements Engineering;Requirements elicitation and management has become ever more important as products become more complex and time to market is shortened and the definitions of product lines has significantly increased project complexity. Outsourcing has added a new dimension to requirements management, exacerbating problems associated with transitioning from analysis to design. This half day tutorial will provide an introduction to product line requirements engineering from the perspective of project and product management: how it impacts project managers, quality assurance personnel, requirements analysts, developers and testers. Topics covered will include product line requirements, feature modeling, CMMI compliant requirements management and requirements analysis processes (both UML and text based). Business analysts who are interested in using UML for modeling will also find the course interesting. No formal knowledge of programming is required. developers and testers.;
An approach to variability management in service-oriented product lines;Service-Oriented product lines (SOPLs) are dynamic software product lines, in which, the products are developed based on services and service-oriented architecture. Although there are similarities between components and services, there are important differences so that we cannot use component-based product line engineering methods and techniques for SOPL engineering. These differences emerge from the fact that, services can be discovered as black box elements from external repositories. Moreover, services can be dynamically bound and are business-aligned. Therefore, analyzing the conformance of discovered external services with the variability of services in the SOPL - which must be aligned to the variable business needs-is necessary. Variability must be managed, that is, it must be represented (modeled), used (instantiated and capable of conformance checking) and maintained (evolved) over time. Feature Models are insufficient for modeling variability in SOPL, because, services cannot be simply mapped to one or more features, and identification of the mapping depends on knowing the detailed implementation of the services. This research aims at providing an approach to managing the variability in SOPLs so that external services can be involved in the SOPL engineering. This paper presents an overview of the proposal.;
Software product line reuse in practice;The study of software product line addresses the issues of engineering software systems families, or collections of similar software systems. The objective of a software product line is to reduce the overall engineering effort required to produce a collection of similar systems by capitalizing on the commonality among the systems and by formally managing the variation among the systems. This is a classic software reuse problem (C. Krueger, 1992). The primary focus of software product line research has been on domain analysis and modeling, architecture modeling, software reuse repositories, generators, and process definition. In contrast, for engineering single systems, these technologies and techniques provide significant value, while for engineering software product lines the conventional wisdom suggests they are essential. We hypothesize, however, that domain analysis, architecture modeling, software reuse repositories, generators, and process definition are simply compensating for a void in the existing software engineering technology space and that this void can be filled by a more simple, powerful, and concise technology for engineering software product lines. This new technology then redefines the status of domain analysis and the other existing technologies so that they have the same status in software product line development that they do in single system development: valuable engineering technologies but not necessarily requisite.;
Extraction and improvement of conditionally compiled product line code;Conditional Compilation (CC) is one of the most widely used variation mechanisms in the development of software product lines (SPLs). However, a problem in SPL maintenance is that conditionally compiled code blocks are often overly scattered, nested, and tangled, which makes the code difficult to understand. Moreover, if variant code is evolved independently of the corresponding variability model, there is a risk that the two may become inconsistent. As a countermeasure, this paper proposes a maintenance process, consisting of variability extraction, error detection, and refactoring, to improve the quality of product line implementation.;
Feature Modularity in Software Product Lines;Feature Oriented Programming (FOP) is a design methodology and tools for program synthesis in software product lines. Programs are specified declaratively in terms of features. FOP has been used to develop product-lines in widely varying domains, including compilers for extensible Java dialects [6], fire support simulators for the U.S. Army [4], network protocols [1], web portlets [8], and program verification tools [9].;
Lightweight Dependency Models for Product Lines;This tutorial presents a practical technique for managing the architecture of software product lines using inter-module dependencies. We will show that the Lightweight Dependency Model approach, based on dependency structure matrices, is highly scalable compared to the directed graph approaches that are common today. We will also show a variety of matrix algorithms and transformations that can be applied to analyze and organize the system into a form that reflects the architecture and demonstrates the importance of managing dependencies in product lines. We illustrate our approach by applying it to real applications each consisting of hundreds or thousands of files. We will show how dependency models can be created for product lines and how formal design rules can be specified to manage the evolution of these architectures.;
Agile Software Product Lines - A Working Session;Agile software development and software product line engineering are both successful approaches to the development of software-intensive products, but can the planning driven approach of product lines be effectively integrated with the opportunistic approach of agile techniques? This is a difficult question to answer since each broad strategy refers to a family of possible methods.;
A feature-oriented method for product line software engineering [Tutorial];Summary form only given, as follows. Over the last decade or so, software product line engineering has emerged as one of the most promising software development paradigms in drastically increasing the productivity of IT-related industries ways to meet diverse needs of the global market most effectively and efficiently and to become competitive. To be able to engineer application software for a product line, the application domain of the product line must first be understood in terms of application family's commonality and variability.;
Variability Aware Requirements Reuse Analysis;Problem: The goal of a software product line is to aid quick and quality delivery of software products, sharing common features. Effectively achieving the above-mentioned goals requires reuse analysis of the product line features. Existing requirements reuse analysis approaches are not focused on recommending product line features, that can be reused to realize new customer requirements. Hypothesis: Given that the customer requirements are linked to product line features' description satisfying them: then the customer requirements can be clustered based on patterns and similarities, preserving the historic reuse information. New customer requirements can be evaluated against existing customer requirements and reuse of product line features can be recommended. Contributions: We treated the problem of feature reuse analysis as a text classification problem at the requirements-level. We use Natural Language Processing and clustering to recommend reuse of features based on similarities and historic reuse information. The recommendations can be used to realize new customer requirements.;
The Quest for Formal Methods in Software Product Line Engineering;Software product line engineering (SPLE) aims to alleviate the complexity by providing a set of systems with wellâ€defined commonalities and variabilities. SPLE offers a commercially successful approach that can improve both time to market and quality. A major limiting factor of quality assurance in existing SPLE practice is the heterogeneity of modeling formalisms in different development phases. The modeling language should be capable of expressing all relevant system aspects and their variability based on a common formal semantics. The modeling framework should contain rich behavioral specification mechanisms in addition to structural description techniques that allow for modeling and reasoning about system behavior. Variability modeling to represent system diversity is integral to a uniform modeling framework. Modularization allows splitting the product line model into manageable parts to alleviate design complexity. The abstract behavioral specification language (ABS) is an integrated modeling language comprising variability modeling with structural and behavioral system modeling;
Architectural aspects of software sharing and standardization: AUTOSAR for automotive domain;Business and cooperation models in the automotive domain are becoming more and more complex and flexible. The following two models and their impact on software architecture will be discussed in more detail: 1) delivery of code relevant artifacts from the OEM (original automobile equipment manufacturer) to the Tier1 (supplier of OEM) and the other way around: 2) delivery of Tier1 software to the OEM. Both use cases and all its derivations are subsumed under the term â€œSoftware Sharingâ€. The discussion is based on the concrete experiences of BOSCH Powertrain (Diesel Gasoline Systems, DGS) in the area of software sharing. Improvements are seen in the strengthened use of standardized architecture and application interfaces. The most important software standard in the automotive domain is AUTOSAR (AUTomotive Open System ARchitecture).;
Software product line and open source software;A similar set of open source software is selected on many systems even if these systems in which the software is applied are in different domains. It must be primary type of core asset on product line software engineering. And next, I want to discuss about success of many network appliances run on open source OS.;
A Guide for Management and Financial Controls of Product Lines;The calculations of NPV (net present value) and cash flows provide useful means when organizations come to decide whether they should transit from one-off development to software product line (SPL) based development, how much investment should be made for the development of SPL, whether their investments are being successfully returned from the on-going SPL adoption programs, or whether they should modify their on-going programs. The paper first summarizes experiences that were gathered from the Toshiba Software Factory in which a series of product lines for the domain of electric power generation, called EPG-SPL, has been developed and practically applied since 1962. At present, the 4 generation of EPG-SPL is being applied. The purpose of this paper is to present how NPV and cash flow calculations can be used if it is applied to the management and controls of SPL adoption, and to propose a guide for monitoring the shortage of return-on- investment every year, which is necessary to achieve successful SPL adoptions.;
What should software practitioners know for adopting product line software engineering?;Software productline engineering is becoming recognized as an important concept for efficient and timely software development. But to be actually useful, practitioners of software development (designers, programmers, testers, etc.) must have solid understanding and well organized knowledge about productline engineering. So in this workshop, I want to discuss about;
Towards Enabling Reuse in the Context of Safety-Critical Product Lines;In the context of safety-critical product lines, industries have to face an urgent challenge: reduction of time and cost for the creation of a safety case. A safety case is a contextualized structured argument constituted of process and product-based sub-arguments to show that a system is acceptably safe. Its creation is an extremely time-consuming and costly activity. To reduce time and cost, reuse capabilities are being investigated from different perspectives however currently no satisfying approach is available. In this paper, we propose a new methodological framework called Anti-Sisyphus. Anti-Sisyphus is aimed at enabling reuse by combining process lines, product lines and safety case lines. The systematization of what varies and what remains in common with respect to process as well as product elements in turns enables the systematization of what varies and remains in common in terms of process-based as well as product-based arguments within a safety case line. Anti-Sisyphus thus has the potential to enable a 3D reuse.;
Tutorial on Generative Software Development;Software product line engineering (SPLE) [5] seeks to exploit the commonalities among systems from a given problem domain while managing the variabilities among them in a systematic way. In SPLE, new system variants can be rapidly created based on a set of reusable assets, such as a common architecture, components, and models. Generative software development [6] aims at modeling and implementing product lines in such a way that a given system can be automatically generated from a specification written in one or more textual or graphical domain-specific languages (DSLs) [13, 4, 15, 8, 3, 1, 12, 14].;
(CSDA) Software Configuration Management (Archived);This course is part of our eLearning Archive, which includes older courses that may not be current or as user-friendly as courses designed more recently.;
This course is part of a series of eLearning courses designed to help you prepare for the examination to become a Certified Software Development Associate (CSDA) or to learn more about specific software engineering topics. Courses in this series address one or more of the fifteen Knowledge Areas that comprise the Software Engineering Body of Knowledge - or SWEBOK;CSDA;
Case Study of Product Line Engineering in Insurance Company;Since every insurance company has several channels for selling the insurance to customer, it was very good business area for applying the product line engineering concept. With common business components, each channel application can be produced by reusing and extending them. But the problem was variability management. Variability management is the most important in product line engineering. It is a basic and essential principle to identify common elements as components and to make them assets of product line. These days, business rule is getting more critical key for successful RTE (real time enterprise). It means separating rules can make easy change or fast adapt to new business context without modifying application. The elements of variability which change with each application are viewed as variability of business rules. Therefore, when there is need to change business requirements;
Achieving Speed in Legacy Systems;The ability to rapidly respond to customer interest and to effectively prioritize development effort has been a longstanding challenge for mass-market software intensive products. This problem is exacerbated in the context of software product lines as functionality may easily fall over software asset and organizational boundaries with consequent losses in efficiency and nimbleness. In this tutorial, we discuss these challenges;
Enabling Verifiable Conformance for Product Lines;NASA is, with the rest of industry, turning to product-line engineering to reduce costs and improve quality by effectively managing reuse. Experience in industry has shown that it is the verifiable conformance of each system to the product-line specifications that makes or breaks the product-line practice. Verification that the software for each project satisfies its intended product-line constraints is thus essential. This paper reports early results from aneffort to assemble from previous, industrial experience a set of enablers of verifiable conformance for use in the application engineering of NASA product lines. Lessons learned may be useful for developers of safety-critical, long-lived, or highly autonomous productlines, as well as for companies that integrate product line subsystems developed by multiple contractors.;
SEI's software product line tenets;Software product lines are emerging as a viable, important software development paradigm. Based on the Software Engineering Institute's research and experience, the concepts, activities, and practices described here can lead to successful product line development. How-to's, success stories, and lessons learned expand on the approach.;
Integrated Variability Modeling of Features and Architecture in Software Product Line Engineering;Existing methods and tools supporting product line variability management typically emphasize either the feature or the architecture level. There have been attempts to combine these aspects, but no widely accepted method is available so far. This paper reports ongoing research in designing and implementing product line variability models, where the focus lies in treating features and architectural elements as parts of an integrated model. The research is carried together with our industry partner Siemens VAI;
Domain-Specific Modeling and Code Generation for Product Lines;Current modeling languages provide surprisingly little, if any, support for product line development. They are either based on the code world using the semantically well-defined concepts of programming languages (e.g. UML, SA/SD) or based on an architectural view using a simple component-connector concept. In both cases, the languages themselves say nothing about a product family or its variants. This situation could be compared to that of a programmer being asked to write object-oriented programs where the language does not support any object-oriented concepts.;
Experiences with Product Line Development of Multi-Discipline Analysis Software at Overwatch Textron Systems;This report explains the challenges experienced as Overwatch Textron Systems transitioned to a software product line approach. Overwatch Textron Systems provides both software products and custom software development in the domain of intelligence planning, collection and analysis to the U.S. Government and its allies. This report: a) Describes the approach taken to transition Overwatch Textron Systems to a product line organization. b) Provides an overview of the Overwatch Textron Systems software product line;
Modeling and Reasoning about Software Systems Containing Uncertainty and Variability;Summary form only given. When building large software-intensive systems, engineers need to express and reason about at least two different types of choices. One type concerns uncertainty - choosing between different design alternatives, resolving inconsistencies, or resolving conflicting stakeholder requirements. Another type deals with variability - supporting different variants of software that serve multiple customers or market segments. Partial modeling has been proposed as a technique for managing uncertainty within a software model. A partial model explicates points of uncertainty and represents the set of possible models that could be obtained by making decisions and resolving the uncertainty. Methods for reasoning about the entire set of possibilities, transforming the entire set and uncertainty-reducing refinements have recently been developed. Software product line engineering approaches propose techniques for managing the variability within sets of related software product variants. Such approaches explicate points of variability (a.k.a.features) and relationships between them in an artifact usually referred to as a feature model. A selection of features from this model guides the derivation of a specific product of a software product line (SPL). Techniques for reasoning about sets of SPL products, transforming the entire SPL and supporting their partial configuration have recently been developed. Partial models and SPL representations are naturally quite similar - both provide ways of encoding and managing sets of artifacts. The techniques for representing, reasoning with and manipulating these sets, naturally, have much in common. Yet, the goals for creating these product sets are quite different, and thus the two techniques lead to distinct methodological considerations. Uncertainty is an aspect of the development process itself;
Dynamic Software Product Lines;Economies of scope imply mass customization, which can be defined as producing goods and services to meet individual customers' needs with near mass production efficiency. Product line engineering (PLE) provides a means of customizing variants of massâ€“produced products. Its key aim is to create an underlying architecture for an organization's product platform in which core assets can be reused to engineer new products from the basic family. Developers have successfully applied software product lines (SPLs) in many different domains â€“ including avionics, medical devices, and information systems â€“ in a wide variety of organizations. In addition, modern computing and network environments demand a higher degree of adaptability from their software systems. Computing environments, user requirements, and interface mechanisms between software and hardware devices, such as sensors, can change dynamically during runtime. In dynamic software product lines (DSPLs), monitoring the current situation and controlling the adaptation are the central tasks;
An Approach of Product Configuration with Modular Product Family and its Applications to PC Configuration;Modular structure of product family is established with generic modules, and the module model denoted by attribute variable is established for each generic module. Then, customer requirements are translated into value of module attributes and the candidate set of modules nearest to customer requirements are retrieved and combined to obtain the final product. Finally, the model of modular product family is applied to solve the configuration of personal computer (PC) efficiently.;
Challenges and Opportunities for Sustainable Software;With the increasing role played by software in supporting our society, its sustainability and environmental impact have become major factors in the development and operation of software-intensive systems. Myths and beliefs hide the real truth behind Green IT: IT is energy-inefficient because software is developed to make it so - intentionally or not. But how far are we from being able to control software energy-efficiency? What makes software greener? How can we transform measuring software energy consumption in a general practice? What architectural design decisions will result in more sustainable systems? How can we ensure that new-generation software will be both cloud-ready and environmental-friendly? and How can we make evident the economic and social impact of developing software with 'energy in mind'? These are a few of the challenges ahead for a more sustainable digital society. This talk will discuss them, hence drawing directions for exciting challenges, promising opportunities, and ultimately inspiring research.;
Organizing for software product line engineering;Software product line engineering is the discipline of engineering a set of software-intensive systems sharing a common, managed set of features that satisfy the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way. The organizational characteristics required to successfully carry out software product line engineering will vary according to an organization's needs. However in general competitive advantage in software product line engineering lies in an organization's capacity to learn and adapt its products accordingly. This paper presents the conditions for a learning organization from management theory and argues that these conditions must prevail for software product line engineering to succeed.;
Change control for product line software engineering;Product line software engineering (PLSE) has proved to be an effective way to benefit from code reuse, leading to improved development efficiency, time-to-market, and product quality. In PLSE, a set of related products is developed by combining reused core assets with product-specific custom assets. Core assets implement most product functionality, and support variable functionality. Custom assets integrate a product's core assets, instantiate variation points, and implement functionality unique to the product. PLSE poses challenges for change control. Software engineering change control is related to configuration management (CM), and is concerned with planning, coordinating, tracking, and managing the impact of change to software artifacts (e.g. source code). The root cause of change control problems for PLSE is that core assets are shared between products that have different stakeholders. Core assets must satisfy the sometimes conflicting needs of these stakeholders. This position paper lists some specific change control problems characteristic of, or exacerbated by, PLSE and some of their solutions. These were observed during the author's prior experience working in a company that adopted PLSE and maintained product lines.;
Avionics product line software architecture flow policies;In 1995, an initiative was launched to assess the, potential for reuse of operational flight program software across multiple fighter aircraft platforms, and to define and demonstrate a supporting system architecture based upon open commercial hardware, software, standards and practices. The following year, this validation of the product line approach led to broader application of the techniques to the tactical aircraft mission processing domain. Key aspects of the component based logical architecture developed have been previously described. This paper briefly restates principle results from the previously published work to set the context for discussion. It then describes the flow policies, to be subsequently defined, developed on the project that substantively affect the product line reusability and suitability of the developed application components.;
Feature modeling from holistic viewpoints in product line engineering;In the field of software intensive systems, the software industry inherently requires a new method to obtain a high level of productivity by reuse of software embedded in the systems. Product line engineering is an emerging software engineering discipline with the new approach that makes it efficient to reuse embedded software by scoping a domain of systems. Features are described with terms for system requirements, which cover both functional requirements and nonfunctional requirements. Features are deployed in a tree figure, such that a general feature consists of subordinate features. The feature tree has a central role in system design and development. To construct a feature tree, the construction must be based on all fundamental design knowledge about a domain of systems such as of integrated circuits and mechanical devices as well as software entities because all design knowledge in any engineering disciplines in a domain of systems affect commonality and variability modeling in the feature tree. The feature modeling therefore needs a global systems engineering viewpoint.;
Reducing the Test Effort of Variability-Rich Systems by Using Feature Interaction Knowledge and Variability-Aware Source Code Analysis;To keep up with the growing demand for customized software solutions that are tailored to specific customer requirements, techniques like Software Product Line Engineering (SPLE) or the more ad-hoc clone-and-own (where engineers do not build each product from anew, but instead maximize the reuse of the available assets in building product families) have been devised. However testing such highly variable software systems has proven challenging. To improve this, the goal of this doctoral research plan is to propose an automated approach to reduce the effort for testing, while improving its effectiveness. The proposed approach aims to detect code parts that have to be considered when devising a test suite by employing source code analysis and test execution monitoring, which we argue have not been used to their full potential in this context.;
Software architecture development for product line software;In 1995, an initiative was launched to assess the potential for reuse of operational flight program software across multiple fighter aircraft platforms, and to define and demonstrate a supporting system architecture based upon open commercial hardware, software, standards and practices. This initiative produced a set of reusable object oriented navigation software, which was flight tested on several different aircraft platforms hosted on different hardware configurations. The following year, this validation of the product line approach led to broader application of the techniques to the tactical aircraft mission processing domain. Key aspects of the component based logical architecture developed have been previously described. This paper traces the process used to develop the Software Architecture used for this project.;
Synthesize software product line;In the development of a Software Product Line (SPL), it is useful to compare various products in order to identify reusable assets and synthesize them in an optimized way. Current differencing approaches provide the difference on a low level thus still leaves the SPL practitioner considerable manual synthesis work. This paper presents a comparison approach based on Common Variability Language (CVL), which is able to identify the difference on a higher conceptual level. We believe that our CVL Compare approach will offer better model comparison support in the context of identifying and synthesizing SPLs.;
Design for Maintenance - Use of Engineering Principles and Product Line Technology;Software systems become increasingly complex, embedded into critical technical or business environments, evolving, and long-living. Other engineering disciplines design for modifiability, testability, and many other â€“ilities a-priori. In software engineering we teach the corresponding principles and laws in software engineering curricula, but we have failed to introduce them into wide-spread practice. There are 2 major reasons for this dissatisfactory situation. First, basic engineering principles for software engineering such as â€œinformation hidingâ€ are being taught as scientific concepts, but scaling engineering style application guidelines are missing. Second, software is too a large portion built by people who have never been taught the basics of software engineering. In this presentation critical engineering principles and laws are being presented. They are part of the existing body of knowledge in our field, and they should be considered mandatory in order to avoid violation of due diligence charges. In addition, it will be demonstrated how they can be applied and checked in real projects. Finally, the software product line engineering approach will be presented as incorporating many of these principles and laws. Its potential will be illustrated using real-world examples. The main purpose of this presentation is to demonstrate that we have a large body of knowledge in our field to improve current practice. But improper mindset, technology transfer, and education are prohibiting faster progress.;
Problems and suggestions for adopting product line software engineering from modification style development;In the intense business competitive situation of today, it is an important theme to improve software development productivity and shorten a software development period. There is product line software engineering (PLSE) as technology to contribute to this theme. However, many types of problems are thought to start adoption of PLSE. Not only economical issues, technical issues, and project risks, but also issues related time to market during core asset development, are identified. This paper address the problems which are identified at a project initiation phase in the PLSE startup organization which usually develops a new product's software by modification and discuss some ideas to deal with theses problems.;
Unburdening Onboarding in Software Product Lines;The number of studies focusing on onboarding in software organizations has increased significantly during the last years. However, current literature overlooks onboarding in Software Product Lines (SPLs). SPLs have been proven effective in managing the increasing variability of industry software and enabling systematic reuse of a product family. Despite these benefits, SPLs are complex and exhibit particular characteristics that distinguish them from traditional software. Due to these peculiarities, SPLs require a tailor-made onboarding process. Assistance tools might help. In this dissertation, we propose assistance tools (i.e., tools built on top of the software project that help learners understand and develop knowledge) as a means for helping newcomers during onboarding in SPLs.;
Building domain specific software architectures from software architectural design patterns;Software design patterns are best practice solutions to common software problems. However, applying design patterns in practice can be difficult since design pattern descriptions are general and can be applied at multiple levels of abstraction. In order to address the aforementioned issue, this research focuses on creating a systematic approach to designing domain specific distributed, real-time and embedded (DRE) software from software architectural design patterns. To address variability across a DRE domain, software product line concepts are used to categorize and organize the features and design patterns. The software architectures produced are also validated through design time simulation. This research is applied and validated using the space flight software (FSW) domain.;
Multi-company Consumer Product Software Test Architecture Industry Experience Report;A case study is presented for a consumer hardware company which added software into the product line with little process-based test planning, including not having a software test architecture (STA). The paper presents the problem, solution, and limitations of the case study as well as future work.;
Research on the Family Design Method of Product by 3D Printing;With the development and mature of 3D printing technology, it has been widely used in various fields. With the great wealth of material life, the product want to occupy more market share, so it is necessary to meet the needs of users as much as possible, therefore, Product family design has gradually become one of the important design strategy of product development. The visual characteristics of the products of the same or similar image is an important way of product family design. Based on the 3D printing and the computer technology, This paper will explore the way of visual image interpretation of product family design, to fast develope series products, and take the initiative in market competition for the enterprise.;
The 3-Tiered Methodology: Pragmatic Insights from New Generation Software Product Lines;Early generation software product line (SPL) methodologies tended to be large, complex, and offer many options and choices, making adoption in practice difficult to comprehend, justify and achieve. We have identified a simpler pattern for SPL methodology, referred to as the 3-Tiered Methodology, based on observations during deployments and operation of new generation SPL practices. This methodology is useful not only for the operation of full-scale SPL practice, but also in understanding, explaining and justifying SPLs, as well as for planning and making transitions to SPL practice.;
Software product line market repositioning: The power of functional groups;This is a longitudinal study of change process as it applies to software product line evolution. The objective is to study and describe changes in software product line that occurred after top management team of a supplier of hardware and software for telecommunication equipments decided to change the target market for its software intensive telecommunication products as a result of market decline. This company has a proven record of innovation and technological breakthroughs and has offices in Europe, North America, Africa, and Asia. The study is divided into three phases. The next phase in this study is to look at the relationships between functional groups and to try and answer the question: â€œDoes the power of functional groups closest to the customer increases during sales declines?â€ The analysis of the data available to us shows that functional groups that were closer to the customers increase their relative size;
The influence of organisational factors on the success and quality of a product-line architecture;The quality of a product-line architecture is strongly affected by its maintenance process, business environment, organisational culture and management practices. The organisational factors which affect the architecture are hardest to detect since their influence on the code and other development artefacts are typically not documented. We have conducted two case studies at Australian organisations to study the influence of organisational factors on the success and quality of a product-line architecture. In our work, we have found organisational factors which affect the quality of the code and architecture. However, although the success of the architecture depends on a certain level of quality, the success of the architecture is rarely measured by its quality. Architectural success is often measured by product sales, which only have a tenuous relationship with the architectural quality. Thus, an organisation may have a successful product-line which is costly to maintain. The results from our case study research are presented in this paper.;
Software Product Line Engineering with Personas;In this paper, a user-centered and mass-customized design process is proposed that unifies Personas and Software Product Line Engineering (SPLE). The key to this proposal is the relationship between persona-weighted feature matrices and product-feature matrices. We propose a development method that (1) creates personas before the product portfolio scoping stage, and (2) adds extra personas during the application engineering stage. Applicable domains are discussed, and methods for evaluating the approach are reported.;
IEEE Guide to Software Configuration Management;The application of configuration management (CM) disciplines to the management of software engineering projects is described. For those planning software configuration management (SCM) activities, this guide provides insight into the various factors that must be considered. For users implementing SCM disciplines, suggestions and detailed examples of plans are provided. An interpretation is given of how ANSI/IEEE Std 828-1983, IEEE Standard for Software Configuration Management Plans, can be used for planning the management of different kinds of computer program development and maintenance activities.;
Blockchain-based Configuration Management System;For SW development convenience, various development support systems like configuration management system, CI/CD, and Bugtrack system are required. Many open projects are underway using the connected environment advance of the internet. This open project uses a sharing configuration system. However, the source code history stored in the configuration system may be lost due to hw fault or managerâ€™s mistake. In this study, we propose a blockchain-based configuration system to solve these problems. The proposed configuration system grafts the configuration unit function to the blockchain platform. In order to verify the effectiveness of the blockchain based configuration system proposed in this study, the functions to be provided by the configuration system and the functions provided by the blockchain platform were verified. As a result, it was confirmed that both functions were perfectly provided. If the configuration system proposed in this study is applied to an open project, data loss prevention and integrity can be guaranteed by applying the strengths of the blockchain platform while keeping the original purpose of the configuration management system. However, since this study used a blockchain platform, there is a limitation in not checking the performance. Therefore, further research on this is needed.;
Evolution Feature Oriented Model Driven Product Line Engineering Approach for Synergistic and Dynamic Service Evolution in Clouds: Pattern Data Structure;Evolution pattern will be defined as an Xml Schema document, the generation of pattern aspect is the process of generating xml instance from its related Xml Schema definition document. The process can be iterative until all the evolution requirement carried by the specific evolution feature has been realized by each evolution pattern aspect (Model Driven Architecture).;
Software product lines: reuse that makes business sense;Summary form only given. Traditionally, software-intensive systems have been acquired, developed, tested, and maintained as separate products, even if these systems have a significant amount of common functionality and code. Such an approach wastes technical resources, takes longer, and costs more than necessary. A product line approach to software can reduce development cycles, improve return on software investments, improve software system integration, and give an organization more future options. Building a new product or system becomes more a matter of assembly or generation than creation, of integration rather than programming. Organizations of all types and sizes are discovering that a product line strategy, when skillfully implemented, can improve productivity, quality, and time to market. Software product lines present at long last a reuse strategy with real economic benefit. Making the move to product lines, however, is a business and technical decision and requires considerable changes in the way organizations practice software engineering, technical management, and organizational management. This article explores the basic concepts of software product lines, share experience reports from companies employing the paradigm, and explore the software engineering and management practices necessary to develop a successful software product line;
Software Product Lines Approach in Enterprise System Development;Enterprise software is an untapped area for software product lines (SPL) approach. Our current understanding of enterprise SPL is as follows. The enterprise SPL is based upon an application centric architecture, which manages variability of platform and non-functional requirements, and achieves variability management for functional requirements in an application layer. NRI has been executing this approach through two projects, (I) development of semi made-to-order package software for the retail chains and (II) restructuring of enterprise systems owned by Seven & i Holdings, the biggest conglomerate of retail industry in Japan. This paper mainly describes what application centric architecture is and how this approach differs from others with lessons learned for the last five years.;
The Scoping Game;Product Line Scoping sets the boundary (scope) between those products, features, etc., that are in a Software Product Line and those that are out of the Product Line. Scoping is an essential activity in Product Line Engineering because this boundary defines the limits within the product Line's core assets must be reusable.;
Reducing avionics software cost through component based product line development;This paper focuses on two important characteristics of the software architecture: layered architecture and medium grained architecture. It is important to note that both of these characteristics derive directly from the original goals of encapsulating change and maximizing reuse. The layering aspect especially relates to developing an application that is independent of the hardware and avionics specifics of a single aircraft. The medium granularity of the components provides a system that can be deployed on varying numbers of processors in single processor or distributed hardware configurations. Both of these goals directly relate to the original decision of developing a product line software system.;
Product Reconfiguration Based on Generalized Modular Design;Scope of application of generalized modular design is discussed on the base of the generalized modular design and its relative concepts, and the technology of product reconfiguration is introduced on the regulation of reconfigurable product family, modeling, module expansion & assembling. An example of product family of hydraulic press machine is given to illustrate the theory and methodology of generalized modular design.;
Developing mobile browsers in a product line;Product lines must be product and application driven instead of reuse or platform driven, at least, that is the lesson learned at Nokia. The paper considers how the mobile phone company initiated and used a product line to develop and deliver mobile browser products. These products let mobile phone or personal digital assistant users access services over wireless telecommunications networks.;
When to Extract Features: Towards a Recommender System;In practice, many organizations rely on cloning to implement customer-specific variants of a system. While this approach can have several disadvantages, organizations fear to extract reusable features later on, due to the corresponding efforts and risks. A particularly challenging and poorly supported task is to decide which features to extract. To tackle this problem, we aim to develop a recommender system that proposes suitable features based on automated analyses of the cloned legacy systems. In this paper, we sketch this recommender and its empirically derived metrics, which comprise cohesion, impact, and costs of features as well as the users' previous decisions. Overall, we will facilitate the adoption of systematic reuse based on an integrated platform.;
Supporting product line development;The author considers how the maturation of the software development field has been inextricably tied to its adoption of a product line orientation. Only by specializing in a particular application domain can software development organizations develop the expertise required for that domain, develop cost effective products, and establish a market niche. He argues that software development processes are fundamentally flawed because maintenance, including enhancement and evolution, is performed on source code. This source code has been hand optimized by programmers and that optimization has spread information and built up implicit dependencies among the parts.;
Feature-oriented analysis and aspect-oriented product line assets development;A feature-oriented approach has been used extensively in product line engineering, as it provides an effective way of identifying variabilities among products. However, incorporating feature variations into product line assets is still a difficult undertaking, as effects of a feature variation may affect a large part of product line assets. In this position paper, I propose an approach of feature-oriented analysis and aspect-oriented component development, which can improve reusability and adaptability of product line assets as well as traceability from requirements to design.;
Constructing generic processes based on tree unification for process family planning;Planning process families in relation to product families has been well recognized as a promising approach to achieving production stability and efficiency, where diverse customized products are involved. As with generic products accommodating product family design, generic processes facilitate process family planning in producing the corresponding product families. In view of the fact that a production process is commonly represented as a tree, this paper puts forward an approach based on tree unification to construct generic processes from large volumes of data existing in companies' databases. The preliminary results of applying the proposed approach to electronic products have demonstrated the feasibility and potential of constructing generic processes based on tree unification.;
Test cost saving and challenges in the implementation of /spl times/6 and /spl times/8 parallel testing on freescale 16-bit HCS12 microcontroller product family;One of the pressing issues faced by the semiconductor industry today is the cost of testing, especially on the low cost and high volume microcontroller (MCU) supply to automotive market. This paper describes the general consideration and justification made on the investment of tester, handler and device interface board (DIB) to enable the /spl times/6 and /spl times/8 multi-site testing on the 80 and 112pin counts 16-bit HCS12 MCU in quad flat pack (QFP) package and the associate test cost reduction and tester saving estimation. Test issue encounter on the first spin of /spl times/6 and /spl times/8 DIB and how it was resolved through re-design of the DIB also is presented. This finding also provide the PCS designer the valuable information on the constraint of trace length and component layout one need to take into consideration when design a multi-site DIB use for high speed MCU testing to avoid AC or DC test failure induced by excessive capacitive loading and resistance drop over signal trace on the DIB.;
Towards a co-evolution model for software product lines based on cladistics;The evolution of a software product line is more challenging than the evolution of a single product, because its artifacts depend on many products. If a change is not well studied, it can break the integrity of the reference architecture of the software product line and all the derived products. Hence, when dealing with evolution, the understanding of change and its impact must be the most important activity. Biology is the science which studied evolution the most. Therefore it was necessary for us to understand evolution in biology in order to handle evolution in software product lines. This paper presents our approach to deal with change understanding in software product line using co-evolution analysis which was used in biology to understand how organisms influence each other during their evolution over time. Similarly to biological co-evolution, the co-evolution of artifacts of a software product line consists on analyzing how the evolution of an artifact influences the evolution of the others. The input data used in our approach are extracted from the history of changes that happened to each version of the software product. Our objective is to establish a co-evolution model for software product lines using Cladistics classification which illustrates the evolution of a population through an evolutionary tree.;
Process Lines: A Product Line Approach Designed for Process Model Development;Standard process models like RUP or the German V-Modell XT are developed to be used in an organizational environment. Yet introducing such a process model into an organization is no simple task. It is usually accompanied by either reorganizing internal processes to comply with a standard process model or by adaptation of the process model to organizational structures. The latter is an approach that can often be found in practice and is subject to this paper.The paper describes a generalization of the process model architecture of the V-Modell XT 1.3. Compared to the previous version 1.2.1.1, its metamodel has completely been revised with respect to a new adaptation concept. We will see how this concept allows the implementation of a so called process line. Software process lines are derived from software product lines and can be used for the adaptation of standard processes during process model development, project initialization and project runtime.;
Software Reuse Based on Business Processes and Requirements;Software reuse is often just addressed at the level of code or low-level design. In contrast, this tutorial explains software reuse based on business processes and requirements. It presents and compares three approaches co-developed by the presenter over more than a decade. The first of these approaches deals with requirements reuse in the context of product lines. It makes the relations among product line requirements explicit, so that single system requirements in this product line can be derived consistently. A key issue is commonality and variability across different products. This tutorial shows how requirements for a product line can be modeled, selected and reused to engineer the requirements for innovative new products. The second approach for software reuse involves case-based reasoning. Instead of explicit relations between requirements (or other artifacts), similarity metrics are employed for finding the most similar software case in a repository to a given set of requirements. This even works when a single envisioned usage scenario is specified yet, and it allows reusing also requirements from retrieved cases. The major point, however, is to facilitate reusing software design (including architecture) and code from similar software cases. The third approach (still under development) strives for (partly) automating software development for certain business applications through reusing business knowledge and software, where both are tightly connected. It involves automated reuse of business processes, and software executing them, based on ontological knowledge. A key point is closing the representational gap between procedurally represented business processes and declaratively represented concepts and their relations, taxonomies, partonomies, etc. So, this is an ontology-based approach for (partly) automated software development guided by business models.;
Requirements management in a product line scenario;Summary form only given. The product line approach is a major reuse concept that has shown concrete commercial results over the past years. Product lines achieve reuse in the functionality and solution space, and thus improve quality, cycle time and cost. They are specifically promising in cases where many variants are produced almost simultaneously, such as in telecommunication systems. Though appealing, the concept is difficult to introduce specifically into an existing development environment. All too often the impacts on requirements management are not considered globally enough. The opposite of a product line concept is to allow every variant of a product to implement its own requirements only loosely coupled to the base product. This article describes the introduction of a product line approach in Alcatel's S12 Switching System Business Unit. Success factors are described related to the interface with marketing, requirements definition, roadmapping and portfolio management, requirements reuse, planning and prioritization incremental development, and configuration management are explained. Practical impacts are described as well as tricks and traps.;
Evaluating Product Line Architectures: Methods and Techniques;Summary form only given. Good software architecture is one of the key factors in successfully developing and evolving a system or a family of systems. Software architecture provides the key framework for the earliest design decisions taken to achieve functional and quality requirements. In addition, it has a profound influence on project organizations' functioning and structure. Poor architecture usually results in project inefficiencies, poor communication, and poor decision making. Software architecture for a family of systems also helps identify the commonality among different systems and explicitly document variability. Since software architecture plays a significant role in the life of a system, it is important to evaluate a system's architecture as early as possible. Architecture evaluation is considered one of the most important and effective techniques of addressing quality related issues at the software architecture level and mitigating architectural risks. Moreover, architecture evaluation sessions are an effective means of sharing and capturing architecture design rationale, reasoning behind architecture design decisions. This tutorial highlights the benefits and challenges in evaluating software architectures. It discusses theoretical and practical concepts underpinning some of the well-known scenario-based architecture evaluation methods and various approaches to characterize quality attributes using scenarios. The use of the presented methods, techniques, and tools will be demonstrated with a case study based on an industrial project.;
IEEE Standard for Software Configuration Management Plans - Redline;The minimum required contents of a Software Configuration Management (SCM) Plan are established via this standard. This standard applies to the entire life cycle of critical software (e.g., where failure would impact safety or cause large financial or social losses). It also applies to noncritical software and to software already developed. The application of this standard is not restricted to any form, class, or type of software.;
Enhancing Requirements Reuse through Automated Similarity Matching;Summary form only given, as follows. The complete presentation was not made available for publication as part of the conference proceedings. Several socio-economic trends are driving customer demands towards individualization. Many suppliers are responding by offering supplier-led software product design customization choices (â€œmass customizationâ€). Some are also offering customer-led software product design choices (â€œmass personalizationâ€). This tutorial introduces these concepts and explores the implications for software product line development. One particular technical challenge is being able to respond to and manage at scale the increasing variety of common, supplier-led and customer-led features. We will discuss two different approaches to address this challenge. One is grounded in feature modelling, the other in case-based reasoning, where the latter relies on measuring similarities. We will then describe a specific product similarity evaluation process in which a product configured from a product line feature model is represented as a weighted binary string, the overall similarity between products is compared using a binary string metric, and the significance of individual feature combinations for product similarity can be explored by modifying the weights. We will illustrate our ideas with mobile phone worked examples, and discuss some of the benefits and limitations of this approach.;
Handling Safety-Related Feature Interaction in Safety-Critical Product Lines;The variation management of software product lines is currently handled without adequately taking safety or other system-level properties into account. This is largely due to (1) the fact that the available product-line variation-management techniques lack sufficient support for representing the combined effect of different features, and (2) the existing feature interaction techniques do not suffice for handling one-to-many feature interactions typical of many safety-critical product lines. The challenge is that we need to track the safety-related feature interactions while still promoting reuse. The expected contribution of this work is to demonstrate how safety-related feature interactions can be better investigated and managed by the safety-analysis guided, model-based approach described in this paper.;
Requirements-driven configuration of emergency response missions with small aerial vehicles;Unmanned Aerial Vehicles (UAVs) are increasingly used by emergency responders to support search-and-rescue operations, medical supplies delivery, fire surveillance, and many other scenarios. At the same time, researchers are investigating usage scenarios in which UAVs are imbued with a greater level of autonomy to provide automated search, surveillance, and delivery capabilities that far exceed current adoption practices. To address this emergent opportunity, we are developing a configurable, multi-user, multi-UAV system for supporting the use of semi-autonomous UAVs in diverse emergency response missions. We present a requirements-driven approach for creating a software product line (SPL) of highly configurable scenarios based on different missions. We focus on the process for eliciting and modeling a family of related use cases, constructing individual feature models, and activity diagrams for each scenario, and then merging them into an SPL. We show how the SPL will be implemented through leveraging and augmenting existing features in our DroneResponse system. We further present a configuration tool, and demonstrate its ability to generate mission-specific configurations for 20 different use case scenarios.;
Monte Carlo tree search for feature model analyses: a general framework for decision-making;The colossal solution spaces of most configurable systems make intractable their exhaustive exploration. Accordingly, relevant analyses remain open research problems. There exist analyses alternatives such as SAT solving or constraint programming. However, none of them have explored simulation-based methods. Monte Carlo-based decision making is a simulation-based method for dealing with colossal solution spaces using randomness. This paper proposes a conceptual framework that tackles various of those analyses using Monte Carlo methods, which have proven to succeed in vast search spaces (e.g., game theory). Our general framework is described formally, and its flexibility to cope with a diversity of analysis problems is discussed (e.g., finding defective configurations, feature model reverse engineering or getting optimal performance configurations). Additionally, we present a Python implementation of the framework that shows the feasibility of our proposal. With this contribution, we envision that different problems can be addressed using Monte Carlo simulations and that our framework can be used to advance the state of the art a step forward.;
A comparison of performance specialization learning for configurable systems;The specialization of the configuration space of a software system has been considered for targeting specific configuration profiles, usages, deployment scenarios, or hardware settings. The challenge is to find constraints among options' values that only retain configurations meeting a performance objective. Since the exponential nature of configurable systems makes a manual specialization unpractical, several approaches have considered its automation using machine learning, i.e., measuring a sample of configurations and then learning what options' values should be constrained. Even focusing on learning techniques based on decision trees for their built-in explainability, there is still a wide range of possible approaches that need to be evaluated, i.e., how accurate is the specialization with regards to sampling size, performance thresholds, and kinds of configurable systems. In this paper, we compare six learning techniques: three variants of decision trees (including a novel algorithm) with and without the use of model-based feature selection. We first perform a study on 8 configurable systems considered in previous related works and show that the accuracy reaches more than 90% and that feature selection can improve the results in the majority of cases. We then perform a study on the Linux kernel and show that these techniques performs as well as on the other systems. Overall, our results show that there is no one-size-fits-all learning variant (though high accuracy can be achieved): we present guidelines and discuss tradeoffs.;
From Single- to Multi-Variant Model Transformations: Trace-Based Propagation of Variability Annotations;In annotative approaches to model-driven product line engineering (MDPLE), model elements are decorated with variability annotations defining the product variants in which they are included. A multi-variant model transformation (MVMT) has to propagate these annotations from source to target models. We propose trace-based propagation as a grey box solution to this problem: After executing a variability ignorant single-variant transformation (SVMT), annotations are propagated a posteriori based on the trace produced by the SVMT. Trace-based propagation allows to reuse SVMTs, and can be implemented in a generic way, independently of SVMT languages and tools, making it suitable for use in a heterogeneous MDPLE environment. A formal proof demonstrates that trace-based propagation achieves commutativity of filters and transformations, obviating the need to manually edit target model annotations.;
One Billion Apples' Secret Sauce: Recipe for the Apple Wireless Direct Link Ad hoc Protocol;Apple Wireless Direct Link (AWDL) is a proprietary and undocumented IEEE 802.11-based ad hoc protocol. Apple first introduced AWDL around 2014 and has since integrated it into its entire product line, including iPhone and Mac. While we have found that AWDL drives popular applications such as AirPlay and AirDrop on more than one billion end-user devices, neither the protocol itself nor potential security and Wi-Fi coexistence issues have been studied. In this paper, we present the operation of the protocol as the result of binary and runtime analysis. In short, each AWDL node announces a sequence of Availability Windows (AWs) indicating its readiness to communicate with other AWDL nodes. An elected master node synchronizes these sequences. Outside the AWs, nodes can tune their Wi-Fi radio to a different channel to communicate with an access point, or could turn it off to save energy. Based on our analysis, we conduct experiments to study the master election process, synchronization accuracy, channel hopping dynamics, and achievable throughput. We conduct a preliminary security assessment and publish an open source Wireshark dissector for AWDL to nourish future work.;
Forwarding and routing with packet subscriptions;In this paper, we explore how programmable data planes can naturally provide a higher-level of service to user applications via a new abstraction called packet subscriptions. Packet subscriptions generalize forwarding rules, and can be used to express both traditional routing and more esoteric, content-based approaches. We present strategies for routing with packet subscriptions in which a centralized controller has a global view of the network, and the network topology is organized as a hierarchical structure. We also describe a compiler for packet subscriptions that uses a novel BDD-based algorithm to efficiently translate predicates into P4 tables that can support O(100K) expressions. Using our system, we have built three diverse applications. We show that these applications can be deployed in brownfield networks while performing line-rate message processing, using the full switch bandwidth of 6.5Tbps.;
Health-Binning: Maximizing the Performance and the Endurance of Consumer-Level NAND Flash;"In recent years, the adoption of NAND flash in enterprise storage systems has been progressing rapidly. Todays all-flash storage arrays exhibit excellent I/O throughput, latency, storage density, and energy efficiency. However, the advancements in NAND technology are driven mostly by the consumer market, which makes NAND flash manufacturers focus primarily on reducing cost ($/GiB) and increasing the storage density by technology node scaling, by increasing the number of bits stored per cell, and by stacking cells vertically (3D-NAND). This comes at the cost of reduced endurance of the raw NAND flash, larger variations across blocks, and longer latencies, especially with extremely high error rates (due to the use of read-retry operations).
In this paper, we present Health Binning, a technique that facilitates bringing low-cost consumer-level flash to the quality required for enterprise-level storage systems. Health Binning determines the wear characteristics of each block in the background and uses this information in the data-placement process to map hotter data to healthier blocks and colder data to less healthy blocks.
Health Binning significantly improves the endurance and performance of the storage system: It actively narrows the block wear distribution and moves endurance from being dictated by the worst blocks towards to a value corresponding to the average endurance of all blocks, resulting in up to 80% enhanced endurance compared with other wear-leveling schemes. At the same time, the probability of reads with high raw bit error rates (RBER) is reduced, thereby decreasing the number of read-retry operations throughout the device lifetime.";
Foraging Among an Overabundance of Similar Variants;Foraging among too many variants of the same artifact can be problematic when many of these variants are similar. This situation, which is largely overlooked in the literature, is commonplace in several types of creative tasks, one of which is exploratory programming. In this paper, we investigate how novice programmers forage through similar variants. Based on our results, we propose a refinement to Information Foraging Theory (IFT) to include constructs about variation foraging behavior, and propose refinements to computational models of IFT to better account for foraging among variants.;
"Revealing the Shopper Experience of Using a ""Magic Mirror"" Augmented Reality Make-Up Application";"Virtual try-ons have recently emerged as a new form of Augmented Reality application. Using motion caption techniques, such apps show virtual elements like make-up or accessories superimposed over the real image of a person as if they were actually wearing them. However, there is as of yet little understanding about their value for providing a viable experience. We report on an in-situ study, observing how shoppers approach and respond to such a ""Magic Mirror"" in a store. Our findings show that after the initial surprise, the virtual try-on resulted in much exploration when shoppers looked at themselves on a display integrated in the make-up counter. Behavior tracking data from interactions with the mirror supported this. Moreover, survey data measured perceptions of augmentation as well as hedonic and utilitarian value of the app and suggested the augmented experience was perceived to be playful and credible while also acting as a strong driver for future behavior. We discuss opportunities and challenges that such technology brings for shopping and other domains.";
Compiling first-order functions to session-typed parallel code;"Building correct and efficient message-passing parallel programs still poses many challenges. The incorrect use of message-passing constructs can introduce deadlocks, and a bad task decomposition will not achieve good speedups. Current approaches focus either on correctness or efficiency, but limited work has been done on ensuring both. In this paper, we propose a new parallel programming framework, PAlg, which is a first-order language with participant annotations that ensures deadlock-freedom by construction. PAlg programs are coupled with an abstraction of their communication structure, a global type from the theory of multiparty session types (MPST). This global type serves as an output for the programmer to assess the efficiency of their achieved parallelisation. PAlg is implemented as an EDSL in Haskell, from which we: 1. compile to low-level message-passing C code; 2. compile to sequential C code, or interpret as sequential Haskell functions; and, 3. infer the communication protocol followed by the compiled message-passing program. We use the properties of global types to perform message reordering optimisations to the compiled C code. We prove the extensional equivalence of the compiled code, as well as protocol compliance. We achieve linear speedups on a shared-memory 12-core machine, and a speedup of 16 on a 2-node, 24-core NUMA.";
SonicPrint: a generally adoptable and secure fingerprint biometrics in smart devices;The advent of smart devices has caused unprecedented security and privacy concerns to its users. Although the fingerprint technology is a go-to biometric solution in high-impact applications (e.g., smart-phone security, monetary transactions and international-border verification), the existing fingerprint scanners are vulnerable to spoofing attacks via fake-finger and cannot be employed across smart devices (e.g., wearables) due to hardware constraints. We propose SonicPrint that extends fingerprint identification beyond smartphones to any smart device without the need for traditional fingerprint scanners. SonicPrint builds on the fingerprint-induced sonic effect (FiSe) caused by a user swiping his fingertip on smart devices and the resulting property, i.e., different users' fingerprint would result in distinct FiSe. As the first exploratory study, extensive experiments verify the above property with 31 participants over four different swipe actions on five different types of smart devices with even partial fingerprints. SonicPrint achieves up to a 98% identification accuracy on smartphone and an equal-error-rate (EER) less than 3% for smartwatch and headphones. We also examine and demonstrate the resilience of SonicPrint against fingerprint phantoms and replay attacks. A key advantage of SonicPrint is that it leverages the already existing microphones in smart devices, requiring no hardware modifications. Compared with other biometrics including physiological patterns and passive sensing, SonicPrint is a low-cost, privacy-oriented and secure approach to identify users across smart devices of unique form-factors.;
Bayesian Deep Learning with Trust and Distrust in Recommendation Systems;Exploiting the selections of social friends and foes can efficiently face the data scarcity of user preferences and the cold-start problem. In this paper, we present a Social Deep Pairwise Learning model, namely SDPL. According to the Bayesian Pairwise Ranking criterion, we design a loss function with multiple ranking criteria based on the selections of users, and those in their friends and foes to improve the accuracy in the top-k recommendation task. We capture the nonlinearity in user preferences and the social information of trust and distrust relationships by designing a deep learning architecture. In each backpropagation step, we perform social negative sampling to meet the multiple ranking criteria of our loss function. Our experiments on a benchmark dataset from Epinions, among the largest publicly available that has been reported in the relevant literature, demonstrate the effectiveness of the proposed approach, outperforming other state-of-the art methods. In addition, we show that our deep learning strategy plays an important role in capturing the nonlinear associations between user preferences and the social information of trust and distrust relationships, and demonstrate that our social negative sampling strategy is a key factor in SDPL.;
The emerging role of data scientists on software development teams;Creating and running software produces large amounts of raw data about the development process and the customer usage which can be turned into actionable insight with the help of skilled data scientists. Unfortunately data scientists with the analytical and software engineering skills to analyze these large data sets have been hard to come by only recently have software companies started to develop competencies in software-oriented data analytics. To understand this emerging role we interviewed data scientists across several product groups at Microsoft. In this paper we describe their education and training background their missions in software engineering contexts and the type of problems on which they work. We identify five distinct working styles of data scientists: (1) Insight Providers who work with engineers to collect the data needed to inform decisions that managers make (2) Modeling Specialists who use their machine learning expertise to build predictive models (3) Platform Builders who create data platforms balancing both engineering and data analysis concerns (4) Polymaths who do all data science activities themselves and (5) Team Leaders who run teams of data scientists and spread best practices. We further describe a set of strategies that they employ to increase the impact and actionability of their work.;
Proceedings of the 38th International Conference on Software Engineering;Security metrics for software products provide quantitative measurement for the degree of trustworthiness for software systems. This paper proposes a new approach to define software security metrics based on vulnerabilities included in the software systems and their impacts on software quality. We use the Common Vulnerabilities and Exposures (CVE) an industry standard for vulnerability and exposure names and the Common Vulnerability Scoring System (CVSS) a vulnerability scoring system designed to provide an open and standardized method for rating software vulnerabilities in our metric definition and calculation. Examples are provided in the paper which show that our definition of security metrics is consistent with the common practice and real-world experience about software quality in trustworthiness.;
Proceedings of the 47th Annual ACM Southeast Conference;Software product line companies increasingly expand their platform outside their organizational boundaries in effect transitioning to a software ecosystem approach. In this paper we discuss the emerging trend of software ecosystems and provide a overview of the key concepts and implications of adopting a software ecosystem approach. We define the notion of software ecosystems and introduce a taxonomy. Finally we explore the implications of software ecosystems to the way companies build software.;
Proceedings of the 13th International Software Product Line Conference;Variability Management (VM) in Software Product Line (SPL) is a key activity that usually affects the degree to which a SPL is successful. SPL community has spent huge amount of resources on developing various approaches to dealing with variability related challenges over the last decade. To provide an overview of different aspects of the proposed VM approaches we carried out a systematic literature review of the papers reporting VM in SPL. This paper presents and discusses the findings from this systematic literature review. The results reveal the chronological backgrounds of various approaches over the history of VM research and summarize the key issues that drove the evolution of different approaches. This study has also identified several gaps that need to be filled by future efforts in this line of research.;
Proceedings of the 36th International Conference on Software Engineering;Software fails and fixing it is expensive. Research in failure prediction has been highly successful at modeling software failures. Few models however consider the key cause of failures in software: people. Understanding the structure of developer collaboration could explain a lot about the reliability of the final product. We examine this collaboration structure with the developer network derived from code churn information that can predict failures at the file level. We conducted a case study involving a mature Nortel networking product of over three million lines of code. Failure prediction models were developed using test and post-release failure data from two releases then validated against a subsequent release. One model's prioritization revealed 58% of the failures in 20% of the files compared with the optimal prioritization that would have found 61% in 20% of the files indicating that a significant correlation exists between file-based developer network metrics and failures.;
Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of Software Engineering;Variability modeling is essential for defining and managing the commonalities and variabilities in software product lines. Numerous variability modeling approaches exist today to support domain and application engineering activities. Most are based on feature modeling (FM) or decision modeling (DM) but so far no systematic comparison exists between these two classes of approaches. Over the last two decades many new features have been added to both FM and DM and it is tough to decide which approach to use for what purpose. This paper clarifies the relation between FM and DM. We aim to systematize the research field of variability modeling and to explore potential synergies. We compare multiple aspects of FM and DM ranging from historical origins and rationale through syntactic and semantic richness to tool support identifying commonalities and differences. We hope that this effort will improve the understanding of the range of approaches to variability modeling by discussing the possible variations. This will provide insights to users considering adopting variability modeling in practice and to designers of new languages such as the new OMG Common Variability Language.;
Proceedings of the 6th International Workshop on Variability Modeling of Software-Intensive Systems;Over more than two decades numerous variability modeling techniques have been introduced in academia and industry. However little is known about the actual use of these techniques. While dozens of experience reports on software product line engineering exist only very few focus on variability modeling. This lack of empirical data threatens the validity of existing techniques and hinders their improvement. As part of our effort to improve empirical understanding of variability modeling we present the results of a survey questionnaire distributed to industrial practitioners. These results provide insights into application scenarios and perceived benefits of variability modeling the notations and tools used the scale of industrial models and experienced challenges and mitigation strategies.;
Proceedings of the 7th International Workshop on Variability Modelling of Software-Intensive Systems;Today's software systems are typically composed of multiple components each with different versions. Software compatibility testing is a quality assurance task aimed at ensuring that multi-component based systems build and/or execute correctly across all their versions' combinations or configurations. Because there are complex and changing interdependencies between components and their versions and because there are such a large number of configurations it is generally infeasible to test all potential configurations. Consequently in practice compatibility testing examines only a handful of default or popular configurations to detect problems as a result costly errors can and do escape to the field.This paper presents a new approach to compatibility testing called Rachet. We formally model the entire configuration space for software systems and use the model to generate test plans to sample a portion of the space. In this paper we test all direct dependencies between components and execute the test plan efficiently in parallel. We present empirical results obtained by applying our approach to two large-scale scientific middleware systems. The results show that for these systems Rachet scaled well and discovered incompatibilities between components and that testing only direct dependences did not compromise test quality.;
Proceedings of the 2008 International Symposium on Software Testing and Analysis;Context: The quality of an Systematic Literature Review (SLR) is as good as the quality of the reviewed papers. Hence it is vital to rigorously assess the papers included in an SLR. There has been no tertiary study aimed at reporting the state of the practice of quality assessment used in SLRs in Software Engineering (SE).Objective: We aimed to study the practices of quality assessment of the papers included in SLRs in SE.Method: We conducted a tertiary study of the SLRs that have performed quality assessment of the reviewed papers.Results: We identified and analyzed different aspects of the quality assessment of the papers included in 127 SLRs.Conclusion: Researchers use a variety of strategies for quality assessment of the papers reviewed but report little about the justification for the used criteria. The focus is creditability but not relevance aspect of the papers. Appropriate guidelines are required for devising quality assessment strategies.;
Proceedings of the 19th International Conference on Evaluation and Assessment in Software Engineering;Service-oriented architectures (SOAs) are well established as an architectural paradigm for distributed systems. With software systems becoming more and more complex over time quality assurance becomes increasingly important. A clear understanding of software quality for SOA is therefore crucial in order to assure quality in the long run. In this paper we present a unifying meta-model to describe the quality of service-oriented systems as an enhancement of the Quamoco meta-model. To put these modeling concepts into practice we present examples from an initial quality model for SOA-based systems which is based on empirical results from other sources in the SOA quality community. By integrating these sources of information similarities as well as contradictions within and between the various models for SOA quality are made transparent. This is the baseline for defining a comprehensive SOA quality model. In addition this approach represents SOA's distinguishing features regarding quality modeling as first-class model entities to reduce modeling effort while increasing model expressiveness.;
Proceedings of the 8th International Workshop on Software Quality;The competitiveness has demanded from the software industry shorter delivery times for its products resulting in optimized life cycles generating a need to increase its performance to maintain competitiveness in the markets where they operate. This context has made productivity study so fundamental that organizations not only evaluate their performance but also provide means to improve it. The main goal of this paper is to investigate which factors affect productivity in software development projects and in open-source projects. In this work a Systematic Literature Review (SLR) was carried out in order to answer the research questions and a survey with practitioners community about their perception in relation to the factors of the productivity of the team. This empirical study led to the discovery of interesting factors that show how the different factors do (or do not) affect productivity. It was also found out that some factors appear to allow independence and responsibility of team while others appear to cause a better distribution of tasks. The results show how factors such as people product organization investment in technology lack of contractual relations and engagement of open-source project contributors influence productivity.;
Proceedings of the XXXIII Brazilian Symposium on Software Engineering;Software product lines of industrial size can easily incorporate thousands of variation points. This scale of variability can become extremely complex to manage resulting in a product development process that bears significant costs. One technique that can be applied beneficially in this context is visualisation. Visualisation is widely used in software engineering and has proven useful to amplify human cognition in data intensive applications. Adopting this technique in software product line engineering can help stakeholders in supporting essential work tasks and in enhancing their understanding of large and complex product lines.The research presented in this paper describes an integrated meta-model and research tool that employs visualisation techniques to address significant software product line tasks such as variability management and product derivation. Examples of the tasks are described and the ways in which these tasks can be further supported by utilising visualisation techniques are explained.;
Proceedings of the 4th ACM Symposium on Software Visualization;With the rise of containerization cloud development and continuous integration and delivery configuration has become an essential aspect not only to tailor software to user requirements but also to configure a software systemâ€™s environment and infrastructure. This heterogeneity of activities domains and processes blurs the term configuration as it is not clear anymore what tasks artifacts or stakeholders are involved and intertwined. However each re- search study and each paper involving configuration places their contributions and findings in a certain context without making the context explicit. This makes it difficult to compare findings translate them to practice and to generalize the results. Thus we set out to evaluate whether these different views on configuration are really distinct or can be summarized under a common umbrella. By interviewing practitioners from different domains and in different roles about the aspects of configuration and by analyzing two qualitative studies in similar areas we derive a model of configuration that provides terminology and context for research studies identifies new research opportunities and allows practitioners to spot possible challenges in their current tasks. Although our interviewees have a clear view about configuration it substantially differs due to their personal experience and role. This indicates that the term configuration might be overloaded. However when taking a closer look we see the interconnections and dependencies among all views arriving at the conclusion that we need to start considering the entire spectrum of dimensions of configuration.;
Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;Organizational factors influence the success of security initiatives in software development. Security audits and developer training can motivate development teams to adopt security practices but their interplay with organizational structures and routines remains unclear. We studied how security consultancy affected organizational routines in a software development group. Security consultants tested their product reported vulnerabilities and delivered a security training. We followed the group during and after consultancy events. As a result of the consultancy group members improved their understanding of security issues but could not effect a change of routines within the given organizational structure. They handled vulnerabilities in a stabilization routine without changes in feature development where security remained intangible. Interestingly group members acknowledged an unfulfilled need for change but defended the structure inhibiting change. Security initiatives need to consider this interplay of structure and situated practice and manage change in addition to providing expertise and tools.;
Proceedings of the 2017 ACM Conference on Computer Supported Cooperative Work and Social Computing;Software development projects are difficult to manage in general due to the friction between completing system features and at the same time obtaining a high degree of code quality to ensure maintainability of the system in the future. A major challenge of this optimization problem is that code quality is less visible to stakeholders in the development process particularly to the management. In this paper we describe an approach for automated software analysis and monitoring of both quality-related code metrics and development activities by means of software maps. A software map represents an adaptive hierarchical representation of software implementation artifacts such as source code files being organized in a modular hierarchy. The maps can express and combine information about software development software quality and system dynamics they can systematically be specified automatically generated and organized by templates. The maps aim at supporting decision-making processes. For example they facilitate to decide where in the code an increase of quality would be beneficial both for speeding up current development activities and for reducing risks of future maintenance problems. Due to their high degree of expressiveness and their instantaneous generation the maps additionally serve as up-to-date information tools bridging an essential information gap between management and development improve awareness and serve as early risk detection instrument. The software map concept and its tool implementation are evaluated by means of two case studies on large industrially developed software systems.;
Proceedings of the 2nd Workshop on Managing Technical Debt;"Industrial Control Systems (ICS) are central to the operation of critical national infrastructure (CNI) such as oil and gas water treatment power generation and transport systems. Effective risk management to mitigate large-scale disruption to societies and economies depends on both timely information about vulnerabilities and the consistency of this information. The longer the vulnerabilities remain in the wild"" or a lack of consistency in vulnerability reporting the greater the impact on CNI operators' ability to systematically understand and mitigate the risks. In this paper we focus on vulnerabilities identified and reported in Siemens ICS devices which hold the largest share of the market. We undertake an in-depth analysis of 207 CVEs identifying the time over which vulnerabilities were 'in the wild' before being discovered and advisories issued and examine issues with the correctness of CVE information. We find that on average a vulnerability is 'in the wild' for 5.3 years and that many CVEs do not correctly reflect and state the affected devices as Common Platform Enumerations (CPEs). Based on our findings we propose a set of guidelines to improve the reporting and consistency of ICS CVE information.""";
Proceedings of the 2020 Joint Workshop on CPS&ampIoT Security and Privacy;An open issue in industry is the combination of software reuse in the context of large scale Agile Software Development. The speed offered by Agile Software Development is needed for short time to market while reuse strategies such as Software Product Line Engineering are needed for long-term productivity efficiency and profit. The paper investigates through a survey communication factors affecting both speed and reuse in 3 large companies developing embedded systems and employing Agile Software Development and Software Product Line Engineering. Our results include a prioritized list of communication related factors obtained by statistical analysis and the recognition and spread of the factors in the companies. We have recognized 5 interfaces with the Agile development team that need to be improved: system engineers (architects) product management distributed teams inter-project teams and sales unit. Few factors (involving inter-project communication) depend on the business drivers for the company. We also reveal that Agile teams need strategic and architectural inputs in order to be implanted in a large company employing Software Product Line Engineering. Academic and industrial training as well as different tactics for co-location would improve the communication skills of engineers. There is also a need for solutions in the reference architecture for fostering Agile Software Development: the goal is the combination of the focus on customer value of the teams reusability system requirements and avoidance of organizational dependencies.;
Proceedings of the 17th International Software Product Line Conference;"Increasingly Software-as-a-Service (SaaS) is becoming a dominant mechanism for the consumption of software by end users. From a vendor's perspective the benefits of SaaS arise from leveraging economies of scale by serving a large number of customers (tenants"") through a shared instance of a centrally hosted software service. Consequently a SaaS provider would in general try to drive commonality amongst the requirements of different tenants and at best offer a fixed set of customization options. However many tenants would also come with custom requirements which may be a pre-requisite for them to adopt the SaaS system. These requirements should then be addressed by evolving the SaaS system in a controlled manner while still supporting the needs of existing tenants. This need to balance tenant variability and commonality and to optimize on development and testing effort can make the evolution of multitenant SaaS systems an interesting engineering challenge this has strong economic undertones as well given the ""pay-per-use"" subscription model of SaaS and the cost of incremental development and maintenance to cater to new tenant needs. In this paper we outline a set of research issues in the design testing and maintenance of multi-tenant SaaS systems and highlight some of the interesting optimization questions that arise in the process. Presenting specific technical solutions is beyond the scope of this paper - instead our goal is to help shape a research agenda for multi-tenant SaaS that can provide stimulus for further investigation into this area by the software and service engineering research community.""";
Proceedings of the 3rd International Workshop on Principles of Engineering Service-Oriented Systems;The concept of a Software ecosystem is gaining in popularity amongst large organizations and inherently relies on the adoption of common architectural development for multiple product development. The adoption of these approaches represents a significant shift in traditional software development style and process methodology. Currently several organizations are in practice with this new process model which embraces business third party involvement and open architecture as its central pillars and these institutions have thrived as a result. The advent of software ecosystems have caused major players in the software industry to rethink their operating practices and engage with third parties opening their platforms to external entities to attain business objectives. In this paper we present a three dimensional view of the software ecosystem model examine the role played by each of the three central pillars business architecture and social aspects. We further highlight their relationships and conclude that this study will help in further aiding understanding of the overall engineering process of ecosystem software.;
Proceedings of the Fourth European Conference on Software Architecture: Companion Volume;Software Product Lines (SPLs) are highly configurable systems. This raises the challenge to find optimal performing configurations for an anticipated workload. As SPL configuration spaces are huge it is infeasible to benchmark all configurations to find an optimal one. Prior work focused on building performance models to predict and optimize SPL configurations. Instead we randomly sample and recursively search a configuration space directly to find near-optimal configurations without constructing a prediction model. Our algorithms are simpler and have higher accuracy and efficiency.;
Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering;Many software defect prediction models have been built using historical defect data obtained by mining software repositories (MSR). Recent studies have discovered that data so collected contain noises because current defect collection practices are based on optional bug fix keywords or bug report links in change logs. Automatically collected defect data based on the change logs could include noises.This paper proposes approaches to deal with the noise in defect data. First we measure the impact of noise on defect prediction models and provide guidelines for acceptable noise level. We measure noise resistant ability of two well-known defect prediction algorithms and find that in general for large defect datasets adding FP (false positive) or FN (false negative) noises alone does not lead to substantial performance differences. However the prediction performance decreases significantly when the dataset contains 20%-35% of both FP and FN noises. Second we propose a noise detection and elimination algorithm to address this problem. Our empirical study shows that our algorithm can identify noisy instances with reasonable accuracy. In addition after eliminating the noises using our algorithm defect prediction accuracy is improved.;
Proceedings of the 33rd International Conference on Software Engineering;The number of software engineering research papers over the last few years has grown significantly. An important question here is: how relevant is software engineering research to practitioners in the field? To address this question we conducted a survey at Microsoft where we invited 3000 industry practitioners to rate the relevance of research ideas contained in 571 ICSE ESEC/FSE and FSE papers that were published over a five year period. We received 17913 ratings by 512 practitioners who labelled ideas as essential worthwhile unimportant or unwise. The results from the survey suggest that practitioners are positive towards studies done by the software engineering research community: 71% of all ratings were essential or worthwhile. We found no correlation between the citation counts and the relevance scores of the papers. Through a qualitative analysis of free text responses we identify several reasons why practitioners considered certain research ideas to be unwise. The survey approach described in this paper is lightweight: on average a participant spent only 22.5 minutes to respond to the survey. At the same time the results can provide useful insight to conference organizers authors and participating practitioners.;
Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering;The notion of features is commonly used to describe the functional and non-functional characteristics of a system. In software product line engineering features often become the prime entities of software reuse and are used to distinguish the individual products of a product line. Properly decomposing a product line into features and correctly using features in all engineering phases is core to the immediate and long-term success of such a system. Yet although more than ten different definitions of the term feature exist it is still a very abstract concept. Definitions lack concrete guidelines on how to use the notion of features in practice.To address this gap we present a qualitative empirical study on actual feature usage in industry. Our study covers three large companies and an in-depth contextualized analysis of 23 features perceived by the interviewees as typical atypical (outlier) good or bad representatives of features. Using structured interviews we investigate the rationales that lead to a feature's perception and identify and analyze core characteristics (facets) of these features. Among others we find that good features precisely describe customer-relevant functionality while bad features primarily arise from rashly executed processes. Outlier features serving unusual purposes are necessary but do not require the full engineering process of typical features.;
Proceedings of the 19th International Conference on Software Product Line;This paper introduces the idea of mining container image repositories for configuration and other deployment information of software systems. Unlike traditional software repositories (e.g. source code repositories and app stores) image repositories encapsulate the entire execution ecosystem for running target software including its configurations dependent libraries and components and OS-level utilities which contributes to a wealth of data and information. We showcase the opportunities based on concrete software engineering tasks that can benefit from mining image repositories. To facilitate future mining efforts we summarize the challenges of analyzing image repositories and the approaches that can address these challenges. We hope that this paper will stimulate exciting research agenda of mining this emerging type of software repositories.;
Proceedings of the 40th International Conference on Software Engineering: New Ideas and Emerging Results;Cloud-based applications are multi-tenant aware whereas customers (i.e. tenants) share hardware and software resources. Offering highly configurable applications to thousands of tenants in a shared cloud environment demands for scalable configuration management. Based on an example scenario taken from the Indenica project we identify requirements for applying methods from software product line (SPL) engineering to configure cloud-based multi-tenant aware applications. Using an extended feature model (EFM) to express variability of functionality and service qualities we propose a concept for dynamic configuration management to address the identified requirements. Our proposed configuration management includes an adaptive staged configuration process that is capable of adding and removing stakeholders dynamically and that allows for reconfiguration of variants as stakeholders' objectives change.;
Proceedings of the 16th International Software Product Line Conference - Volume 2;It has been shown that product line engineering can significantly improve the productivity quality and time-to-market of software development by leveraging extensive reuse. Variability models are currently the most advanced approach to define document and manage the commonalities and variabilities of reusable artifacts such as software components requirements test cases etc. These models provide the basis for automating the derivation of new products and are thus the key artifact to leverage the flexibility and adaptability of systems in a product line. Among the existing approaches to variability modeling feature modeling and decision modeling have gained most importance. A significant amount of research exists on comparing and analyzing different feature modeling approaches. However despite their significant role in product line research and practical applications only little effort has been devoted to compare and analyze decision modeling approaches. In order to address this shortcoming and to provide a basis for more structured research on decision modeling in the future we present a comparative analysis of representative approaches. We identify their major modeling concepts and present an analysis of their commonalities and variabilities.;
Proceedings of the 5th International Workshop on Variability Modeling of Software-Intensive Systems;Modern software often exposes configuration options that enable users to customize its behavior. During software evolution developers may change how the configuration options behave. When upgrading to a new software version users may need to re-configure the software by changing the values of certain configuration options.  This paper addresses the following question during the evolution of a configurable software system: which configuration options should a user change to maintain the software's desired behavior? This paper presents a technique (and its tool implementation called ConfSuggester) to troubleshoot configuration errors caused by software evolution. ConfSuggester uses dynamic profiling execution trace comparison and static analysis to link the undesired behavior to its root cause - a configuration option whose value can be changed to produce desired behavior from the new software version.  We evaluated ConfSuggester on 8 configuration errors from 6 configurable software systems written in Java. For 6 errors the rootcause configuration option was ConfSuggester's first suggestion. For 1 error the root cause was ConfSuggester's third suggestion. The root cause of the remaining error was ConfSuggester's sixth suggestion. Overall ConfSuggester produced significantly better results than two existing techniques. ConfSuggester runs in just a few minutes making it an attractive alternative to manual debugging.;
Proceedings of the 30th International Conference on Software Engineering;Variability models represent the common and variable features of products in a product line. Several variability modeling languages have been proposed in academia and industry however little is known about the practical use of such languages. We study and compare the constructs semantics usage and tools of two variability modeling languages Kconfig and CDL. We provide empirical evidence for the real-world use of the concepts known from variability modeling research. Since variability models provide basis for automated tools (feature dependency checkers and product configurators) we believe that our findings will be of interest to variability modeling language and tool designers.;
Proceedings of the 25th IEEE/ACM International Conference on Automated Software Engineering;Software testing faces up several challenges. One out of these is the opposition between time-to-market software delivery and the excessive length of testing activities. The latter results from the growth of the application complexity along with the diversity of handheld devices. The economical competition branding impose zero-defect products putting forward testing as an even more crucial activity. In this paper we describe a Domain-Specific Modeling Language (DSML) built upon an industrial platform (a test bed) which aims to automate mobile application checking. A key characteristic of this DSML is its ability to cope with variability in the spirit of software product line engineering. We discuss this DSML as part of a tool suite enabling the test of remote devices having variable features.;
Proceedings of the 5th European Conference on Software Architecture: Companion Volume;The use of the term ecosystem in the context of extensible software platforms and third-party developers or user communities has made us ponder about the similarities between software ecosystems and natural ecosystems. We therefore compare software ecosystems and natural ecosystems to present an agenda for further research by analyzing some key characteristics of both types of ecosystems. We discuss the regulatory factors and mechanisms existing in nature and then deduce key challenges that need to be dealt with in order to achieve healthy operation of software ecosystems.;
Proceedings of the 2011 ACM Symposium on Applied Computing;If you change the CS1 language to Python what is the impact on the rest of the curriculum? In earlier work we examined the impact of changing CS1 from C++ to Python while leaving CS2 in C++. We found that Python-prepared CS1 students fared no differently in CS2 than students whose CS1 course was in C++ even though CS2 was taught in C++ and covered the same topics as in previous years. Was that an anomaly? What happens in the next tier of courses? When our CS1 was first changed to Python there were many students who had taken CS1 in C++ still in the system. The result is that there is a cadre of students with either CS1 in Python or CS1 in C++ moving together through our curriculum. This one-time occurrence is an opportunity to study the students with many variables fixed. Our next tier of courses is a C-based computer organization course a C++ based object-oriented software design course and a data structures course. We found that the students who started with Python fared as well as the CS1 C++ students. As before the best predictor of performance was their college GPA. Python versus C++ CS1 preparation was not a predictor of performance in any course. We conclude again that in our C++ based curriculum changing CS1 to Python had no negative impact on student performance and did not require any significant change in those subsequent courses.;
Proceedings of the 41st ACM Technical Symposium on Computer Science Education;Much system software can be configured at compile time to tailor it with respect to a broad range of supported hardware architectures and application domains. A good example is the Linux kernel which provides more than 10000 configurable features growing rapidly.From the maintenance point of view compile-time configurability imposes big challenges. The configuration model (the selectable features and their constraints as presented to the user) and the configurability that is actually implemented in the code have to be kept in sync which if performed manually is a tedious and error-prone task. In the case of Linux this has led to numerous defects in the source code many of which are actual bugs.We suggest an approach to automatically check for configurability-related implementation defects in large-scale configurable system software. The configurability is extracted from its various implementation sources and examined for inconsistencies which manifest in seemingly conditional code that is in fact unconditional. We evaluate our approach with the latest version of Linux for which our tool detects 1776 configurability defects which manifest as dead/superfluous source code and bugs. Our findings have led to numerous source-code improvements and bug fixes in Linux: 123 patches (49 merged) fix 364 defects 147 of which have been confirmed by the corresponding Linux developers and 20 as fixing a new bug.;
Proceedings of the Sixth Conference on Computer Systems;This paper provides a highly opinionated and biased vision and a two-stage plan with guidelines to reach a new era of software development where anyone can create software without bothering to write code. Moreover this paper explores in depth the first of these stages which consists of creating a no-code tool based on six principles: configuration driven development APIs open-source cross-platform cloud computing and design systems. An examination of each principle is presented and a case is made for why such a combination of principles would lay the foundation for future development efforts. Possible enquiries are addressed and a path is laid out for future works.;
Proceedings of the 1st ACM SIGPLAN International Workshop on Beyond Code: No Code;In this paper we develop a vision of software evolution based on a feature-oriented perspective. From the fact that features provide a common ground to all stakeholders we derive a hypothesis that changes can be effectively managed in a feature-oriented manner. Assuming that the hypothesis holds we argue that feature-oriented software evolution relying on automatic traceability analyses and recommendations reduces existing challenges in understanding and managing evolution. We illustrate these ideas using an automotive example and raise research questions for the community.;
Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 1;Requirements engineering is recognized as a critical stage in software development lifecycle. Given the nature of Software Product Lines (SPL) the importance of requirements engineering is more pronounced as SPLs pose more complex challenges than development of a 'single' product. Several methods have been proposed in the literature which encompass activities for capturing requirements their variability and commonality. To investigate the maturity and effectiveness of the current requirements engineering approaches in software product lines we develop an evaluation framework containing a set of evaluation criteria and assess feature oriented requirements engineering methods based on the proposed criteria. As a result of this initial study we find out the majority of approaches lacks proper techniques for supporting the validation of family requirements models as well as dealing with delta requirements. Additionally capturing stakeholders' preferences and applying them during the course of software feature configuration have not been taken into account and addressed in the proposed approaches.;
Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;The key premise of an organization is to allow more efficient production including production of high quality software. To achieve that an organization defines roles and reporting relationships. Therefore changes in organization's structure are likely to affect product's quality. We propose and investigate a relationship between developer-centric measures of organizational change and the probability of customer-reported defects in the context of a large software project. We find that the proximity to an organizational change is significantly associated with reductions in software quality. We also replicate results of several prior studies of software quality supporting findings that code change and developer characteristics affect fault-proneness. In contrast to prior studies we find that distributed development decreases quality. Furthermore recent departures from an organization were associated with increased probability of customer-reported defects thus demonstrating that in the observed context the organizational change reduces product quality.;
Proceedings of the Eighteenth ACM SIGSOFT International Symposium on Foundations of Software Engineering;The advent of variability management and generator technology enables users to derive individual variants from a variable code base based on a selection of desired configuration options. This approach gives rise to the generation of possibly billions of variants that however cannot be efficiently analyzed for errors with classic analysis techniques. To address this issue researchers and practitioners usually apply sampling heuristics. While sampling reduces the analysis effort significantly the information obtained is necessarily incomplete and it is unknown whether sampling heuristics scale to billions of variants. Recently researchers have begun to develop variability-aware analyses that analyze the variable code base directly exploiting the similarities among individual variants to reduce analysis effort. However while being promising so far variability-aware analyses have been applied mostly only to small academic systems. To learn about the mutual strengths and weaknesses of variability-aware and sampling-based analyses of software systems we compared the two strategies by means of two concrete analysis implementations (type checking and liveness analysis) applied them to three subject systems: Busybox the x86 Linux kernel and OpenSSL. Our key finding is that variability-aware analysis outperforms most sampling heuristics with respect to analysis time while preserving completeness.;
Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering;The need for defining flexible and dynamic composed services that can adapt to the execution environment in an easy and quick way brings a new challenge to service centric system development and use. In this article we present an innovative easy-to-handle solution that supports the development of self-configuring and context-aware compositions from design time to implementation level. We discuss the steps that the service integrators should follow to create context-aware service compositions and also introduce a composition platform that supports the lifecycle of dynamic compositions both at design-time and at runtime. In order to demonstrate that our approach enables the development of context-aware service composition we focus on a real case study in the automotive and telecommunication domains where the evaluation results may be useful to understand supervise and improve our approach to support dynamic compositions.;
Proceedings of the 2nd International Workshop on Systems Development in SOA Environments;This paper seeks to briefly examine what is known so far about game mods and modding practices. Game modding has become a leading method for developing games by customizing extensions to game software. The research method in this study is observational and qualitative so as to highlight current practices and issues that can be associated with software engineering foundations. Numerous examples of different game mods and modding practices are identified throughout.;
Proceedings of the 1st International Workshop on Games and Software Engineering;Dynamically adaptive systems (DAS) enable the continuous design and adaptation of complex software systems but their main focus is limited to the application itself rather than the underlying platform and infrastructure. Cloud computing in contrast enables the management of the complete software stack but it lacks integration with software engineering approaches techniques and methods from DAS. Model-based approaches have been successfully adopted for modelling DAS at design-time and facilitate their adaptation at run-time. Therefore a natural next step is to adopt model-based approaches to enable cloud-based DAS. In this paper we present the Cloud Modelling Framework (CloudMF) a model-based framework that addresses this issue. It consists of (i) a tool-supported domain-specific modelling language to model the provisioning and deployment of multi-cloud systems and (ii) a models@run-time environment for enacting the provisioning deployment and adaptation of these systems.;
Proceedings of the Second Nordic Symposium on Cloud Computing &amp Internet Technologies;Software traceability is a sought-after yet often elusive quality in large software-intensive systems primarily because the cost and effort of tracing can be overwhelming. State-of-the art solutions address this problem through utilizing trace retrieval techniques to automate the process of creating and maintaining trace links. However there is no simple one- size-fits all solution to trace retrieval. As this paper will show finding the right combination of tracing techniques can lead to significant improvements in the quality of generated links. We present a novel approach to trace retrieval in which the underlying infrastructure is configured at runtime to optimize trace quality. We utilize a machine-learning approach to search for the best configuration given an initial training set of validated trace links a set of available tracing techniques specified in a feature model and an architecture capable of instantiating all valid configurations of features. We evaluate our approach through a series of experiments using project data from the transportation healthcare and space exploration domains and discuss its implementation in an industrial environment. Finally we show how our approach can create a robust baseline against which new tracing techniques can be evaluated.;
Proceedings of the 4th ACM SIGCHI Symposium on Engineering Interactive Computing Systems;The complexity of product line variability models makes it hard to maintain their consistency over time regardless of the modeling approach used. Engineers thus need support for detecting and resolving inconsistencies. We describe experiences of applying a tool-supported approach for incremental consistency checking on variability models. Our approach significantly improves the overall performance and scalability compared to batch-oriented techniques and allows providing immediate feedback to modelers. It is extensible as new consistency constraints can easily be added. Furthermore the approach is flexible as it is not limited to variability models and it also checks the consistency of the models with the underlying code base of the product line. We report the results of a thorough evaluation based on real-world product line models and discuss lessons learned.;
Proceedings of the 2008 ACM Symposium on Applied Computing;Variability management is a common challenge for Software Product Line (SPL) adoption since developers need suitable mechanisms for specifying and implementing variability that occurs at different SPL artifacts (requirements design implementation and test). In this paper we present a novel approach for use case scenario variability management enabling a better separation of concerns between languages used to manage variabilities and languages used to specify use case scenarios. The result is that both representations can be understood and evolved in a separate way. We achieve such a goal by modeling variability management as a crosscutting phenomenon for the reason that artifacts such as feature models product configurations and configuration knowledge crosscut each other with respect to each specific SPL member. After applying our approach to different case studies we achieved a better feature modularity and scenario cohesion.;
Proceedings of the 8th ACM International Conference on Aspect-Oriented Software Development;Organizations are subject to constant evolution and must systematically analyze and design the impact of change to implement it consistently across all organizational domains. A thorough understanding of all relevant business-related artifacts as well as their relationships is a prerequisite to achieve this. For many organizations business architecture management is a means to ensure the correct and up-to-date documentation of these artifacts. One challenge of business architecture management is the development a company-specific business architecture meta model. Two directions of existing work provide partial solutions: (1) generic (meta) modeling methods and (2) business architecture meta models and languages. We argue that these two approaches complement each other and should be applied in an integrated way. The goal of this contribution is to propose such an integrated approach to business architecture engineering. The development of this approach follows the design research process and is based on experiences gained in three industrial business architecture engineering projects.;
Proceedings of the 2009 ACM Symposium on Applied Computing;To develop analyze and evolve today's highly configurable software systems developers need deep knowledge of a system's configuration options e.g. how options need to be set to reach certain locations what configurations to use for testing etc. Today acquiring this detailed information requires manual effort that is difficult expensive and error prone. In this paper we propose iGen a novel lightweight dynamic analysis technique that automatically discovers a program's interactions---expressive logical formulae that give developers rich and detailed information about how a system's configuration option settings map to particular code coverage. iGen employs an iterative algorithm that runs a system under a small set of configurations capturing coverage data processes the coverage data to infer potential interactions and then generates new configurations to further refine interactions in the next iteration. We evaluated iGen on 29 programs spanning five languages the breadth of this study would be unachievable using prior interaction inference tools. Our results show that iGen finds precise interactions based on a very small fraction of the number of possible configurations. Moreover iGen's results confirm several earlier hypotheses about typical interaction distributions and structures.;
Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering;Model merging is widely recognized as an essential step in a variety of software development activities. During the process of combining a set of related products into a product line or consolidating model views of multiple stakeholders we need to merge multiple input models into one yet most of the existing approaches are applicable to merging only two models. In this paper we define the n-way merge problem. We show that it can be reduced to the known and widely studied NP-hard problem of weighted set packing. Yet the approximation solutions for that problem do not scale for real-sized software models. We thus evaluate alternative approaches of merging models that incrementally process input models in small subsets and propose our own algorithm that considerably improves precision over such approaches without sacrificing performance.;
Proceedings of the 7th International Workshop on Software and Performance;Model-based systems engineering (MBSE) can address many challenges of modern systems development. However due to its comprehensive coverage process maturity improvement can take many directions potentially leading to sub-optimal solutions. Therefore selecting disciplines most aligned to the development team context and goal is key to higher returns on investment. This research aims to relate goals driving MBSE process maturity improvement and candidate capabilities thus providing recommendations that highest yield the expected benefits. For this means we propose a goal-benefit model and respective operationalization method. The model relates MBSE capabilities with benefits generated upon implementation and process improvement goals. Our approach results in a list of MBSE capabilities prioritized according to the improvement goal. The approach was applied to eight development teams located in Germany and Brazil. We also provide a sensitivity analysis to validate the model. The approach was assessed positively by the case study participants who stated that it provides a starting ground for process maturity improvement efforts.;
Proceedings of the International Conference on Software and System Processes and International Conference on Global Software Engineering;Implementation of feature-oriented systems is typically made by creating an admissible configuration according to a specified feature diagram that dictates what artifacts are to be composed to create the desired solution. These artefacts are typically grouped according to the feature they concern. However some artefacts may be related not to a specific feature but to a combination of them. Also multiple alternate implementations of a single feature may exist and the preferred one may be dependent on the specific configuration that is being composed. We propose a graphic model to represent configuration knowledge that is able to address such concerns.;
Proceedings of the First International Workshop on Feature-Oriented Software Development;Software product lining is the act of providing different but related software products under the same brand known as a software product line (SPL). As engineering management and validation of SPLs is far from trivial special solutions for software product line engineering (SPLE) have a continuous momentum in both academic and industry. In general it is hard to judge when to reasonably favor SPLE over alternative solutions that are more common in the industry. In this paper we illustrate how we as Elinvar manage variability within our WealthTech Platform as a Service (PaaS) at different granularity levels and discuss methods for SPLE in this context. More in detail we share our techniques and concepts to address configuration management and show how we manage a single microservice SPL including inter-service communication. Finally we provide insights into platform solutions by means of packages for our clients. We end with a discussion on SPLE techniques in context of service SPLs and our packaging strategy. We conclude that while we are good to go with industry-standard approaches for microservice SPLs the variability modeling and analysis advantages within SPLE is promising for our packaging strategy.;
Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume B;Feature modeling has emerged as the de-facto standard to compactly capture the variability of a software product line. Multiple feature modeling languages have been proposed that evolved over the last decades to manage industrial-size product lines. However less expressive languages solely permitting require and exclude constraints are permanently and carelessly used in product-line research. We address the problem whether those less expressive languages are sufficient for industrial product lines. We developed an algorithm to eliminate complex cross-tree constraints in a feature model enabling the combination of tools and algorithms working with different feature model dialects in a plug-and-play manner. However the scope of our algorithm is limited. Our evaluation on large feature models including the Linux kernel gives evidence that require and exclude constraints are not sufficient to express real-world feature models. Hence we promote that research on feature models needs to consider arbitrary propositional formulas as cross-tree constraints prospectively.;
Proceedings of the 5th ACM SIGCHI Symposium on Engineering Interactive Computing Systems;For highly configurable software systems such as the Linux kernel maintaining and evolving variability information along changes to source code poses a major challenge. While source code itself may be edited also feature-to-code mappings may be introduced removed or changed. In practice such edits are often conducted ad-hoc and without proper documentation. To support the maintenance and evolution of variability it is desirable to understand the impact of each edit on the variability. We propose the first complete and unambiguous classification of edits to variability in source code by means of a catalog of edit classes. This catalog is based on a scheme that can be used to build classifications that are complete and unambiguous by construction. To this end we introduce a complete and sound model for edits to variability. In about 21.5ms per commit we validate the correctness and suitability of our classification by classifying each edit in 1.7 million commits in the change histories of 44 open-source software systems automatically. We are able to classify all edits with syntactically correct feature-to-code mappings and find that all our edit classes occur in practice.;
Proceedings of the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering;In product line engineering (PLE) a major challenge is the complexity of artifacts that have to be handled. In real-world product lines variability models can become large and complex comprising thousands of elements with hundreds of non-trivial dependencies. Visual and interactive techniques aim to reduce the (cognitive) complexity and support the user during challenging PLE tasks like product configuration. There are many visualization techniques described in the literature -- e.g. in Software Visualization -- and some isolated techniques have been applied in PLE tools. Nevertheless the full potential of visualization in the context of PLE has not been exploited so far. This paper provides an overview of (1) available visualization techniques and criteria to judge their benefits and drawbacks for product configuration (2) which have been applied in product configuration in PLE and (3) which could be beneficial to support product configuration. We propose a research agenda for future work in visual and interactive PLE techniques.;
Proceedings of the 15th International Software Product Line Conference Volume 2;The design of a mobile phone application is a tedious task according to its intrinsic variability. Software designers must take into account in their development process the versatility of available platforms (e.g. Android iPhone). In addition to this the variety of existing devices and their divergences (e.g. frontal camera GPS) introduce another layer of complexity in the development process. These two dimensions can be formalized as Software Product Lines (SPL) independently defined. In this paper we use a dedicated metamodel to bridge the gap between an application SPL and a mobile device one. This meta-model is also the support for the product derivation process. The approach is implemented in a framework named Applide and is used to successfully derive customer relationship management software on different devices.;
Proceedings of the 2013 Conference on Internet Measurement Conference;Agile processes like Scrum are increasingly being used in globally distributed contexts. One key reality of the world today is the threat of terrorism. This paper documents the case of a globally distributed Scrum team and shows how this team recovered from a terrorist attack. The team successfully delivered their sprint and the gold release. The main finding of this paper is that if configured correctly such distributed agile processes seem highly resilient in the face of unexpected disasters. Lessons learned from this unique event are also explicated.;
Proceedings of the 2009 Conference of the Center for Advanced Studies on Collaborative Research;Systematic software reuse is still the most promising strategy for increasing productivity and improving quality in the software industry. Although it is simple in concept successful software reuse implementation is difficult in practice. A reason put forward for this is the dependence of software reuse on the context in which it is implemented. This paper describes an interpretive case study aimed at investigating the potential for the implementation of systematic software reuse in a project-centric company. The study confirmed the need for systematic software reuse and identified the reuse issues that could present challenges. The study also revealed a number of problems relating to the project-centric structure for which systematic reuse provides potential solutions.;
Proceedings of the 2008 Annual Research Conference of the South African Institute of Computer Scientists and Information Technologists on IT Research in Developing Countries: Riding the Wave of Technology;Defining organizational processes is essential for enhancing maturity. However the best process depends on the particularities of each project. Typically a process engineer defines a specific process for each project in an ad-hoc fashion which is expensive unrepeatable and error prone. Trying to deal with this challenge we propose a model-based approach to software process tailoring that generates project specific processes based on the organizational process and the project context. The approach is systematic repeatable and it does not depend on the people using it. The proposal has been applied for tailoring the Requirements Engineering process of a medium size company. The obtained results were validated by process engineers of the company. Processes obtained using the proposed approach matched the ones used in the company for planned contexts and also they were reasonable for non-expected situations.;
Proceedings of the 2011 International Conference on Software and Systems Process;Industrial products tend to be customized by third-parties for different use cases. This is currently supported by adding external Programmable Logic Controllers (PLC) to installations. As IoT software ecosystems become wide-spread the need for such hardware will decrease. However removing the controllers opens the challenge of configuring distributed industrial installations. This paper argues for modeling application requirements on industrial installations so that they can be evaluated automatically based on information about targeted installations. GIMLE a visual language for modeling application requirements using expressive domain knowledge is proposed. GIMLE enables modeling requirements on physical features of installations which hasn't received significant attention in the related work. A study with domain experts is used to reflect on the proposed process. The scalability of the visual language is evaluated using a model for a real-world application. The support for reuse of requirements enabled us to build models that can add support for new installations without significant changes and with a slower increase in size the more components can be reused.;
Proceedings of the Seventh International Conference on the Internet of Things;Software design is a process of trading off competing objectives. If the user objective space is rich then we should use optimizers that can fully exploit that richness. For example this study configures software product lines (expressed as feature maps) using various search-based software engineering methods. As we increase the number of optimization objectives we find that methods in widespread use (e.g. NSGA-II SPEA2) perform much worse than IBEA (Indicator-Based Evolutionary Algorithm). IBEA works best since it makes most use of user preference knowledge. Hence it does better on the standard measures (hypervolume and spread) but it also generates far more products with 0% violations of domain constraints. Our conclusion is that we need to change our methods for search-based software engineering particularly when studying complex decision spaces.;
Proceedings of the 2013 International Conference on Software Engineering;In addition to inherited characteristics from software variability service variability exposes two distinct characteristics that impose certain challenges in variability management. These characteristics are: i) Different types of variability and their inter-relationships and ii) Dynamic and recursive variability communication among different stakeholders. This paper elaborates these distinct characteristics in detail with a case study. The challenges brought about by these distinct characteristics in managing variability also are highlighted. We present a review of related work in service variability management and briefly propose our ongoing approach to addressing these challenges.;
Proceedings of the 21st International Conference on Evaluation and Assessment in Software Engineering;Background. Continuous experimentation (CE) has recently emerged as an established industry practice and as a research subject. Our aim is to study the application of CE and A/B testing in various industrial contexts. Objective. We wanted to investigate whether CE is used in different sectors of industry by how it is reported in academic studies. We also wanted to explore the main topics researched to give an overview of the subject and discuss future research directions. Method. We performed a systematic mapping study of the published literature and included 62 papers using a combination of database search and snowballing. Results. Most reported software experiments are done online and with software delivered as a service although varied exemptions exist for e.g. financial software and games. The most frequently researched topics are challenges to conduct experiments and statistical methods for software experiments. Conclusions. The software engineering research on CE is still in its infancy. There are future research opportunities in evaluation research of technical topics and investigations of ethical experimentation. We conclude that the included studies show that A/B testing is applicable to a diversity of software and organisations.;
Proceedings of the 4th International Workshop on Rapid Continuous Software Engineering;The software industry is experiencing a shift towards more open processes a globalized market and more active and engaged customers and end users. This change seems natural and inevitable imposing necessary changes in how software product line organizations plan and drive the development of their products. This paper gives insight into some recent developments in a product line organization and discusses how their efforts have helped them in improving their development processes and their product line. Based on this experience this paper provides some preliminary guidelines to both industry and research indicating that software product line organizations should exploit open innovation engage customers build communities and simplify processes and organization.;
Proceedings of the 2010 ICSE Workshop on Product Line Approaches in Software Engineering;Scoping can be defined as the process of deciding in which parts of an organization's products features and domains systematic reuse is economically useful. It generally is the first phase in product line engineering. For a decade now scoping has been recognized as a discipline of it's own in product line engineering. So it's time to look at what has been done in scoping in the last years and what is still to be done. In this survey we identify and characterize existing scoping approaches with the main goal to derive open areas and research questions for further research in scoping. We analyze and compare existing approaches and derive open and partially addressed research questions that can be tackled by researchers in product line engineering in the next years.;
Proceedings of the 28th ACM International Conference on Design of Communication;Software product lines and model transformations are two techniques used in industry for managing the development of highly complex software. Product line approaches simplify the handling of software variants while model transformations automate software manipulations such as refactoring optimization code generation etc. While these techniques are well understood independently combining them to get the benefit of both poses a challenge because most model transformations apply to individual models while model-level product lines represent sets of models. In this paper we address this challenge by providing an approach for automatically ``lifting'' model transformations so that they can be applied to product lines. We illustrate our approach using a case study and evaluate it through a set of experiments.;
Proceedings of the 8th Working Conference on Mining Software Repositories;Software-as-a-Service is becoming popular in the software business due to its rapid delivery and cost effectiveness in development and maintenance. Software-as-a-Service should be provided in single code base and operated as a single instance. To meet these constraints and requirements from various customers Software-as-a-Service must be highly configurable. To develop configurable Software-as-a-Service it is important to elicit and analyze configuration requirements in the early stages of development. Another issue is that on implementing configuration requirements there are duplicated and untidy code segments. In our study configuration requirements are identified and classified. This study introduces design patterns to remove duplicated codes for configuration.;
Proceedings of the 16th International Software Product Line Conference - Volume 1;Traceability is an important concern for numerous software engineering activities. Establishing traceability links is a challenging and cost-intensive task which is uneconomical without suitable strategies for maintaining high link quality. Current approaches to Traceability Management (TM) however often make important assumptions and choices without ensuring that the consequences and implications for traceability maintenance are feasible and desirable in practice.  In this paper therefore we identify a set of core factors that influence how the quality of traceability links can be maintained. For each factor we discuss relevant challenges and provide guidelines on how best to ensure viable traceability maintenance in a practical TM approach. Our guidelines are meant to be used by tool developers and users to select the most appropriate TM approach for their needs.  Our results are based on and supported by data collected from interviews conducted with: (i) 9 of our industrial and academic project partners to elicit requirements for a TM tool and (ii) 24 software development stakeholders from 15 industrial cases to provide a broader overview of the current state of the practice on TM.  To evaluate the feasibility of our guidelines we investigate a set of existing TM approaches used in industry with respect to our guidelines.;
Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering;We describe ongoing work on a variability mechanism for Autonomic Software Product Lines (ASPL). The autonomic software product lines have self-management characteristics that make product line instances more resilient to context changes and some aspects of product line evolution. Instances sense the context selects and bind the best component variants to variation-points at run-time. The variability mechanism we describe is composed of a profile guided dispatch based on off-line and on-line training processes. Together they form a simple yet powerful variability mechanism that continuously learns which variants to bind given the current context and system goals.;
Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications;Software product families and agile development have emerged as a popular means in software engineering. In this position paper we discuss how development management in agile methods can be integrated with software product family structure modeling. The integration aims towards improving software product family development governance by providing technology in terms of concepts and even automated tool support for planning monitoring and controlling the development work for different stakeholders. For example integration provides support for prioritization of development tasks and enables monitoring the development status of products in a software product family for example. The feasibility of integration is shown by combining Kumbang and Agilefant conceptualizations and respective prototype tools.;
Proceedings of the 1st International Workshop on Software Development Governance;With more than 11000 optional and alternative features the Linux kernel is a highly configurable piece of software. Linux is generally perceived as a textbook example for preprocessor-based product derivation but more than 65 percent of all features are actually handled by the build system. Hence variability-aware static analysis tools have to take the build system into account.However extracting variability information from the build system is difficult due to the declarative and turing-complete make language. Existing approaches based on text processing do not cover this challenges and tend to be tailored to a specific Linux version and architecture. This renders them practically unusable as a basis for variability-aware tool support -- Linux is a moving target!We describe a robust approach for extracting implementation variability from the Linux build system. Instead of extracting the variability information by a text-based analysis of all build scripts our approach exploits the build system itself to produce this information. As our results show our approach is robust and works for all versions and architectures from the (git-)history of Linux.;
Proceedings of the 4th International ICST Conference on Simulation Tools and Techniques;The Software Product Lines (SPL) paradigm has arisen for taking advantage of existing common aspects between different products while also considering product-specific features. The architecture of a SPL comprises a model that will result in product architectures and may include solutions leading to bad (architectural) design. One way to assess such design decisions is through the identification of architectural bad smells which are properties that prejudice the overall software quality but are not necessarily faulty or errant. In this paper we conduct an exploratory study that aims at characterizing bad smells in the context of product line architectures. We analyzed an open source SPL project and extracted its architecture to investigate the occurrence or absence of four smells initially studied in single systems. In addition we propose a smell specific to the SPL context and discuss possible causes and implications of having those smells in the architecture of a product line. The results indicate that the granularity of the SPL features may influence on the occurrence of smells.;
Proceedings of the WICSA 2014 Companion Volume;A software product line is a set of different software products that share commonalities. For a selection of features specialized products of one domain can be generated automatically from domain artifacts. However analyses of software product lines need to handle a large number of products that can be exponential in the number of features. In the last decade many approaches have been proposed to analyze software product lines efficiently. For some of these approaches tool support is available. Based on a recent survey on analysis for software product lines we provide a first overview on such tools. While our discussion is limited to analysis tools we provide an accompanying website covering further tools for product-line development. We compare tools according to their analysis and implementation strategy to identify underrepresented areas. In addition we want to ease the reuse of existing tools for researchers and students and to simplify research transfer to practice.;
Proceedings of the 18th International Software Product Line Conference: Companion Volume for Workshops Demonstrations and Tools - Volume 2;Software projects embrace variability to increase adaptability and to lower cost however others blame variability for increasing complexity and making reasoning about programs more difficult. We carry out a controlled experiment to quantify the impact of variability on debugging of preprocessor-based programs. We measure speed and precision for bug finding tasks defined at three different degrees of variability on several subject programs derived from real systems.The results show that the speed of bug finding decreases linearly with the degree of variability while effectiveness of finding bugs is relatively independent of the degree of variability. Still identifying the set of configurations in which the bug manifests itself is difficult already for a low degree of variability. Surprisingly identifying the exact set of affected configurations appears to be harder than finding the bug in the first place. The difficulty in reasoning about several configurations is a likely reason why the variability bugs are actually introduced in configurable programs.We hope that the detailed findings presented here will inspire the creation of programmer support tools addressing the challenges faced by developers when reasoning about configurations contributing to more effective debugging and ultimately fewer bugs in highly-configurable systems.;
Proceedings of the 24th ACM Conference on Systems and Software Product Line: Volume A - Volume A;Dynamic computing systems with small distributed and communicating embedded devices as they are expected for the future must be able to manage appearance and loss of devices and resources. For the development of static systems component-oriented engineering approaches have been shown to foster well-structured configurable systems. Frameworks for the dynamic integration of such components often rely on a centralized component integration platform containing service brokers and similar. This paper describes several aspects of a component-oriented approach for the development of dynamic-adaptive systems that distributes all needed infrastructure among the participating embedded devices. This results in a runtime framework working whenever two components come together and form an ad-hoc system.;
Proceedings of the 2008 International Workshop on Software Engineering for Adaptive and Self-Managing Systems;Cyber-Physical Production Systems (CPPSs) are complex systems comprised of software and hardware interacting with each other and the environment. In industry over time a plethora of CPPSs are developed to satisfy varying customer requirements and changing technologies. Managing variability is challenging especially in multidisciplinary environments like in CPPS engineering. For instance when supporting the automatic derivation and configuration of control software one needs to understand variability from not only a software perspective but also a mechatronic electrical process and business perspective. It is unrealistic to use a single model or even one type of model across these perspectives. In this paper we describe a Multidisciplinary Delta-Oriented Variability Management approach for CPPSs that we are currently developing. Our approach aims to express CPPS variability in different disciplines using heterogeneous variability models relating models via cross-discipline constraints and automatically generating control software based on variability models. We implemented a prototype of our approach by realizing delta-oriented variability modeling for IEC&nbsp61499-based distributed control software and a configuration tool to enact the configuration options from multiple variability models. We performed a feasibility study of our approach using two systems of different size and complexity. We conclude that despite current limitations our approach can successfully and automatically generate control software based on related multidisciplinary variability models. We think that our approach is a good starting point to manage CPPS variability in practice.;
Proceedings of the 16th International Working Conference on Variability Modelling of Software-Intensive Systems;In automotive electrical/electronics systems reuse of software applications over vehicle lines is becoming essential due to the growing complexity of the applications. In addition a growing number of variants have to be handled because of the increasing number of differences arising in vehicle lines. Software product lines are a common approach to address these issues. This paper presents the challenges and our vision for the introduction of a product line approach in the context of AUTOSAR (AUTomotive Open System Architecture)-based development of applications for in vehicle systems.;
Proceedings of the 11th Annual International Conference on Aspect-Oriented Software Development;"Today's product development creates multiple products over time often by using reuse strategies like Clone and Own"" leading to very inefficient reuse of artifacts in the long term since synergy effects between the products e.g. from testing cannot be utilized. Applying a product line approach with explicitly modeling the commonalities and variabilities of system artifacts and deriving products from that common base is a way to tackle the problem. High variant complexity can often be found in the development of embedded systems which in turn often control safety critical functions. For these systems functional safety is a major concern not only since the ISO 26262 got relevant for the automotive industry. The arising question is: Can variability in functional safety related assets be treated in the same way as for other artifacts like requirements models and source code? In this paper we demonstrate on the example of two commercial tools and an automotive use case that from the technical/tool point of view safety related artifacts can be treated like other artifacts regarding variability. This means linking with variability information and visualizing as well as deriving of variants is feasible. This is a big step forward because now not only ordinary artifacts but also functional safety related assets can be reused in the same way as other product line artifacts. However we have identified and will discuss challenges with respect to variable safety analyses regulations and reuse of certifications which need further research and elaboration in this paper.""";
Proceedings of the 5th Workshop on Automation of Software Test;Software engineering activities like code reviews change management knowledge management issue tracking etc. tend to be heavily process oriented. Gamification of such activities by composing the core activities with game design elements like badges and points can increase developers' interest in performing such activities. While there are various frameworks/applications that assist in gamification extending the frameworks to add any/all desired game design elements has not been adequately addressed. In this paper we propose an extensible architectural framework for gamification of software engineering activities where in the game design elements are modeled as services. We create an example instance of our framework by building a prototype for code review activity and note the challenges of designing such an extensible architectural framework. The example instance uses python's Flask micro framework and has five game design elements implemented as services and exposed using restful APIs.;
Proceedings of the 9th India Software Engineering Conference;The feature-interaction problem has been keeping researchers and practitioners in suspense for years. Although there has been substantial progress in developing approaches for modeling detecting managing and resolving feature interactions we lack sufficient knowledge on the kind of feature interactions that occur in real-world systems. In this position paper we set out the goal to explore the nature of feature interactions systematically and comprehensively classified in terms of order and visibility. Understanding this nature will have significant implications on research in this area for example on the efficiency of interaction-detection or performance-prediction techniques. A set of preliminary results as well as a discussion of possible experimental setups and corresponding challenges give us confidence that this endeavor is within reach but requires a collaborative effort of the community.;
Proceedings of the 5th International Workshop on Feature-Oriented Software Development;"In this experience report we describe the motivation experience lessons learned and future directions of a software engineering curriculum used at a large international company. The Curriculum for Software Engineers"" project which developed the content and a role-based qualification and certification program was started at Siemens in 2006. This paper includes an overview of various kinds of certification in the software engineering area and why we chose the knowledge- and experience-based type of certification. The experience report part focuses mainly on the ""certified senior software architect"" role as this role has the longest history and participants from many different business units and countries.""";
Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 2;Automotive architectures today consist of up to 100 electronic control units (ECUs) that communicate via one or more FlexRay and CAN buses. Multiple control applications - like cruise control brake control etc. are specified as Simulink/Stateflow models from which code is generated and mapped onto the different ECUs. In addition scheduling policies and parameters both for the ECUs and the buses need to be specified. Code generation/optimization from the Simulink/Stateflow models task partitioning and mapping decisions as well as the parameters chosen for the schedulers all of these impact the execution times and timing behaviour of the control tasks and control messages. These in turn affect control performance such as stability and steady-/transient-state behaviour. This paper discusses different aspects of this multi-layered design flow and the associated research challenges. The emphasis is on model-based code generation analysis testing and verification of control software for automotive architectures as well as on architecture or platform configuration to ensure that the required control performance requirements are satisfied.;
Proceedings of the Ninth ACM International Conference on Embedded Software;The increasing complexity and cost of software-intensive systems has led developers to seek ways of increasing software reusability. One software reuse approach is to develop a Software Product-line (SPL) which is a reconfigurable software architecture that can be reused across projects. Creating configurations of the SPL that meets arbitrary requirements is hard.Existing research has focused on techniques that produce a configuration of the SPL in a single step. This paper provides three contributions to the study of multi-step configuration for SPLs. First we present a formal model of multi-step SPL configuration and map this model to constraint satisfaction problems (CSPs). Second we show how solutions to these CSP configuration problem CSPs can be derived automatically with a constraint solver. Third we present empirical results demonstrating that our CSP-based technique can solve multi-step configuration problems involving hundreds of features in seconds.;
Proceedings of the 2nd India Software Engineering Conference;Highly-configurable software underpins much of our computing infrastructure. It enables extensive reuse but opens the door to broken configuration specifications. The configuration specification language Kconfig is designed to prevent invalid configurations of the Linux kernel from being built. However the astronomical size of the configuration space for Linux makes finding specification bugs difficult by hand or with random testing. In this paper we introduce a software model checking framework for building Kconfig static analysis tools. We develop a formal semantics of the Kconfig language and implement the semantics in a symbolic evaluator called kclause that models Kconfig behavior as logical formulas. We then design and implement a bug finder called kismet that takes kclause models and leverages automated theorem proving to find unmet dependency bugs. kismet is evaluated for its precision performance and impact on kernel development for a recent version of Linux which has over 140000 lines of Kconfig across 28 architecture-specific specifications. Our evaluation finds 781 bugs (151 when considering sharing among Kconfig specifications) with 100% precision spending between 37 and 90 minutes for each Kconfig specification although it misses some bugs due to underapproximation. Compared to random testing kismet finds substantially more true positive bugs in a fraction of the time.;
Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;Dynamic Software Product Lines (DSPLs) provide a promising approach for planning and applying runtime reconfiguration scenarios to adaptive software systems. However applying DSPLs in the vital domain of highly context-aware systems e.g. mobile devices is obstructed by the inherently limited resources being insufficient to handle large constrained (re-)configurations spaces. To tackle these drawbacks we propose a novel model-based approach for designing DSPLs in a way that allows for a trade-off between precomputation of reconfiguration scenarios at development time and on-demand evolution at runtime. Therefore we (1) enrich feature models with context information to reason about potential context changes and (2) specify context-aware reconfiguration processes on the basis of a scalable transition system incorporating state space abstractions and incremental refinement at runtime. We illustrate our concepts by means of a smartphone case study and present an implementation and evaluation considering different trade-off metrics.;
Proceedings of the 17th International Software Product Line Conference Co-Located Workshops;Background. Software defect prediction has been one of the central topics of software engineering. Predicted defect counts have been used mainly to assess software quality and estimate the defect correction effort (DCE). However in many cases these defect counts are not good indicators for DCE. Therefore in this study DCE has been modeled from a different perspective. Defects originating from various development phases have different impact on the overall DCE especially defects shifting from one phase to another. To reduce the DCE of a software product it is important to assess every development phase along with its specific characteristics and focus on the shift of defects over phases.Aims. The aim of this paper is to build a model for effort prediction at different development stages. Our model is mainly focused on a dynamic DCE changing from one development phase to another. It reflects the increasing cost of correcting defects which are introduced in early but found in later development phases.Research Method. The modeling technique used in this study is a Bayesian network which among many others has three important capabilities: reflecting causal relationships combining expert knowledge with empirical data and incorporating uncertainty. The procedure of model development contains a set of iterations including the following steps: problem analysis data analysis model enhancement with simulation runs and model validation.Results. The developed Defect Cost Flow Model (DCFM) reflects the widely used V-model an international standard for developing information technology systems. It has been pre-calibrated with empirical data from past projects developed at Robert Bosch GmbH. The analysis of evaluation scenarios confirms that DCFM correctly incorporates known qualitative and quantitative relationships. Because of its causal structure it can be used intuitively by end-users.Conclusion. Typical cost benefit optimization strategies regarding the optimal effort spent on quality measures tend to optimize locally e.g. every development phase is optimized separately in its own domain. In contrast to that the DCFM demonstrates that even cost intensive quality measures pay off when the overall DCE of specific features is considered.;
Proceedings of the 6th International Conference on Predictive Models in Software Engineering;Successful software products evolve continuously to meet the changing stakeholder requirements. For software product lines modifying variability is an additional challenge that must be carefully tackled during the evolution of the product line. This bears considerable challenges for industry as understanding on how variability realizations advance over time is not trivial. Moreover it may lead to an erosion of variability which needs an investigation of techniques on how to identify the variability erosion in practice especially in the source code. To address various erosion symptoms we have investigated the evolution of a large-scale industrial product line over a period of four years. Along improvement goals we have researched a set of appropriate metrics and measurement approaches in a goal-oriented way applied them in this case study with tool support and interpreted the results including identified erosion symptoms.;
Proceedings of the 2022 ACM SIGPLAN International Symposium on New Ideas New Paradigms and Reflections on Programming and Software;"Successful software products evolve continuously to meet the changing stakeholder requirements. For software product lines an additional challenge is that variabilities characteristics that vary among products change as well over time. That challenge must be carefully tackled during the evolution of the product line infrastructure. This is a significant problem for many software development organizations as practical guidelines on how to evolve core assets and especially source code are missing.This paper investigates how to achieve good enough"" variability management during the evolution of variation in software design and implementation assets. As a first contribution we present a customizable goal-based approach which helps to identify improvement potential in existing core assets to ease evolution. To find concrete ways to improve the product line infrastructure we list the typical symptoms of variability ""code smells"" and show how to refine them to root causes questions and finally to metrics that can be extracted from large code bases.As a second main contribution we show how this method was applied to evaluate the reuse quality of three industrial embedded systems. These systems are implemented in C or C++ and use Conditional Compilation as the main variability mechanism. We also introduce the analysis and refactoring tool set that was used in the case studies and discuss the lessons learnt.""";
Proceedings of the 2008 International Working Conference on Mining Software Repositories;In emerging domains such as Cloud-based Industrial Control Systems (ICSs) and SCADA systems where data-intensive and high performance computing are needed a higher degree of flexibility is being demanded to meet new stakeholder requirements context changes and intrinsic complexity. In this light Dynamic Software Product Lines (DSPLs) provide a way to build self-managing systems exploiting traditional product line engineering concepts at runtime. Although context-awareness is widely perceived to be a first-class concern in such runtime variability mechanisms existing approaches do not provide the necessary level of formalization to model and enact context variability for DSPLs. This is crucial for operational analytics processes since variant configuration could differ from context to context depending on diverse data values linked to context features and cross-tree constraints in a feature model. In this paper we propose a context variability modeling approach demonstrate its applicability and usability via a wind farm use case and present the fundamental building blocks of a framework for enabling context variability in service-based DSPLs which provide Workflow as a Service (WFaaS).;
Proceedings of the Joint International and Annual ERCIM Workshops on Principles of Software Evolution (IWPSE) and Software Evolution (Evol) Workshops;In this text we identify relevant adaptation issues concerning the software architecture of a system for intelligent health monitoring of a person at home. Our solution integrates medical knowledge patient's physiological and behavioral data and environmental conditions. The designed software architecture includes modules for context management alarm generation reasoning and learning. A fuzzy logic model and rules based on medical recommendations helps analyzing and identifying critical situations of the patient. In this scenario ubiquitous computing has an important role allowing the non-intrusive monitoring of several relevant context variables. Considering this infrastructure we argue that configuration management and context management are key mechanisms to support the adaptation requirements of the target class of applications. Finally we describe our approach towards tackling the related architecture adaptation issues.;
Proceedings of the 2010 ICSE Workshop on Software Engineering in Health Care;For economical reasons the creation of feature oriented software should include previously created products and should not be done from scratch. To speed up this migration process feature models have to be generated automatically from existing product variants. This work presents an approach based on formal concept analysis that analyzes incidence matrices containing matching relations as input and creates feature models as output. The resulting feature models describe exactly the given input variants. The introduced novel optimized approach performs this transformation in reasonable time even for large product libraries.;
Proceedings of the 2015 European Conference on Software Architecture Workshops;Industrial variability models tend to grow in size and complexity due to ever-increasing functionality and complexity of software systems. Some authors report on variability models specifying several thousands of variabilities. However traditional variability modeling approaches do not seem to scale adequately to cope with size and complexity of such models. Recently textual variability modeling languages have been advocated as one scalable solution.In this paper we provide a systematic analysis of the capabilities of current textual variability modeling languages in particular regarding variability management in the large. Towards this aim we define a classification schema consisting of five dimensions classify ten different textual variability modeling languages using the classification schema and provide an analysis. In summary some textual variability modeling languages go beyond textual representations of traditional variability modeling approaches and provide sophisticated modeling concepts and constraint languages. Three textual variability modeling approaches already support mechanisms for large-scale variability modeling such as model composition modularization or evolution support.;
Proceedings of the Ninth International Conference on Generative Programming and Component Engineering;Several change metrics and source code metrics have been introduced and proved to be effective features in building bug prediction models. Researchers performed comparative studies of bug prediction models built using the individual metrics as well as combination of these metrics. In this paper we investigate whether the prediction accuracy of bug prediction models is improved by applying feature selection techniques. We explore if there is one algorithm amongst ten popular feature selection algorithms that consistently fares better than others across sixteen bench marked open source projects. We also study whether the metrics in best feature subset are consistent across projects.;
Proceedings of the 8th India Software Engineering Conference;Inversion of control is a common design practise that has been used in various application areas. It gained popularity in the context of object-oriented application frameworks and designs based on abstract classes and interfaces. Recently dependency injection techniques especially in the context of lightweight containers such as Spring have raised the attention for inversion of control again. However inversion of control has not yet been described in its architectural dimension with a focus on layering architectures and the pros and cons of the design decision for control inversion. In this paper we present the inversion-of-control layer pattern which describes the design practise from an architectural point of view rather than focusing on particular implementation techniques.;
Proceedings of the 15th European Conference on Pattern Languages of Programs;"Context: In the software product line domain the concept of variability is well recognized. However variability in the context of software architecture still seems to be poorly understood. Objective: In this paper we aim at contributing to the development of a basic understanding of the notion of variability in the software architecture domain beyond the idea of product lines. Method: We perform a preliminary exploratory study which consists of two parts: an expert survey among 11 subjects and a mini focus group with 4 participants. For both parts we collect and analyze mostly qualitative data. Results: Our observations indicate that there seems to be no common understanding of variability"" in the context of software architecture. On the other hand some challenges related to variability in software architecture are similar to challenges identified in the product line domain. Conclusions: Variability in software architecture might require more theoretical foundations in order to establish ""variability"" as an architectural key concept and first-class quality attribute.""";
Proceedings of the Tenth International Conference on Aspect-Oriented Software Development;Eurocopter is the majority partner in NH Industries the international consortium that develops and produces the medium weight multi-role helicopter NH90. AgustaWestland and Stork Fokker are additional partners. The NH90 has been successfully sold to 14 nations and their armed forces. The software division at Eurocopter Germany develops the on-board software for three computers of the NH90 avionics CORE and MISSION Systems. The growing number of customers and their specific application domains for the NH90 has led to an increasing number of functionally different helicopter variants. Moreover during the long development time that is typical for complex military avionics projects the computing technology has changed considerably over time so that the current operational software has to fit to several processor architectures. In order to cope with the high number of software variants and technology variations the NH90 software team developed concepts and strategies for SW architecture and tool modifications based on Software Product Line (SPL) principles.;
Proceedings of the WICSA/ECSA 2012 Companion Volume;Service Oriented Architectures (SOA) and Software Product Lines (SPL) have individually proven to be software engineering concepts that create added value to the development of software systems. Recently the research community has recognized and investigated potentials for combining these two concepts. However there have been no mapping study and literature surveys that systematically review the present research results in combining the two. This paper presents results of a preliminary work on a systematic mapping study of research papers that report on combining SOA and SPL. The main goal of a systematic mapping study is to provide a breath overview classification of approaches and the quantity and type of research as well as available research results which is complimentary step toward further systematic literature review. This paper based on selected papers published from 2002 to mid-2010 reports on various aspects of the analyzed literature including the motivations for combining the two concepts contributions to specific stages of software engineering lifecycles types of synergies and characteristics that are accomplished through combinations of the two concepts and the methods used for and the rigor of the evaluations of the research conducted on the studied topic.;
Proceedings of the Warm Up Workshop for ACM/IEEE ICSE 2010;In embedded systems in general and in automotive systems in particular the systematic reuse of existing assets is crucial. Moreover companies in these domains often offer whole families of similar products. Hence the application of product line engineering seems to be an obvious option.However current products have reached a complexity level where management of products within a product line cannot be handled with current techniques and tools (e.g. Matlab/Simulink) alone. To sustain an efficient engineering process and to reach the required quality levels of the products additional techniques are required.In this paper we report on a prototypical framework for the analysis of embedded systems product lines. The techniques and tools offered by the framework were developed to support engineers in typical tasks which occur during design implementation and maintenance of embedded software product lines. The techniques allow to analyse product line artefacts by transforming them into models which are then used in an analysis process based on model transformation languages.;
Proceedings of the 18th International Software Product Line Conference - Volume 1;Product lines are usually built for the long term in order to repay the initial investment. While long-term stable software systems are already hard if they are developed individually it is even harder for complete product lines. At the time a new product line is created the details of future product line characteristics are typically not known no matter how well and detailed scoping and planning is done. Thus any product line needs to evolve and adapt over time to incorporate new customer requirements as well as new technology constraints.Stability of the product line architecture is very important to the successful long-term evolution of a product line. In this paper we discuss how a form of domain decomposition which we call conceptual architecture can be used to guide product line engineering towards long-term viability. We will illustrate this approach in the context of a large-scale product line development and analyze the evolution properties of the product line. Transferability of the approach is suggested to other embedded software systems that drive mature well-understood physical control system.;
Proceedings of the 26th ACM International Systems and Software Product Line Conference - Volume A;This paper describes a novel approach to detect variability in a software product line from its change history such that software changes are converted to vectors and a factor analysis is applied. To show the applicability of our approach we conducted experimental applications using a software repository of automotive engine control software. As a result of the experiments variability is detected from the change history of products.;
Proceedings of the 20th International Systems and Software Product Line Conference;Software product lines (SPLs) and software ecosystems (SECOs) are approaches to capturing families of closely related software systems in terms of common and variable functionality. SPLs and especially SECOs are subject to evolution to adapt to new or changed requirements resulting in different versions of the software family and its variable assets. These versions may have to be maintained and used for products even after they were superseded by newer versions. Variability models describing valid combinations of variable assets such as feature models capture variability in space (configuration) but not variability in time (evolution) making it impossible to respect versions of variable assets in product definitions on a conceptual level. In this paper we propose Hyper Feature Models (HFMs) explicitly providing feature versions as configurable units for product definition. Furthermore we provide a version-aware constraint language to specify dependencies between features and ranges of feature versions as well as a procedure to automatically select valid combinations of versions for a pre-configuration of features. We demonstrate our approach in a case study.;
Proceedings of the 8th International Workshop on Variability Modelling of Software-Intensive Systems;One key challenge for software product lines is efficiently managing variability throughout their lifecycle. In this paper we address the problem of variability in software product lines testing. We (1) identify a set of issues that must be addressed to make software product line testing work in practice and (2) provide a framework that combines a set of techniques to solve these issues. The framework integrates feature modelling combinatorial interaction testing and constraint programming techniques. First we extract variability in a software product line as a feature model with specified feature interdependencies. We then employ an algorithm that generates a minimal set of valid test cases covering all 2-way feature interactions for a given time interval. Furthermore we evaluate the framework on an industrial SPL and show that using the framework saves time and provides better test coverage. In particular our experiments show that the framework improves industrial testing practice in terms of (i) 17% smaller set of test cases that are (a) valid and (b) guarantee all 2-way feature coverage (as opposite to 19.2% 2-way feature coverage in the hand made test set) and (ii) full flexibility and adjustment of test generation to available testing time.;
Proceedings of the 23rd International Systems and Software Product Line Conference - Volume A;Organizational Punishment/Penalty is a pervasive phenomenon in many professional organizations. In some software development organizations punishment measures have been adopted in an attempt to improve software developers' performance reduce the software defects and hence ensure software quality. It is unclear whether these measures are effective. This article presents the results of a multi-method field study that analyzes software engineers' perception towards penalty policies in relation to software quality in a software development process. The results were generated via both qualitative and quantitative methods. Through interviews we collected the individuals' perception towards the penalty policy. By extracting data in a software configuration management system we identified several patterns of defects change. We found that while a penalty mechanism does help to reduce software defects in daily coding activity it fails in achieving programmers' maximum work potential. Meanwhile experienced software programmers require less time to adapt to penalty policies and benefit from exist of less experienced developers. Some additional findings and implications are also discussed.;
Proceedings of the 29th ACM/IEEE International Conference on Automated Software Engineering;Nowadays embedded system development is increasing its complexity dealing with quality cost and time-to-market among others. Quality attributes are an important issue to consider in embedded software development where time issues may be critical. Development paradigms such as Model Driven Development and Software Product Lines can be an adequate alternative to traditional software development and validation methods due to the characteristics of embedded systems. But for a proper validation and verification based on MARTE model analysis all variability issues and critical quality attributes that take part in analysis must be properly modelled and managed. Therefore a model analysis process for Model Driven Embedded Software Product Lines has been defined as some process lacks have been found.;
Companion Proceedings of the 15th International Conference on Modularity;Aligning the software process and the documentation process is a recipe for having both software and documentation in synchrony where changes in software seamlessly ripple along its documentation counterpart. This paper focuses on documentation for Software Product Lines (SPLs). A SPL is not intended to build one application but a number of them: a product family. In contrast to single-software product development SPL development is based on the idea that the distinct products of the family share a significant amount of assets. This forces a change in the software process. Likewise software documentation development should now mimic their code counterpart: product documentation should also be produced out of a common set of assets. Specifically the paper shows how DITA process and documents are recasted using a feature-oriented approach a realization mechanism for SPLs. In so doing documentation artifacts are produced at the same pace and using similar variability mechanisms that those used for code artifacts. This accounts for three main advantages: uniformity separation of concerns and timely and accurate delivery of the documentation.;
Proceedings of the 9th ACM Symposium on Document Engineering;Highly configurable systems are complex pieces of software. To tackle this complexity hundreds of dedicated analysis techniques have been conceived many of which able to analyze system properties for all possible system configurations as opposed to traditional single-system analyses. Unfortunately it is largely unknown whether these techniques are adopted in practice whether they address actual needs or what strategies practitioners actually apply to analyze highly configurable systems. We present a study of analysis practices and needs in industry. It relied on a survey with 27 practitioners engineering highly configurable systems and follow-up interviews with 15 of them covering 18 different companies from eight countries. We confirm that typical properties considered in the literature (e.g. reliability) are relevant that consistency between variability models and artifacts is critical but that the majority of analyses for specifications of configuration options (a.k.a. variability model analysis) is not perceived as needed. We identified rather pragmatic analysis strategies including practices to avoid the need for analysis. For instance testing with experience-based sampling is the most commonly applied strategy while systematic sampling is rarely applicable. We discuss analyses that are missing and synthesize our insights into suggestions for future research.;
Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering;Conditional compilation and software product line technologies make it possible to generate a huge number of different programs from a single software project. Typing each of these programs individually is usually impossible due to the sheer number of possible variants. Our previous work has addressed this problem with a type system for variational lambda calculus (VLC) an extension of lambda calculus with basic constructs for introducing and organizing variation. Although our type inference algorithm is more efficient than the brute-force strategy of inferring the types of each variant individually it is less robust since type inference will fail for the entire variational expression if any one variant contains a type error. In this work we extend our type system to operate on VLC expressions containing type errors. This extension directly supports locating ill-typed variants and the incremental development of variational programs. It also has many subtle implications for the unification of variational types. We show that our extended type system possesses a principal typing property and that the underlying unification problem is unitary. Our unification algorithm computes partial unifiers that lead to result types that (1) contain errors in as few variants as possible and (2) are most general. Finally we perform an empirical evaluation to determine the overhead of this extension compared to our previous work to demonstrate the improvements over the brute-force approach and to explore the effects of various error distributions on the inference process.;
Proceedings of the International Workshop on Machine Learning Technologies in Software Engineering;Over time many software ecosystems have achieved success. Several organizations are opening their software projects for external businesses creating an multi-organizational government to development their software platform The software architecture has an important participation in this success. In this context there are some studies describing architectural challenges for software ecosystems but little research is investigating how these challenges are being faced by software ecosystems organizations. This paper presents an initial investigation how open source software (OSS) ecosystems have faced several architectural challenges. We conducted interviews with three architects of different OSS ecosystems and gathered some architectural practices to lead with challenges. We also analyzed how these architectural practices have influenced the software ecosystem health introducing the concept of Software Ecosystems Architectural Health.;
Proccedings of the 10th European Conference on Software Architecture Workshops;Many important works have been carried out to provide modeling languages (e.g. UML SDL) with expressiveness to support embedded system design validation and verification. A fundamental shortcoming in current model-driven approaches is the inability to explicitly capture design decisions and trade-offs between different non-functional parameters among which timeliness memory usage and power consumption are of primary interest. This paper highlights technical limitations in UML to specify complex non-functional evaluation scenarios of candidate architectures and outlines our current work to provide straightforward solutions.;
Proceedings of the 3rd International Workshop on Sharing and Reusing Architectural Knowledge;Tracing requirements to their implementation is crucial to all stakeholders of a software development process. When managing software variability requirements are typically expressed in terms of features a feature being a user-visible characteristic of the software. While feature traces are fully documented in software product lines ad-hoc branching and forking known as clone-and-own is still the dominant way for developing multi-variant software systems in practice. Retroactive migration to product lines suffers from uncertainties and high effort because knowledge of feature traces must be recovered but is scattered across teams or even lost. We propose a semi-automated methodology for recording feature traces proactively during software development when the necessary knowledge is present. To support the ongoing development of previously unmanaged clone-and-own projects we explicitly deal with the absence of domain knowledge for both existing and new source code. We evaluate feature trace recording by replaying code edit patterns from the history of two real-world product lines. Our results show that feature trace recording reduces the manual effort to specify traces. Recorded feature traces could improve automation in change-propagation among cloned system variants and could reduce effort if developers decide to migrate to a product line.;
Proceedings of the 21st International Systems and Software Product Line Conference - Volume A;Dynamic Software Product Line (DSPL) Engineering has gained interest through its promise of being able to unify software adaptation whereby software adaptation can be realised at compile time and runtime. While previous work has enabled program logic adaptation by the use of language extensions and platform support little attention has been placed on Graphical User Interface (GUI) variability. Different design patterns including the Model View Controller are commonly used in GUI implementation with GUI documents being used for declaring the GUI. To handle dynamic GUI variability currently the developer needs to implement GUI refinements using multiple techniques. This paper proposes a solution for dealing with GUI document variability statically and dynamically in a unified way. In our approach we currently use a compile time method for producing GUI variants and code transformations to handle these variants within the application at runtime. To avoid GUI duplicates only GUI variants that are unique and related to a valid product configuration are produced. To validate our approach we implemented tool support to enable this for Android based applications.;
Proceedings of the 12th International Conference on Generative Programming: Concepts &amp Experiences;Version control systems are an integral part of today's software and systems development processes. They facilitate the management of revisions (sequential versions) and variants (concurrent versions) of a system under development and enable collaboration between developers. Revisions are commonly maintained either per file or for the whole system. Variants are supported via branching or forking mechanisms that conceptually clone the whole system under development. It is known that such cloning practices come with disadvantages. In fact while short-lived branches for isolated development of new functionality (a.k.a. feature branches) are well supported dealing with long-term and fine-grained system variants currently requires employing additional mechanisms such as preprocessors build systems or custom configuration tools. Interestingly the literature describes a number of variation control systems which provide a richer set of capabilities for handling fine-grained system variants compared to the version control systems widely used today. In this paper we present a classification and comparison of selected variation control systems to get an understanding of their capabilities and the advantages they can offer. We discuss problems of variation control systems which may explain their comparably low popularity. We also propose research activities we regard as important to change this situation.;
Proceedings of the 16th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;The development of variable software in general and feature models in particular is an error-prone and time-consuming task. It gets increasingly more challenging with industrial-size models containing hundreds or thousands of features and constraints. Each change may lead to anomalies in the feature model such as making some features impossible to select. While the detection of anomalies is well-researched giving explanations is still a challenge. Explanations must be as accurate and understandable as possible to support the developer in repairing the source of an error. We propose an efficient and generic algorithm for explaining different anomalies in feature models. Additionally we achieve a benefit for the developer by computing short explanations expressed in a user-friendly manner and by emphasizing specific parts in explanations that are more likely to be the cause of an anomaly. We provide an open-source implementation in FeatureIDE and show its scalability for industrial-size feature models.;
Proceedings of the 2016 ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;In logic metaprogramming programs are not stored as plain textfiles but rather derived from a deductive database. While the benefits of this approach for metaprogramming are obvious its incompatibility with separate checking limits its applicability to large-scale projects. We analyze the problems inhibiting separate checking and propose a class of logics that reconcile logic metaprogramming and separate checking. We have formalized the resulting module system and have proven the soundness of separate checking. We validate its feasibility by presenting the design and implementation of a specific logic that is able to express many metaprogramming examples from the literature.;
Proceedings of the 2008 AOSD Workshop on Early Aspects;Process models for software product-line engineering focus on proactive adoption scenarios---that is building product-line platforms from scratch. They comprise the two phases domain engineering (building a product-line platform) and application engineering (building individual variants) each of which defines various development activities. Established more than two decades ago these process models are still the de-facto standard for steering the engineering of platforms and variants. However observations from industrial and open-source practice indicate that the separation between domain and application engineering with their respective activities does not fully reflect reality. For instance organizations rarely build platforms from scratch but start with developing individual variants that are re-engineered into a platform when the need arises. Organizations also appear to evolve platforms by evolving individual variants and they use contemporary development activities aligned with technical advances. Recognizing this discrepancy we present an updated process model for engineering software product lines. We employ a method for constructing process theories building on recent literature as well as our experiences with industrial partners to identify development activities and the orders in which these are performed. Based on these activities we synthesize and discuss the new process model called promote-pl. Also we explain its relation to modern software-engineering practices such as continuous integration model-driven engineering or simulation testing. We hope that our work offers contemporary guidance for product-line engineers developing and evolving platforms and inspires researchers to build novel methods and tools aligned with current practice.;
Proceedings of the 40th International Conference on Software Engineering: Software Engineering in Practice;"Second Generation Systems and Software Product Line Engineering (2GPLE) has emerged to pick up where classic software product line practice leaves off and is empowering a whole new class of product lines that solve unprecedented challenges of scale and variation complexity. These so-called mega-scale"" product lines often define product spaces with more possible variations than there are atoms in the universe.To deal with product line complexity that is literally astronomical 2GPLE comprises a surprisingly small set of elegant and simple concepts. This tutorial will show how in 2GPLE:- a small set of feature constructs suffices to model the most complex product lines in the world- a small set of variation mechanisms suffices to work in all kinds of shared assets from across the entire engineering lifecycle -- from requirements to architectures design models implementations calibrations parts lists test cases documentation and more- a simple model of configuration management makes product line CM as simple or simpler than single-product CM- application engineering (the partner of domain engineering) is reduced to a vanishingly small activity- off-the-shelf automation is available to exercise variation points in assets based on the features needed in a product being built.Together these concepts make migrating to defining developing and sustaining a product line of almost any size tractable and practical either within an organization or across organizations. Further the products are not limited to software or software-intensive systems 2GPLE is a true systems and software engineering approach.This tutorial will draw upon first-hand experience in applying 2GPLE to some of the best-known product lines in the world from companies such as Lockheed Martin General Dynamics HomeAway and General Motors. In addition to concepts and experience it will also cover roles and responsibilities and organizational adoption and training.""";
Proceedings of the 10th Workshop on Domain-Specific Modeling;Code Review Automation can reduce human efforts during code review by automatically providing valuable information to reviewers. Nevertheless it is a challenge to automate the process for large-scale companies such as Samsung Electronics due to their complexity: various development environments frequent review requests huge size of software and diverse process among the teams. In this work we show how we automated the code review process for those intricate environments and share some lessons learned during two years of operation. Our unified code review automation system Code Review Bot is designed to process review requests holistically regardless of such environments and checks various quality-assurance items such as potential defects in the code coding style test coverage and open source license violations. Some key findings include: 1) about 60% of issues found by Code Review Bot were reviewed and fixed in advance of product releases 2) more than 70% of developers gave positive feedback about the system 3) developers rapidly and actively responded to reviews and 4) the automation did not much affect the amount or the frequency of human code reviews compared to the internal policy to encourage code review activities. Our findings provide practical evidence that automating code review helps assure software quality.;
Proceedings of the 15th International Working Conference on Variability Modelling of Software-Intensive Systems;If traceability links between requirements and source code are not clarified when conducting maintenance and enhancements for the same series of software products engineers cannot immediately find the correction location in the source code for requirement changes. However manually recovering links in a large group of products requires significant costs and some links may be overlooked. Here we propose a semi-automatic method to recover traceability links between requirements and source code in the same series of large software products. In order to support differences in representation between requirements and source code we recover links by using the configuration management log as an intermediary. We refine the links by classifying requirements and code elements in terms of whether they are common or specific to the products. As a result of applying our method to real products that have 60KLOC we have recovered valid traceability links within a reasonable amount of time. Automatic parts have taken 13 minutes 36 seconds and non-automatic parts have taken about 3 hours with a recall of 76.2% and a precision of 94.1%. Moreover we recovered some links that were unknown to engineers. By recovering traceability links software reusability will be improved and software product line introduction will be facilitated.;
Proceedings of the 2008 Workshop on Defects in Large Software Systems;In the research on software product lines product variants typically differ by their functionality and quality attributes are more or less similar across products. To accumulate empirical evidence this paper presents a descriptive case study of performance variability in a software product line of mobile network base stations. The goal is to study the motivation to vary performance and the strategy for realizing performance variability in the product line architecture. The results highlight that the evolution of customer needs motivates performance variability performance variability can be realized either with software or hardware variability strategy with the latter often being prevailing and the software strategy can be kept focused by downgrading performance.;
Proceedings of the 2015 ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;The current technology gives little room for the different kinds of evolution needed for any software product line (SPL): evolution of the associated engineering environment evolution of the market and SPL scope evolution of the products and variability. The paper describes how these different evolution needs are addressed in the CADSE and Selecta systems. The solution we propose uses metamodeling and generation for the engineering environment evolution composition for scope and market evolution a component database and a selection language for the product and variability evolution. The paper presents the Selecta system and shortly discusses the experience.;
Proceedings of the 2nd International Workshop on Product Line Approaches in Software Engineering;A good software process improves software products. In the case of a small software company software development is a matter of survivability due to its limited resources to develop software. XYZ Company is a very small software company that adopted Kanban and DevOps and faced software delivery delays. It is necessary to recommend the software process improvements to solve this problem. Software process improvements are the outcomes of measurement and analysis of maturity levels using the ISO 29110 framework in a qualitative study. They are then analyzed using the Lean Six Sigma tools namely gap analysis root cause analysis and Pareto analysis. Delphi method validated them and resulted in 18 improvement recommendations within four domains namely (a) product (b) people (c) technology and (d) process. The improvements span across two main processes within software development namely (a) Project Management (PM) and (b) Software Implementation (SI). The XYZ Company or any agile-based software company could adopt the 18 improvement recommendations to enhance the software process and quality.;
Proceedings of the 2021 4th International Conference on Software Engineering and Information Management;"System software especially operating systems tends to be highly configurable. Like every complex piece of software a considerable amount of bugs in the implementation has to be expected. In order to improve the general code quality tools for static analysis provide means to check for source code defects without having to run actual test cases on real hardware. Still for proper type checking a specific configuration is required so that all header include paths are available and all types are properly resolved.In order to find as many bugs as possible usually a full configuration"" is used for the check. However mainly because of alternative blocks in form of #else-blocks a single configuration is insufficient to achieve full coverage. In this paper we present a metric for configuration coverage (CC) and explain the challenges for (properly) calculating it. Furthermore we present an efficient approach for determining a sufficiently small set of configurations that achieve (nearly) full coverage and evaluate it on a recent Linux kernel version.""";
Proceedings of the 6th Workshop on Programming Languages and Operating Systems;This paper presents experiences of verifying architectural design rules of the NASA Core Flight Software (CFS) product line implementation. The goal is to check whether the implementation is consistent with the CFS' architectural rules derived from the developer's guide. The results indicate that consistency checking helps a) identifying architecturally significant deviations that were eluded during code reviews b) clarifying the design rules to the team and c) assessing the overall implementation quality. Furthermore it helps connecting business goals to architectural principles and to the implementation. This paper is the first step in the definition of a method for analyzing and evaluating product line implementations from an architecture-centric perspective.;
Proceedings of the ACM-IEEE International Symposium on Empirical Software Engineering and Measurement;Feature-oriented software design is a useful paradigm for building and reasoning about highly-configurable software. By making variability explicit feature-oriented tools and languages make program analysis tasks easier such as bug-finding maintenance and more. But critical software such as Linux coreboot and BusyBox rely instead on brittle tools such as Makefiles to encode variability impeding variability-aware tool development. Summarizing Makefile behavior for all configurations is difficult because Makefiles have unusual semantics and exhaustive enumeration of all configurations is intractable in practice. Existing approaches use ad-hoc heuristics missing much of the encoded variability in Makefiles. We present Kmax a new static analysis algorithm and tool for Kbuild Makefiles. It is a family-based variability analysis algorithm where paths are Boolean expressions of configuration options called reaching configurations and its abstract state enumerates string values for all configurations. Kmax localizes configuration explosion to the statement level making precise analysis tractable. The implementation analyzes Makefiles from the Kbuild build system used by several low-level systems projects. Evaluation of Kmax on the Linux and BusyBox build systems shows it to be accurate precise and fast. It is the first tool to collect all source files and their configurations from Linux. Compared to previous approaches Kmax is far more accurate and precise performs with little overhead and scales better.;
Proceedings of the 13th International Workshop on Variability Modelling of Software-Intensive Systems;This tutorial introduces the essential activities and underlying practice areas of software product line development. It reviews the basic concepts of software product lines discusses the costs and benefits of product line adoption introduces the SEI's Framework for Software Product Line Practice and describes approaches to applying the practices of the framework.;
Proceedings of the 38th International Conference on Software Engineering Companion;Danfoss Drives - one of the largest producers of frequency converters in the world - has been doing Software Product Line development for its frequency converter products for about 3 years. This paper describes the approach used and the experiences with it. It discusses processes ways to convince the unconvinced and arising tool issues when doing product line development.This paper is a follow-up on a previous article which described the product line migration process in detail.;
Proceedings of the 23rd International Systems and Software Product Line Conference - Volume B;Cardinality-based feature models (CFM) constitute a crucial and non-trivial extension to FODA feature models in terms of UML-like feature multiplicities and corresponding cardinality constraints. CFM allow for specifying configuration choices of software systems incorporating multiple instances (copies) of features e.g. for tailoring customer-specific and even potentially unrestricted application resources. Nevertheless the improved expressiveness of CFM compared to FODA feature models complicates configuration semantics including sub-tree cloning and potentially unbounded configuration spaces. As a consequence entirely novel anomalies might arise such as dead cardinality intervals false unboundedness and cardinality gaps which are not properly treated by recent feature-modeling tools. In this paper we present comprehensive tool support for assisting specification validation and configuration of CFM. Our tool CARDYGAN therefore incorporates capabilities for CFM editing automated CFM validation including anomaly detection based on a combination of ILP and SMT solvers as well as a CFM configuration engine based on ALLOY.;
Proceedings of the 10th International Workshop on Variability Modelling of Software-Intensive Systems;In Software Product Line Engineering variability modeling plays a crucial rule. Over the years a couple of different modeling paradigms with a plethora of different approaches have been proposed. However only little attention was spent to compare these concepts. In this paper we compare the capabilities and expressiveness of basic feature modeling with basic decision modeling.In this paper we also present a formalization of basic decision modeling and show that in combination with a powerful constraint language both approaches are equivalent while in their very basic forms they are not equivalent. These results can be used to transfer existing research results between the two paradigms.;
Proceedings of the 23rd International Conference on Evaluation and Assessment in Software Engineering;The transition from a software product line to a software ecosystem as reported by Bosch [5] takes place when the product line company makes its platform available to developers outside the company. A similar transition takes place from a software ecosystem to a collective when the platform is jointly created and owned by a group of members. Building on the literature on software product line economics this research identifies three factors affecting the economics of collectives (level of contribution number of members and diversity of use) and develops a model linking those factors to three economic outcomes (time quality and cost).;
Proceedings of the 2008 International Workshop on Comparison and Versioning of Software Models;[Context] With the proliferation of desktop and mobile platforms the development and maintenance of identical or similar applications on multiple platforms is urgently needed. [Goal] We study a software product deployed to more than 25 software/hardware combinations over 10 years to understand multi-platform development practices. [Method] We use semi structured interviews project wikis VCSs and issue tracking systems to understand and quantify these practices. [Results] We find the projects using MR cloning MR review meeting cross platform coordinator's role as three primary means of coordination. We find that forking code temporarily relieves the coordination needs and is driven by divergent schedule market needs and organizational policy. Based on our qualitative findings we propose quantitative measures of coordination redundant work and parallel development. [Conclusions] A model of coordination intensity suggests that it is related to the amount of paralel and redundant work. We hope that this work will provide a basis for quantitative understanding of issues faced in multi-platform software development.;
Proceedings of the 8th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement;An increasing number of software systems today are systems of systems (SoS) comprising decentralized and heterogeneous systems with operational and managerial independence. The evolution of SoS is the rule and not the exception in practice due to frequently changing requirements technologies and markets. However providing adequate support for the evolution of SoS is rather challenging as their behavior often emerges at runtime and is difficult to predict. Hence SoS must be monitored during simulation and operation to ensure compliance with its requirements. In this position paper we present challenges for SoS evolution from the domain of industrial automation. We discuss existing approaches supporting SoS evolution and derive research issues. We outline requirements for SoS evolution support and present key capabilities of a flexible monitoring and evolution infrastructure. We conclude with a discussion of research perspectives.;
Proceedings of the First International Workshop on Software Engineering for Systems-of-Systems;Variability management is an important issue for the software-intensive systems domain. Such an issue is essential for the success of software product line (SPL) adoption strategies. Although it is a well-discussed subject in the SPL community there is a lack of tool support for environments that handle UML-based SPL variabilities as several variability management approaches take UML as a basis specially its profiling mechanism. Such environments might handle variabilities for several reasons such as evaluating SPLs defining and applying metrics based on a SPL modeling and automating the product generation. Therefore this paper presents the SMartyParser a parser for processing UML-based SPL models. Such models can be obtained in the XMI format from every UML specification-compliant tool. Such a parser provides several services to make it easier the handling of variability data in a particular SPL environment/tool. SMartyParser was built by taking the Open Core framework as a basis for processing XMI files. A parser use example is presented by taking into account the SPL Arcade Game Maker UML models.;
Proceedings of the 22nd International Systems and Software Product Line Conference - Volume 1;Software-product-line engineering is an approach to systematically manage reusable software features and has been widely adopted in practice. Still in most cases organizations start with a single product that they clone and modify when new customer requirements arise (a.k.a. clone-and-own). With an increasing number of variants maintenance can become challenging and organizations may consider migrating towards a software product line which is referred to as extractive approach. While this is the most common approach in practice techniques to extract variability from cloned variants still fall short in several regards. In particular this accounts for the low accuracy of automated analyses and refactoring our limited understanding of the costs involved and the high manual effort. A main reason for these limitations is the lack of realistic case studies. To tackle this problem we provide a set of cloned variants. In this paper we characterize these variants and challenge the research community to apply techniques for reverse engineering feature models feature location code smell analysis architecture recovery and the migration towards a software product line. By evaluating solutions with the developer of these variants we aim to contribute to a larger body of knowledge on this real-world case study.;
Proceedings of the 22nd International Systems and Software Product Line Conference - Volume 2;As the complexity and variety of systems and software products have increased the ability to manage their variability effectively and efficiently became crucial. To this end variability can be specified either as an integral part of the development artifacts or in a separate orthogonal variability model. Lately orthogonal variability models attract a lot of attention due to the fact that they do not require changing the complexity of the development artifacts and can be used in conjunction with different development artifacts. Despite this attention and to the best of our knowledge no empirical study examined the comprehensibility of orthogonal variability models.In this work we conducted an exploratory experiment to examine potential comprehension problems in two common orthogonal variability modeling languages namely Common Variability Language (CVL) and Orthogonal Variability Model (OVM). We examined the comprehensibility of the variability models and their relations to the development artifacts for novice users. To measure comprehensibility we used comprehension score (i.e. percentage of correct solution) time spent to complete tasks and participants' perception of difficulty of different model constructs. The results showed high comprehensibility of the variability models but low comprehensibility of the relations between the variability models and the development artifacts. Although the comprehensibility of CVL and OVM was similar in terms of comprehension score and time spent to complete tasks novice users perceived OVM as more difficult to comprehend.;
Proceedings of the 2011 International Workshop on Early Aspects;The growing use of Software Supply Chains results in an increasing proportion of the functionality of a software product line (SPL) being determined by functionality of suppliers. In order to cover the whole product line it is sometimes necessary to use several suppliers offering partly the same functionality. This leads to overlapping feature models.This paper introduces a Supplier Independent Feature Model (SIFM). Through dependency relations between the SIFM and the feature models of the individual suppliers the variability of the combined components is modelled. In this way the complexity of merging feature models is avoided and the relations with the development artefacts are maintained.The creation of an SIFM is elaborated through an example and a case study. These show that this is a straightforward process and show that the SIFM facilitates the generation of product variants in an efficient manner.;
Proceedings of the 18th International Conference on Evaluation and Assessment in Software Engineering;Many organizations developing software-intensive systems face challenges with high product complexity and large numbers of variants. In order to effectively maintain and develop these product variants Product-Line Engineering methods are often considered while Model-based Systems Engineering practices are commonly utilized to tackle product complexity. In this paper we report on an industrial case study concerning the ongoing adoption of Product Line Engineering in the Model-based Systems Engineering environment at Volvo Construction Equipment (Volvo CE) in Sweden. In the study we identify and define a Product Line Engineering process that is aligned with Model-based Systems Engineering activities at the engines control department of Volvo CE. Furthermore we discuss the implications of the migration from the current development process to a Model-based Product Line Engineering-oriented process. This process and its implications are derived by conducting and analyzing interviews with Volvo CE employees inspecting artifacts and documents and by means of participant observation. Based on the results of a first system model iteration we were able to document how Model-based Systems Engineering and variability modeling will affect development activities work products and stakeholders of the work products.;
Proceedings of the 13th Innovations in Software Engineering Conference (Formerly Known as India Software Engineering Conference);With recent advances in development and deployment of mobile business applications (MBAs) based on the hybrid Web approach (hybrid MBAs) enterprises around the world well recognize new potentials to mobilize their business processes (BPs). Variability has a natural appearance in complex environments of different enterprises where even similar BPs can have varying facets on the cross-enterprise scale. Yet despite this fact current development tools for hybrid MBAs are lacking systematic variability management. Further the literature on this particular technological landscape is scarce. We highlight in this paper emerging importance of this research field and describe its context and a research methodology. We propose an SPL-based approach to tackle considerable variabilities of hybrid MBAs.;
Proceedings of the 37th International Conference on Software Engineering - Volume 2;The development of complex systems such as aircraft product lines requires the support of advanced modeling methodologies such as Model-Based Systems Engineering (MBSE) and Product-Line Engineering (PLE). To enable the development of such complex product lines Airbus is adopting the combination of MBSE and PLE a method previously applied in other industries and known as Model-Based Product Line Engineering (MBPLE). In adopting MBPLE it is necessary to understand the type of constraints that influences the definition of variability within a development program or project. This paper proposes four different dimensions of variability which facilitate and guide the application of MBPLE at Airbus but that can also be extended to other industries and organizations. Those four dimensions namely Co-Variability in product manufacturing and services Variability in development lifecycle Variability in layers of abstraction and Variability in system hierarchy levels are first described. Afterward their impact on the MBPLE method steps namely â€œDefine Product Line Feature Modelsâ€ â€œDefine Product Line Assetsâ€ â€œSelect Member Product Feature Configurationâ€ and â€œDerive Member Product Assetsâ€ is analyzed with the support of an Airbus example.;
Proceedings of the 27th Annual ACM Symposium on Applied Computing;Most software product lines are first specified as an architecture a high-level description of what the overall family system structure is to be like and from which individual product architectures can be generated. This structure however must be mapped onto implementation code stored in a Software Configuration Management system for it to be useful beyond the definitional phase of product line development. Various solutions have been developed to date but the recent emergence of change-based approaches to product line architecture description challenges these existing solutions. In this paper we characterize those challenges and present an alternative solution that relies on a mapping to a change-based Software Configuration Management system. We motivate this choice discuss why it is more appropriate and carefully lay out its strengths and weaknesses relative to the existing state of the art.;
Proceedings of the 11th International Workshop on Variability Modelling of Software-Intensive Systems;"The Collaborations Workshop 2014 (CW14) brought together representatives from across the research community to discuss the issues around software's role in reproducible research. In this paper we summarise the themes practices and ideas raised at the workshop. We also consider how the unconference"" format of the CW14 helps in eliciting information and forming future collaborations around aspects of reproducible research. In particular we describe three distinct areas of concern which emerged from the event: collaboration readiness capability enhancement and advocacy.""";
Proceedings of the 1st ACM SIGPLAN Workshop on Reproducible Research Methodologies and New Publication Models in Computer Engineering;A software product line is a strategic investment for an organization. Besides the initial decision to use a product line approach other strategic decisions are made including which variations to accommodate. In this paper we present an adaptation of an equation for computing option values. The equation can be used to understand the economic impact of adding a variation point to the product line architecture. The equation was exercised on multiple sets of hypothetical data and and produced the expected changes from one data set to another. In the future the equation will be validated with data from real projects. We describe some practical sources of values for the parameters of the equation.;
Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering;Model-Driven Software Product Line Engineering (MD-SPLE) is the combination of Model-Driven Software Development and Software Product Line Engineering. In this paradigm there is a strong dependency relationship between meta-models models transformation specifications and traceability links. Moreover there are also dependency relationships between core assets and product specific artifacts which raise dependency complexity. Due to the pressure to release new product versions and the quantity of dependent elements there is a probability that models and related artifacts are not updated at all and become inconsistent with each other. The proposal of this thesis is to keep MD-SPLE models meta-models transformation specifications and traceability links consistent.;
Proceedings of the International Conference on Management of Emergent Digital EcoSystems;We discuss our experience in use of models and model-driven techniques for developing large business applications. Benefits accrued and limitations observed are highlighted. We describe possible means of overcoming some of the limitations and experience thereof. A case for shift in focus of model driven engineering (MDE) community in the context of large enterprises is argued. Though emerging from a specific context we think the takeaways from this experience may have a more general appeal for MDE practitioners tool vendors and researchers.;
Proceedings of the FSE/SDP Workshop on Future of Software Engineering Research;Early generation Software Product Line (SPL) engineering has evolved into Systems and Software Product Line Engineering (PLE) approaches that extend well beyond the original focus on source code to a more holistic perspective of the engineering lifecycle. PLE tools and methods in commercial practice today support variation management in requirements architecture design models source code documentation configuration data test cases and more. One of the last lifecycle holdouts from PLE has been mechanical engineering or Product Lifecycle Management (PLM). The engineering complexity of mechanical product families with embedded software has increased to a threshold where it is intractable for mechanical and software product line engineering to remain disjoint. This paper explores the convergence of mechanical systems and software product line engineering and why it has been slow to emerge. The reasons are based both on conceptual misalignment among the traditionally distinct disciplines as well the differences between the physics of mechanical and software systems. The Aras Innovator / BigLever Gears Bridge an example PLM and PLE integration is used to illustrate key concepts.;
Proceedings of the 34th ACM/SIGAPP Symposium on Applied Computing;The Web systems domain has faced an increasing number of devices browsers and platforms to cope with driving software systems to be more flexible to accomodate them. Software product line (SPL) engineering can be used as a strategy to implement systems capable of handling such a diversity. To this end automated tool support is almost indispensable. However current tool support gives more emphasis to modeling variability in the problem domain over the support of variability at the solution domain. There is a need for mapping the variability between both abstraction levels so as to determine what implementation impact a certain variability has. In this paper we propose the FeatureJS a FeatureIDE extension aiming at Javascript and HTML support for SPL engineering. The tool combines feature-oriented programming and preprocessors as a strategy to map variability at source code with the variability modeled at a higher level of abstraction. We carried out a preliminary evaluation with an industrial project aiming to characterize the capability of the tool to handle SPL engineering in the Web systems domain.;
Proceedings of the 1st International Workshop on Variability and Complexity in Software Design;Though variability is everywhere there has always been a shortage of publicly available cases for assessing variability-aware tools and techniques as well as supports for teaching variability-related concepts. Historical software product lines contains industrial secrets their owners do not want to disclose to a wide audience. The open source community contributed to large-scale cases such as Eclipse Linux kernels or web-based plugin systems (Drupal WordPress). To assess accuracy of sampling and prediction approaches (bugs performance) a case where all products can be enumerated is desirable. As configuration issues do not lie within only one place but are scattered across technologies and assets a case exposing such diversity is an additional asset. To this end we present in this paper our efforts in building an explicit product line on top of JHipster an industrial open-source Web-app configurator that is both manageable in terms of configurations (â‰ˆ 163000) and diverse in terms of technologies used. We present our efforts in building a variability-aware chain on top of JHipster's configurator and lessons learned using it as a teaching case at the University of Rennes. We also sketch the diversity of analyses that can be performed with our infrastructure as well as early issues found using it. Our long term goal is both to support students and researchers studying variability analysis and JHipster developers in the maintenance and evolution of their tools.;
Proceedings of the 4th International Workshop on Software Engineering for Computational Science and Engineering;What is the number of valid configurations for Linux? How to generate uniform random samples for Linux? Can we create a binary decision diagram for Linux? It seems that the product-line community tries hard to answer such questions for Linux and other configurable systems. However attempts are often not published due to the publication bias (i.e. unsuccessful attempts are not published). As a consequence researchers keep trying by potentially spending redundant effort. The goal of this challenge is to guide research on these computationally complex problems and to foster the exchange between researchers and practitioners.;
Proceedings of the Tenth International Conference on Aspect-Oriented Software Development Companion;Database management systems provide updates with guaranteed durability in the presence of OS crashes or power failures. Durability is achieved by performing synchronous writes to a transaction log on stable non-volatile storage. The procedure is expensive and several techniques have been devised to ameliorate the impact on overall performance at the cost of increased system complexity.In this paper we explore the possibility of reducing the system complexity around logging by leveraging verification instead of using specialised/dedicated hardware or complicated optimisations. The prototype system RapiLog uses a dependable hypervisor based on seL4 to buffer log data outside the database system and its OS and performs the physical disk writes asynchronously with respect to the operation of the database. RapiLog guarantees that the log data will eventually be written to the disk even if the database system or the underlying OS crash or electrical power is cut. We evaluate RapiLog with multiple open-source and commercial database engines and find that performance is never degraded (beyond the virtualisation overhead) and at times is significantly improved.;
Proceedings of the 8th ACM European Conference on Computer Systems;Many of the benefits expected from Software Product Lines (SPLs) are based on the assumption that the additional investment in setting up a product line pays off later when products are created. However to fully exploit this assumption organizations need to optimize the development of core assets and products that bring the maximum business value. The objective of this workshop is to bring together researchers and practitioners to report and discuss the challenges and opportunities for integrating quantitative methods in product line engineering with the objective of achieving both technical and business goals. In particular we are seeking contributions that on the one hand deal with product line estimation and metrics for the effective management of product line projects and on the other hand provide some insight into new trends in value-based product line engineering.;
Proceedings of the 11th International Conference on Generative Programming and Component Engineering;In many domains organizations need to serve a mass market while at the same time customers request highly individual solutions. Companies thus form software ecosystems (SECOs) comprising various related hardware and software product lines (SPLs). Technology changes internal enhancements and customer requests drive the evolution of such SECOs. Multiple projects are conducted in parallel to deliver customized solutions to customers. Developers often adhere to a staged configuration process: first required software components are selected to derive an initial product which is then evolved by refining features and adapting source code to meet customer requirements. These customer-specific solutions are often created using a clone-and-own approach and typically contain features potentially reusable in other solutions. However the awareness of developers about such platform extensions is typically low and feedback from products to SPLs is often lacking. In this research-in-progress paper we thus present a publish-subscribe approach fostering the awareness about feature implementations in SECOs. The approach is based on feature feeds and SECO awareness models.;
Proceedings of the 9th International Workshop on Variability Modelling of Software-Intensive Systems;In the context of software product lines there is often a need to represent graphs containing variability. For example extending traditional modeling techniques or program analyses to variational software requires a corresponding notion of variational graphs. In this paper we introduce a general model of variational graphs and a theoretical framework for discussing variational graph algorithms. Specifically we present an abstract syntax based on tagging for succinctly representing variational graphs and other data types relevant to variational graph algorithms such as variational sets and paths. We demonstrate how (non-variational) graph algorithms can be generalized to operate on variational graphs to accept variational inputs and produce variational outputs. Finally we discuss a filtering operation on variational graphs and how this interacts with variational graph algorithms.;
Proceedings of the 14th International Working Conference on Variability Modelling of Software-Intensive Systems;Model-Based Engineering (MBE) and Product Line Engineering (PLE) have been combined to handle new system development constraints like: increasing complexity higher product quality faster time-to-market and cost reduction. As observed by some authors the derivation of a product from product line shared core assets has been insufficiently addressed and can remain tedious in practice. We cope with this issue focusing on having a flexible and reactive model-based derivation and propose an incremental evolution by extension of the product line coupled with this derivation activity. Process and tools bridge the gap between Application and Domain Engineering introducing a semi-automatic feedback to benefits from the developments made in the Application Engineering. The approach is applied to a model-based product line dedicated to Class diagrams and is tooled within the Eclipse environment.;
Proceedings of the 11th ACM SIGPLAN International Conference on Software Language Engineering;Software projects use build systems to automate the compilation testing and continuous deployment of their software products. As software becomes increasingly configurable the build of multiple configurations is a pressing need but expensive and challenging to implement. The current state of practice is to build independently (a.k.a. clean build) a software for a subset of configurations. While incremental build has been studied for software evolution and relatively small changes of the source code it has surprisingly not been considered for software configurations. In this exploratory study we examine the benefits and limits of building software configurations incrementally rather than always building them cleanly. By using five real-life configurable systems as subjects we explore whether incremental build works outperforms a sequence of clean builds is correct w.r.t. clean build and can be used to find an optimal ordering for building configurations. Our results show that incremental build is feasible in 100% of the times in four subjects and in 78% of the times in one subject. In average 88.5% of the configurations could be built faster with incremental build while also finding several alternatives faster incremental builds. However only 60% of faster incremental builds are correct. Still when considering those correct incremental builds with clean builds we could always find an optimal order that is faster than just a collection of clean builds with a gain up to 11.76%.;
Proceedings of the 44th International Conference on Software Engineering;Handling configurable systems with thousands of configuration options is a challenging problem in research and industry. One of the most common approaches to manage the configuration options of large systems is variability modelling. The verification and configuration process of large variability models is manually infeasible. Hence they are usually assisted by automated analyses based on solving satisfiability problems (SAT). Recent advances in satisfiability modulo theories (SMT) could prove SMT solvers as a viable alternative to SAT solvers. However SMT solvers are typically not utilized for variability analyses. A comparison for SAT and SMT could help to estimate SMT solvers potential for the automated analysis. We integrated two SMT solvers into FeatureIDE and compared them against a SAT solver on analyses for feature models configurations and realization artifacts. We give an overview of all variability analyses in FeatureIDE and present the results of our empirical evaluation for over 122 systems. We observed that SMT solvers are generally faster in generating explanations of unsatisfiable requests. However the evaluated SAT solver outperformed SMT solvers for other analyses.;
Proceedings of the 2014 European Conference on Software Architecture Workshops;When applying model-based techniques to the engineering of embedded application software a typical challenge is the complexity of dependencies between application elements. In many situations e.g. during rollout of products or in the evolution of product lines the understanding of these dependencies is a key capability. In this paper we discuss how model-based techniques in particular model transformations can help to reduce the complexity of such analysis tasks. To this end we realised a representation of Simulink models based on the Eclipse Modeling Framework (EMF). The resulting integration allows us to apply various model-based frameworks from the Eclipse ecosystem. On this basis we developed a view that increases the visibility of functional dependencies which otherwise would have been hidden due to a lack of abstraction in the native Simulink representation. The provided analysis framework comes in handy when such a model has to be modified. Consequently the developer is supported in reusing existing models and avoiding errors. The concepts and techniques are illustrated with a running example which is derived from a real industry model from Automotive Software Engineering.;
Proceedings of the 7th International Workshop on Model-Based Methodologies for Pervasive and Embedded Software;Some programming languages especially dynamic programming languages offer suitable mechanisms for the construction of internal domain-specific languages (DSL). Internal DSLs inherit the facilities of their host language such as the availability of libraries frameworks tool support and other DSLs. When developing an internal DSL there are two challenges. First to cope with the host language's syntactic and semantic restrictions. Careful and thoughtful extensions and modifications of the host language are crucial to overcome these restrictions without reverting to poor language design. Second to support several design principles that are genuine for a DSL. Although there is an extensive body of knowledge about DSL design principles and desirable quality properties it remains difficult to apply them or to reason about whether a particular DSL exhibits specific desirable principles.Our objective is to put the two perspectives together. We research the most important design principles of a DSL and show how different patterns can be used to support these principles. This allows us to produce an extensive pattern catalog which is the foundation of principled approach for designing internal DSLs. The patterns can be used to assess the design quality of a DSL and structure its implementation. In particular we show a complex DSL example illustrating each principle and the corresponding patterns. While we stick to Ruby for the explanation and application of the patterns we also name known uses in Python Scala and Smalltalk. Patterns are explained with their context problem forces solution and consequences. We also explain the patterns with the classical structure of intent motivation forces implementation and their consequences. Finally we reflect upon the pattern utilization by discussing their strengths and weaknesses.;
Proceedings of the 17th Conference on Pattern Languages of Programs;Migrating a family of software systems from ad-hoc development approaches such as `clone-and-own' towards software product lines (SPL) is a challenging task. Software architecture recovery techniques can play a crucial role in such a migration. However it is to date still unclear how these techniques which have been mostly developed for single system architecture recovery in mind can be utilized in an SPL context most effectively. In this paper we present a mapping study examining 35 research articles with the purpose of discussing the current state of the art in applying software architecture recovery techniques for SPL and identifying potential research gaps in this area. The results provide evidence that currently used approaches do not seem to consider the potential architectural degradation that might exist in the family of systems to be migrated. Moreover it is hard to generalize across empirical studies as currently it seems difficult to compare and benchmark the approaches applied for software product line architecture (SPLA) extraction/reconstruction.;
Proceedings of the 12th European Conference on Software Architecture: Companion Proceedings;A Model-Driven Software Product Line (MD-SPL) uses metamodels models and transformations to create a family of products using a Model Refinement Line (MRL). However an MD-SPL must evolve and provide mechanisms to add new crosscutting concerns such as security or logging to the applications. Our problem is that we want to preserve and reuse the original MRL. In this paper we present the challenges associated with this problem. We illustrate them by evaluating different model-driven approaches to add crosscutting concerns into an application using high-level aspects. Furthermore we propose an approach to add crosscutting concerns as early aspects and to preserve the original MRL. This approach adds a new MRL that refines a high-level model of the concern. This high-level model is related with the high-level application model in the original MRL. The refinement of the application model and the concern model proceeds in parallel. The presented approach is a work in progress and requires us to tackle several challenges in order to implement and validate the proposal.;
Proceedings of the 14th ACM International Workshop on Context-Oriented Programming and Advanced Modularity;Software solutions in complex environments such as railway control systems or power plants are assemblies of heterogeneous components which are very large and complex systems themselves. Interplay of these systems requires a thorough design of a system-of-systems (SoS) encompassing the required interactions between the involved systems. One of the challenges lies in reconciliation of the domain data structures and runtime constraints to ensure consistency of the SoS behavior. In this paper we present a generative approach that enables reconciliation of a common platform based on reusable domain models of the involved systems. This is comparable to a product line configuration problem where we generate a common platform model for all involved systems. We discuss the specific requirements for model composition in a SoS context and address them in our approach. In particular our approach addresses the operational and managerial independence of the individual systems and offers appropriate modeling constructs. We report on our experiences of applying the approach in several real world projects and share the lessons learned.;
Proceedings of the 12th International Workshop on Variability Modelling of Software-Intensive Systems;Current market developments require organizations to produce high-quality tailored software variants while simultaneously coping with increased software complexity. Software Product Line Engineering (SPLE) is a well-known approach to manage this variability and complexity however no step-wise migration process is available allowing a co-existence of SPLE along with established development processes. In this paper we introduce an incremental SPLE migration strategy and process starting from using the feature model as synchronized product and variant documentation. They can be applied as a first step of SPLE migration along with the continuous software development cycle. We performed initial steps of the process on industrial low voltage drive embedded firmware spanning around few millions lines of code using a commercial SPLE tool and validated short-term benefits by means of stakeholder feedback.;
Proceedings of the XXX Brazilian Symposium on Software Engineering;Convolutional Neural Networks (CNNs) are intensively used to solve a wide variety of complex problems. Although powerful such systems require manual configuration and tuning. To this end we view CNNs as configurable systems and propose an end-to-end framework that allows the configuration evaluation and automated search for CNN architectures. Therefore our contribution is threefold. First we model the variability of CNN architectures with a Feature Model (FM) that generalizes over existing architectures. Each valid configuration of the FM corresponds to a valid CNN model that can be built and trained. Second we implement on top of Tensorflow an automated procedure to deploy train and evaluate the performance of a configured model. Third we propose a method to search for configurations and demonstrate that it leads to good CNN models. We evaluate our method by applying it on image classification tasks (MNIST CIFAR-10) and show that with limited amount of computation and training our method can identify high-performing architectures (with high accuracy). We also demonstrate that we outperform existing state-of-the-art architectures handcrafted by ML researchers. Our FM and framework have been released to support replication and future research.;
Proceedings of the 11th International Symposium on Software Engineering for Adaptive and Self-Managing Systems;Mature development methodologies like software product line engineering or model-driven engineering are more and more adopted in software development. Accordingly the resulting development processes combine artifacts from different disciplines and on different abstraction levels. It is crucial that the relationship between these artifacts is explicitly maintained to be able to track the development process and the reasons for design decisions. This problem becomes exacerbated if variability is considered since it is a cross-cutting concern that impacts all disciplines and artifacts. Traceability links support the linking of artifacts across model boundaries in an end-to-end manner. However existing traceability solutions are either limited to specific development processes tools and artifact types lack in uniformity or do not consider variability. Thus this paper introduces a MOF-based generic traceability metamodel for establishing uniform traceability-enabled workflows in a variability-aware and model-based environment. Necessary steps for instantiating the metamodel to specific artifact types of certain development processes are described. We evaluate the proposed solution with an exemplar of a car headlight and demonstrate the benefits of a consistent traceability concept.;
Proceedings of the 2009 ESEC/FSE Workshop on Software Integration and Evolution @ Runtime;Combining microservices and software product line engineering (SPLE) is a challenge in variability management. This paper proposes a solution to that challenge by re-engineering existing webshop systems into a product line application. We first perform feature identification to analyze the features of subject systems. We introduce a mechanism that models the variability and designs a software product line architecture based on existing features. We use a UML diagram with the UML-DOP profile to abstract microservice variability in SPLE. Then a transformation into a product line application is conducted to generate running applications based on selected features. We utilize a preliminary framework of microservice variability based on delta-oriented programming.;
Proceedings of the 6th Workshop on Scientific Cloud Computing;Software Product Line engineering aims at reusing and automating software development to reduce costs have shorter development cycles and maintain quality. However for organizations with settled development processes and a large code base adopting an SPL approach may prove to be a daunting task. In this paper we present an industrial experimentation and a proposal for an SPL adoption in Heinsohn Business Technology (HBT) a software development company specialized in financial transportation mortgage-backed securities and pension-fund solutions. We start by identifying and modeling multiple levels of variability inherent to the kind of developments undertaken by HBT. Next we define restrictions inside every level as well as between the levels to fully characterize an HBT software product. To limit the impact on the organization development process we use an extractive approach. This allows us to design core assets starting from current software artifacts. The overall approach is based on real-world software artifacts developed over the years by HBT whose combinations result in approximately 4.88e11 possible product configurations.;
Proceedings of the 5th Asia-Pacific Symposium on Internetware;Feature models are a de facto standard for representing the commonalities and variability of product lines and configurable software systems. Requirements-level features are commonly implemented in multiple source code artifacts which results in complex dependencies at the code level. As developers change and evolve features frequently it is challenging to keep feature models consistent with their implementation. We thus present an approach combining feature-to-code mappings and code dependency analyses to inform engineers about possible inconsistencies. Our focus is on code-level changes requiring updates in feature dependencies and constraints. Our approach uses static code analysis and a variation control system to lift complex code-level dependencies to feature models. We present the suggested dependencies to the engineer in two ways: directly as links between features in a feature model and as a heatmap visualizing the dependency changes of all features in a model. We present results of an evaluation on the Pick-and-Place Unit system which demonstrates the utility and performance of our approach and the quality of the suggestions.;
Proceedings of the 18th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;Inadequate version control has been identified as a major obstacle to the application of model-driven software engineering. In particular sophisticated support for merging model versions is urgently needed. We present a tool for merging of EMF models which may be applied to instances of arbitrary Ecore models. The tool advances the state of the art by guaranteeing a consistent merge result. Furthermore it detects and resolves not only context-free but also context-sensitive conflicts. Our merge tool is model-based it relies on EMF for its implementation. Initial experiences gained from its application confirm that the merge tool operates both accurately and efficiently.;
Proceedings of the Workshop on ACadeMics Tooling with Eclipse;Cyber-physical systems i.e. systems that seamlessly integrate computation and physical components are typically highly-configurable systems. Testing such systems is particularly challenging because they comprise a large number of heterogeneous components that can be configured and combined in different ways. Despite a plethora of work investigating software testing in general and software product line testing in particular variability in tests and how industry does actually manage testing highly configurable cyber-physical systems is not well understood. In this paper we report the results of a multiple case study we conducted with three companies developing and maintaining highly-configurable cyber-physical systems focusing on their testing practices with a particular focus on how they manage variability in tests. We conclude that experienced-based selection of configurations for testing is currently predominant. Variability modeling techniques are not utilized and the dependencies between configuration options are only partially modeled at best. However the companies are aware of the situation and have the need and desire to cover more configuration combinations by automated tests. This in turn raises many questions which might also be of interest to the scientific community and motivate future research.;
Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems;Ideally the variability of a product line is represented completely and correctly by its variability model. However in practice additional variability is often represented on the level of the build system or in the code. Such a situation may lead to inconsistencies where the actually realized variability does not fully correspond to the one described by the variability model. In this paper we focus on configuration mismatches i.e. cases where the effective variability differs from the variability as it is represented by the variability model. While previous research has already shown that these situations still exist even today in well-analyzed product lines like Linux so far it was unclear under what circumstances such issues occur in reality. In particular it is open what types of configuration mismatches occur and how severe they are. Here our contribution is to close this gap by presenting a detailed manual analysis of 80 configuration mismatches in the Linux 4.4.1 kernel and assess their criticality. We identify various categories of configuration issues and show that about two-thirds of the configuration mismatches may actually lead to kernel misconfigurations.;
Proceedings of the 6th ECMFA Traceability Workshop;During the development of embedded software the system context (mechanical electronical business etc.) has to be considered. Typically this context is diverse and highly complex. Moreover the context in which the system is embedded can vary. For example the system can be used in different technical environments or in different countries. This variability in the context influences the software to be developed and typically leads to system variability. This paper systematically analyses the impact of context variability on the system development more precisely on the variability of the system. Related work is discussed and an example from the automotive domain is presented to identify open issues that need to be addressed.;
Proceedings of the 30th Annual ACM Symposium on Applied Computing;This paper presents an aspect-oriented framework which enables dynamically weaving aspects into operating system in order to adjust its functionalities during system operation. The framework is designed based on the notion of dynamic aspect weaving in Aspect-Oriented Programming (AOP) arena which can achieve modulating at runtime the behavior of an existing program by injecting a piece of code (called advice in AOP terminology) at selected location (called join point) of the program. It is useful in making program adaptable especially for non-stopping systems of which in general going off-line for maintenance and undertaking system restart is either unacceptable or too expensive. The design of this framework includes a join point model and management functions on aspects. The join point model supports weaving multiple aspects to the same join point and the chained execution of advices of the same type. The management functions provide the creation deployment and runtime management of aspects in addition to sequencing the execution of advices. An example implementation of this framework working on Linux operating system is described in this paper which demonstrates both the feasibility and the effectiveness of this framework.;
Proceedings of the 2010 ACM Symposium on Applied Computing;Formal verification of variant requirements has gained much interest in the software product line (SPL) community. Feature diagrams are widely used to model product line variants. However there is a lack of precisely defined formal notation for representing and verifying such models. This paper presents an approach to modeling and analyzing SPL variant feature diagrams using first-order logic. It provides a precise and rigorous formal interpretation of the feature diagrams. Logical expressions can be built by modeling variants and their dependencies by using propositional connectives. These expressions can then be validated by any suitable verification tool such as Alloy. A case study of a Computer Aided Dispatch (CAD) system variant feature model is presented to illustrate the analysis and verification process.;
Proceedings of the 26th ACM International Systems and Software Product Line Conference - Volume B;The choice calculus a formal language for representing variation in software artifacts features syntactic forms to map dimensions of variability to local choices between source code variants. However the process of selecting alternatives from dimensions was relegated to an external operation. The lack of a syntactic form for selection precludes many interesting variation and reuse patterns such as nested product lines and theoretical results such as a syntactic description of the configuration process.In this paper we add a selection operation to the choice calculus and illustrate how that increases the expressiveness of the calculus. We investigate some alternative semantics of this operation and study their impact and utility. Specifically we will examine selection in the context of static and dynamically scoped dimension declarations as a well as a linear and comprehensive form of dimension elimination. We also present a design for a type system to ensure configuration safety and modularity of nested product lines.;
Proceedings of the 31st Annual ACM Symposium on Applied Computing;Preprocessors are a common way to implement variability in software. They are used in numerous software systems such as operating systems and databases. Due to the ability of preprocessors to enable and disable code fragments not all parts of the program are active at the same time. Thus programmers and tools need to handle the interactions resulting from annotations in the program. With our Eclipse-based tool FeatureIDE we provide tool support to tackle multiple challenges with preprocessors such as code comprehension feature traceability separation of concerns and program analysis. With FeatureIDE instead of focusing on one particular preprocessor we provide tool support which can easily be adopted for further preprocessors. Currently we support development with CPP Antenna and Munge. https://youtu.be/jVe7f32mLCQ;
Proceedings of the 6th International Workshop on Feature-Oriented Software Development;We address a category of systems whose deployment requires a configuration according to topological information. Although inspired by the case of railway interlocking systems we give a general definition of topologically configurable control systems. We consider the application of product line engineering principles to the development of these systems by discussing the adoption of different approaches to achieve a flexible configuration of products able to factorise most of the design effort as typical in a product line approach.Verifying the behaviour of such systems either by testing or by formal verification is actually a challenge: the intricate relations between the actual topology controlled by a product and its functional requirements may prevent any attempt to factorise analysis activities. We will discuss how the application of product line engineering principles can help with special focus on formal verification pointing to several open research issues.;
Proceedings of the International Conference on Software and System Process;Often either to expand the target market or to satisfy specific new requirements software systems inside a company are cloned refactored and customized generating new derived software systems. Although this is a practical solution it is not effective in the long-term because of the high maintenance costs when maintaining each of these derived software systems. Software product lines (SPLs) were proposed to reduce these costs however the lack of integration between variability realization mechanisms and version control systems reduces its attractiveness in the software development industry especially in small and medium software companies. In this paper we propose an approach to integrate the conditional compilation mechanism used to implement the SPL variabilities and the Git version control system used to manage software versions in order to increase the attractiveness of the SPLs in the industry. The proposed solution also could be seen as a method to manage software system families' evolution in space and time.;
Proceedings of the 7th International Workshop on Feature-Oriented Software Development;This paper describes a demonstration of the product line engineering tool and framework Gears from BigLever software. Gears provides a single feature modeling language a single variation point mechanism and a single automated product configurator that are used to configure a product portfolio's shared engineering assets appropriately for each product in the portfolio. The result is an automated production line capability that can quickly produce any product in the portfolio from the same single set of shared assets.;
Proceedings of the 3rd International Workshop on Variability &amp Composition;Control software for automated production systems (aPs) becomes increasingly complex as it evolves due to changing requirements. To address varying customer demands or altered regulatory guidelines it is common practice to create a new system variant by copying and subsequently modifying existing control software. Referred to as clone-and-own proper documentation is typically not cherished thereby entailing severe maintenance issues in the long-run. To mitigate such problems and to reinstate sustainable development respective software systems need to be compared and their variability information needs to be reverse-engineered. However recent work identified variability management in the domain of aPs to remain a challenging endevour and appropriate tool support to be missing.We bridge this gap and introduce the Variability Analysis Toolkit (VAT) an extensible platform that allows for the customizable definition of metrics to compare IEC61131-3 control software variants as well as providing means to visualize results. The VAT facilitates a working environment that allows for the exchange of produced results between users. By that we aim to support engineers in re-engineering control software systems by providing them with means to define metrics based on their individual demands. We demonstrate the feasibility of the VAT using 24 software system variants implemented in accordance to the IEC61131-3 standard.;
Proceedings of the International Colloquium on Software-Intensive Systems-of-Systems at 10th European Conference on Software Architecture;The aim of domain engineering process is to define and realise the commonality and variability of a Software Product Line. In the context of a family of models spotting the commonalities and differences may become cumbersome and error prone as the number of models and its complexity increases. This work presents an approach to automate the formalization of variability in a given family of models. As output the variability is made explicit in terms of Common Variability Language. The model commonalities and differences are specified as placements over a base model and replacements in a model library. The resulting Software Product Line (SPL) enables the derivation of new product models by reusing the extracted model fragments. Furthermore the SPL can be evolved by the creation of new models which are in turn automatically decomposed as model fragments of the SPL. The approach has been validated with our industrial partner (BSH) an induction hobs company. Finally we present five different evolution scenarios encountered during the validation.;
Proceedings of the Companion Publication of the 2015 Annual Conference on Genetic and Evolutionary Computation;Variability is commonly understood as the ability of a software system or software artifact (e.g. component) to be changed so that it fits a specific context. Variability allows adapting the structure of a software system its behavior or underlying processes. These adaptations are enabled through variation points and variants as options that can be selected at these variation points. So far variability has mainly been studied in the classic software product line domain. However variability is not limited to product lines or families but imposes challenges on software development in general. Many other types of today's software systems are built with variability in mind one prominent type is self-adaptive systems that are capable to adapt autonomously at runtime another is dynamic software product lines that combines principles from product lines with self-adaptation. In this talk I summarize the results of an extensive survey we recently performed on the use of variability in software systems in general [1]. Based on our findings I present dimensions of variability in software engineering. This empirically grounded set of core dimensions provides a step towards an integrated perspective of variability in software systems spanning across loosely coupled research areas in the software engineering community. To conclude I outline some interesting opportunities for future research.;
Proceedings of the 4th International Workshop on Feature-Oriented Software Development;Feature modeling is widely used to capture and manage commonalities and variabilities in software product lines. Cardinality-based feature models are used when variability applies not only to the selection or exclusion of features but also to the number of times a feature can be included in a product. Feature cardinalities are usually considered to apply in either a local or global scope. However we have identified that these interpretations are insufficient to capture the variability of cloud environments. In this paper we redefine cardinality-based feature models to allow multiple relative cardinalities between features and we discuss the effects of relative cardinalities on feature modeling semantics consistency and cross-tree constraints. To evaluate our approach we conducted an analysis of relative cardinalities in four cloud computing providers. In addition we developed tools for reasoning on feature models with relative cardinalities and performed experiments to verify the performance and scalability of the approach. The results from our study indicate that extending feature models with relative cardinalities is feasible and improves variability modeling particularly in the case of cloud environments.;
Proceedings of the XVII Brazilian Symposium on Software Quality;The complexity of configurable systems has grown immensely and it is only getting more complex. Such systems are a challenge for software testing and maintenance because bugs and other defects can and do appear in any configuration. One common requirement for many development tasks is to identify the configurations that lead to a given defect or some other program behavior. We distill this requirement down to a challenge question: given a program location in a source file what are valid configurations that include the location? The key obstacle is scalability. When there are thousands of configuration options enumerating all combinations is exponential and infeasible. We provide a set of target programs of increasing difficulty and variations on the challenge question so that submitters of all experience levels can try out solutions. Our hope is to engage the community and stimulate new and interesting approaches to the problem of analyzing configurations.;
Proceedings of the 24th ACM International Systems and Software Product Line Conference - Volume B;"By analogy with software product reuse the ability to reuse (meta)models and model transformations is key to achieve better quality and productivity. To this end various opportunistic reuse techniques have been developed such as higher-order transformations metamodel adaptation and model types. However in contrast to software product development that has moved to systematic reuse by adopting (model-driven) software product lines we are not quite there yet for modelling languages missing economies of scope and automation opportunities. Our vision is to transpose the product line paradigm at the metamodel level where reusable assets are formed by metamodel and transformation fragments and products"" are reusable language building blocks (model types). We introduce featured model types to concisely model variability amongst metamodelling elements enabling configuration automated analysis and derivation of tailored model types. We provide a wish list of software engineering activities to work with featured model types.""";
Proceedings of the 8th International Workshop on Modeling in Software Engineering;Non-functional properties such as memory footprint have recently gained importance in software product line research. However determining the memory characteristics of individual features and product variants is extremely challenging. We present an approach that supports the monitoring of memory characteristics of individual features at the level of Java virtual machines. Our approach provides extensions to Java virtual machines to track memory allocations and deal-locations of individual features based on a feature-to-code mapping. The approach enables continuous monitoring at the level of features to detect anomalies such as memory leaks excessive memory consumption or abnormal garbage collection times in product variants. We provide an evaluation of our approach based on different product variants of the DesktopSearcher product line. Our experiment with different program inputs demonstrates the feasibility of our technique.;
Proceedings of the 5th IBM Collaborative Academia Research Exchange Workshop;Danfoss Power Electronics is a centre with both extensive power electronics know-how and many competencies within frequency converters and solar inverters. Development of embedded controllers built in Danfoss products raises similar challenges found in many other companies: creation of product series with an increasing number of variants while at the same time decreasing time-to-market and keeping development costs low. Introduction of a Software Product Line approach into product development is a challenge that Danfoss Power Electronics decided to take in order to reduce software development efforts few years ago. The approach has been successful allowing for development of a number of highly engineered products. However the software product line is in a constant evolution. It grows over time as new functionality is added in the form of extra software artefacts and further products are configured from it. As a result the overall complexity and maintenance of assets hinders further efficiency of the approach. This paper presents extension of the variability management that goes beyond the scope of software assets reuse previously introduced into the organization. A prototype of the technique linking multi-level variability management is further elaborated using pure::variants.;
Proceedings of the 2nd International Workshop on Feature-Oriented Software Development;Studies show that CS enrollments are dropping. Reasons for the drop vary from the perception that there is a lack of jobs and outsourcing to misconceptions about the computing profession. Recommendations to increase enrollments include industry alignment and multi / cross disciplinary programs. EMC Corporation the world leader in information management and data storage believes that CS programs need to align with industry. EMC created the EMC Academic Alliance Program to educate students on the fastest growing segment of IT: Storage. Offering courses in storage technologies will benefit students and prepare them for the emerging roles of the 21st century.;
Proceedings of the 2008 ACM SIGMIS CPR Conference on Computer Personnel Doctoral Consortium and Research;Document Product Lines (DPL) is an approach to variable content document generation based on the definition of document families that share parts of common content while differ in others. Following principles of the Software Product Line Engineering the production of the different documents in a family is performed with a high degree of reuse of document components. In this paper we have used DPL for the development of variable content recipe documents. We describe a flexible approach to recipe generation that allows the customization of recipe content in terms of different factors such as user expertise ingredients and even delivery format.;
Proceedings of the 5th International Workshop on Multimedia for Cooking &amp Eating Activities;Emerging domains such as smart homes and more recently smart cities represent a big challenge to software engineering. In such context the need of runtime self-adaptations to cope with both user needs and environmental changes brings Dynamic Software Product Lines (DSPL) as a suitable solution. However DSPL implementation itself is challenging which demands a proper modeling. In this sense the literature still lacks of means of choosing the modeling technique that best fits a given domain. This paper tackles such problem by defining a criteria for rank such techniques which is used for ranking a set DSPL modeling techniques found in the literature.;
Proceedings of the Fifth International Workshop on Product LinE Approaches in Software Engineering;Runtime variability is becoming an attractive technique to support those runtime scenarios for systems that demand some kind of autonomous reconfiguration or adaptive behavior. Nowadays the challenge of many critical systems that need to handle different operational modes often in an unattended mode require specific solutions for which runtime variability mechanisms become relevant. This research describes the challenges of runtime variability to support multiple binding modes for handling the diversity of different operational modes and runtime reconfiguration needs. We validate our approach in a power plant control product line at Toshiba which advances previous work making the transition between the power plant operational modes more automatic and dynamic.;
Proceedings of the 2015 ACM SIGPLAN International Conference on Software Language Engineering;Software and systems engineering is challenged by variability in space (concurrent variations at a single point in time) and time (sequential variations due to evolution). Managing both dimensions of variability independently is cumbersome and error-prone. A common foundation for operations on these dimensions is still missing hampering the comparison and integration of existing techniques coping with variability in space and time as well as the design of new ones. In this paper we address this problem by systematically identifying categorizing and unifying operations from contemporary tools and extending them to cope with both variability dimensions. Based on our gained insights we identify gaps and trade-offs in current tools for managing variability in space and time and discuss open challenges. The unified operations establish a common foundation that helps researchers and practitioners to gain a deeper understanding of existing techniques and tools for managing variability in space and/or time analyze and compare them and design new ones.;
Proceedings of the International Conference on Intelligent Information Processing Security and Advanced Communication;Linux is a highly configurable operating-system kernel which has been widely studied in the context of software product lines over the past years. Understanding the challenges and perils of evolving and maintaining feature models of the size of Linux is crucial to provide the right tools for development today and to direct future research. Unfortunately previous studies show contradictory observations when analyzing the evolution of Linux feature models. We explain how peculiarities of the feature models of the Linux kernel lead to those differing observations and show how the results can be re-aligned. Moreover our findings also demonstrate that symbolic differencing on feature models used by researchers so far has limited value depending on the use case. We show how the limitations can be addressed by means of semantic differencing and ironically invalidate the results we sought to re-align.;
Proceedings of the XXXI Brazilian Symposium on Software Engineering;There is growing trend towards using Commercial off the shelf (COTS) software within enterprises as against developing custom-built software. IT service providers who specialize in executing COTS implementation projects have to deal with the problem of managing variability within the implementations at different customer enterprises. Customer specific implementations would have variations across different dimensions such as product used industry vertical business processes navigational flows user interface technology platform and so on. In this paper we describe the practical problems faced by service providers in managing variability within test cases for COTS implementations. We draw upon the experience shared with us by practitioners from COTS implementation testing teams and teams who have been developing reusable test cases for various COTS products. We motivate the need for further research on test notations/meta-models for business applications and variability management within these models.;
Proceedings of the 10th International ACM Sigsoft Conference on Quality of Software Architectures;In multi-tenant Software as a Service (SaaS) business software the degree of tenants' satisfaction is a significant indicator of the success of the SaaS system. Tenants' satisfaction can be achieved by continuously fulfilling their evolving needs. Usually SaaS providers frequently deliver new releases of the application. Each release contains new or enhanced features. However SaaS providers have limited resources which makes it difficult to them to incorporate all of the tenants' requests in the next release. Therefore some requirements shall be postponed to later releases. In order to achieve the highest possible level of tenets' satisfaction SaaS providers shall include the most common requirements in the next release which guarantee the satisfaction of highest possible number of tenants with less effort. Additionally tenants' priorities and preferences about the requirements must be considered. Besides maximizing tenants' satisfaction it is crucial to meet different types of constraints such as resource technical and contractual constraints. This paper identifies the factors that govern the release planning process for multi-tenant business software which are contractual constraints commonality of requirements tenants' preferences and decision weights risk technical constraints. The first two factors are suggested by this paper while the remaining factors are inherited from the traditional release planning process. Moreover this paper proposes a framework that deals with the uniqueness of the release planning process in multi-tenant SaaS system. In this framework Binary Linear Programming (BLP) is employed to optimize the selection process of the requirements that will be implemented in the next release. An experiments section is provided to illustrate the degree of satisfaction that can be achieved using the proposed framework.;
Proceedings of the 2014 International C* Conference on Computer Science &amp Software Engineering;Product line development of communication system firmware with more than 2000 features was performed in a large-scale project that involved more than 300 engineers (at a maximum) across four distributed sites. However since intense demands to reduce development costs and time made it prohibitive to construct core assets for all those identified features the project screened a limited number of the features for which core assets were constructed and then performed partial application of product line engineering. Nevertheless when compared with previously engineered derivative developments when the second product of the product line was released it was clear that the project had achieved significant improvements in quality as well as reductions in development costs and time requirements. Automatic code generation also contributed to those improvements.;
Proceedings of the 7th Workshop on Reflection AOP and Meta-Data for Software Evolution;Complex software products are often subject to application context specific configuration and variations. Variability management is a critical aspect of engineering software product families efficiently. However the variability management on the data aspect of systems has received less attention. In this paper we present SVL Tool a plug-in for the Case Tool DB-Main which enables software engineers to model feature models map them to database schema elements and finally produce a new database schema including only the selected features. We present the Simple Variability Language a language designed on the basis of the Common Variability Language. We also present our results of applying SVL Tool to a case study an Electronic Medical Records software program widely used in Canadian primary health care.;
Proceedings of the VII Brazilian Symposium on Software Components Architectures and Reuse;The United Nations Centre for Trade Facilitation and Electronic Commerce provides a conceptual approach named Core Components for defining business document models based on reusable building blocks. For the application in concrete business scenarios these building blocks need customizing resulting in different variants of business document models. In previous work we have proven the application of concepts from Model-Driven Product Line Engineering to manage the resulting business document model variants. However due to the highly dynamic environment of electronic commerce with ever-changing market requirements business document models evolve over time. This adds another dimension of variability to the problem domain leading to complex evolution scenarios. In this paper we define evolution patterns for capturing the different types of evolution present in the context of business document model variants. Having such patterns at hand makes the different types of evolution in business document models more tangible.;
Proceedings of the 21st European Conference on Pattern Languages of Programs;The paper describes a demonstration of pure::variants a commercial tool for variant and variability management for product lines. The demonstration shows how flexible product line (PL) architectures can be built tested and maintained by using the modeling and integration capabilities provided by pure::variants. With pure::variants being available for a long time the demonstration (and the paper) combines both basics of pure::variants known to parts of the audience and new capabilities introduced within the last year.;
Proceedings of the 2019 Summer Simulation Conference;Since the emergence of XaaS and Cloud Computing paradigms the number and complexity of available services have been increasing enormously. These services usually offer a plethora of configuration options which can even include additional services provided as a bundled offer. In this scenario usual tasks such as description discovery and selection become increasingly complex due to the variability of the decision space. The notion of Highly-Configurable Service (HCS) has been coined to identify such group of services that can be configured and bundled together to perform demanding computing tasks. In this paper we characterize HCSs by means of an abstract model and a text-based human-readable notation named SYNOPSIS that facilitates the execution of various service tasks. In particular we validate the usefulness of our model when checking the validity of HCSs descriptions in SYNOPSIS as well as selecting the optimal configuration with regards to user requirements and preferences by providing a prototype implementation.;
Proceedings of the 17th International Doctoral Symposium on Components and Architecture;This tutorial provides an introduction to the basic concepts of software product line engineering: business orientation variability management architecture-driven development and the two-lifecycle approach.Based on this introduction the Families Evaluation Framework (FEF) is described. This is a systematic approach to evaluating a product line organization and its development approach. The material in this tutorial also provides the basis for the tutorial on inner source software product lines.;
Proceedings of the 33rd Annual ACM Symposium on Applied Computing;Change is inevitable for software systems to deal with the evolving environment surrounding them and applying changes requires careful design and implementation not to break existing functionalities. Evolution in software product lines (SPLs) is more complex compared to evolution for individual products: a change applied to a single feature might affect all the products in the whole product family. In this paper we present an approach for change impact analysis in delta-oriented programming (DOP) an existing language aimed at supporting SPLs. We propose the CIAHelper tool to identify dependencies within a DOP program by analyzing the semantics of both the code artifacts and variability models to construct a directed dependency graph. We also consider how the source code history could be used to enhance the recall of detecting the affected artifacts given a change proposal. We evaluate our approach by means of five case studies on two different DOP SPLs.;
Proceedings of the 39th International Conference on Software Engineering Companion;A Dynamic Software Product Line (dspl) is a widely used approach to handle variability at runtime e.g. by activating or deactivating features to adapt the running configuration. With the emergence of highly configurable and evolvable systems dspls have to cope with the evolution of their structural variability i.e. the Feature Model (fm) used to derive the configuration. So far little is known about the evolution of the fm while a configuration derived from this fm is running. In particular such a dynamic evolution changes the dspl configuration space which is thus unsynchronized with the running configuration and its adaptation capabilities. In this position paper we propose and describe an initial architecture to manage the dynamic evolution of dspls and their synchronization. In particular we explain how this architecture supports the evolution of dspls based on fms extended with cardinality and attributes which to the best of our knowledge has never been addressed yet.;
Proceedings of the 10th International Symposium on Software Engineering for Adaptive and Self-Managing Systems;The Department of Defense (DoD) Modeling &amp Simulation Coordination Office (M&ampSCO) in collaboration with the Personnel &amp Readiness (P&ampR)/Force Readiness &amp Training (FR&ampT) Directorate/Joint Assessment and Enabling Capability (JAEC) Office sponsored the initial work on a Defense Handbook on Conceptual Modeling for Models and Simulation Systems. The objective of the handbook is the presentation of various paradigms that can help the project managers and project execution offices (PEO) to support their various needs. This paper presents summaries of a subset of these paradigms covered in more detail in the handbook such as conceptual modeling for data rights management the Robinson Template to capture conceptual modeling for management conceptual modeling of information exchange longevity and reuse general methods contributing to recommended best practices of conceptual modeling and intellectual property rights.;
Proceedings of the 48th Annual Simulation Symposium;Variability is an inherent property of software systems to create families of products dealing with needs of different customers and environments. However some practices to manage variability may incur technical debt. For example the use of opportunistic reuse strategies e.g. clone-and-own harms maintenance and evolution activities or deciding to abandon variability management and deriving a single product with all the features might threaten system usability. These examples are common problems found in practice but to the best of or knowledge not properly investigated from the perspective of technical debt. To expand the knowledge on the research and practice of technical debt in the perspective of variability management we report results of this phenomenon which we defined as variability debt. Our work is based on 52 industrial case studies that report problems observed in the use of opportunistic reuse. The results show that variability debt is caused by business operational and technical aspects leads to complex maintenance creates difficulties to customize and create new products misuse of human resources usability problems and impacts artifacts along the whole life-cycle. Although some of these issues are investigated in the field of systematic variability management e.g. software product lines our contribution is to present them from a technical debt perspective to enrich and create synergies between the two fields. As additional contribution we present a catalog of variability debts in the light of technical debts found in the literature.;
Proceedings of the XX Brazilian Symposium on Software Quality;Safety-critical autonomous systems are becoming highly variant-intensive with thousands of variations points within a single product. Modeling these systems requires the specification of safety properties but the diversity of these properties makes hard to configure these systems manually to prevent emerging hazards and fault behaviors. Because existing software variability techniques provide rudimentary mechanisms for mapping variability constructs to functional safety models we describe in this paper an experience report showing how a novel annotative modeling approach and tool can be used to derive system models enriched with functional safety information. We validate our approach using a case study from the automotive domain and we estimate the effort reduction in the tasks comparing our approach with two similar tools.;
Proceedings of the 15th Brazilian Symposium on Software Components Architectures and Reuse;Technical projects environments i.e. sets of methods and tools that support an engineering project are software-intensive systems that need to be configured according to software process and project characteristics. Tailored software processes e.g. based on the V Modell XT framework specify project process steps and drive method and tool selection with a focus on individual feature requirements. Therefore feature models can support the automated selection and configuration of methods and tools. For designing an effective and efficient engineering project environment project managers and engineering domain experts can semantically integrate a given set of engineering tools and project data models in a flexible way. In this paper we analyze challenges of managing engineering tool variability in context of engineering project environment configurations and present a conceptual approach using semantic modeling of project requirements and tool capabilities.;
Proceedings of the 11th International Conference on Product Focused Software;There are some Quality Attributes (QAs) whose variability is addressed through functional variability in the software architecture. Separately modelling the variability of these QAs from the variability of the base functionality of the application has many advantages (e.g. a better reusability) and facilitates the reconfiguration of the QA variants at runtime. Many factors may vary the QA functionality: variations in the user preferences and usage needs variations in the non-functional QAs variations in resources hardware or even in the functionality of the base application that directly affect the product's QAs. In this paper we aim to elicit the relationships and dependencies between the functionalities required to satisfy the QAs and all those factors that can provoke a reconfiguration of the software architecture at runtime. We follow an approach in which the variability of the QAs is modelled separately from the base application functionality and propose a dynamic approach to reconfigure the software architecture based on those reconfiguration criteria.;
Proceedings of the 43rd International Conference on Software Engineering;"Within software product lines customers may have different quality needs. To produce products with purposefully different quality attributes several challenges must be addressed. First one must be able to distinguish product quality attributes to the customers in a meaningful way. Second one must create the desired quality attribute differences during product-line architecture design and derivation. To study how performance is varied purposefully in software product lines we conducted a comparison and re-analysis of two industrial case studies in the telecommunication and mobile game domains. The results show that performance variants must be communicated to the customer in a way that links to customer value and her role. When performance or its adaptation are crucial for the customer performance differences must be explicitly designed in"" with software or hardware means. Due to the emergent nature of performance it is important to test performance and manage how other variability affects performance.""";
Proceedings of the 18th European Conference on Pattern Languages of Program;Since software engineering is globalized and not a homogeneous whole we expect that development practices are differently adopted across domains. However little is known about how practices are followed in different software domains (e.g. healthcare banking and Oil and gas). In this paper we report the results of an exploratory and inductive research in which we seek differences and similarities regarding the adoption of several widespread practices across 13 domains. We interviewed 19 worldwide developers with experience in multiple domains (i.e. cross-domain developers) from large multinational companies such as Facebook Google and Macy's. We also run a Web survey to confirm (or not) the interview results. Our findings show that in fact different domains adopt practices in a different fashion. We identified that continuous integration practices are interrupted during important commerce periods (e.g. Black Friday) in the financial domains. We also noticed the company's culture and policies strongly influence the adopted practices instead of the domain itself. Our study also has important implications for global software engineering practices. For instance companies should provide targeted training for their development teams and new interdisciplinary courses in software engineering and other domains such as healthcare are highly recommended.;
Proceedings of the 14th International Conference on Global Software Engineering;Today's complex software systems are highly variable systems of systems (SoS) that evolve continuously to meet new customer requirements or to address technological changes. Despite thorough testing of the different parts of an SoS the full behavior often emerges during operation only. The systems and their interactions thus need to be continuously monitored and checked during operation to determine compliance with their requirements. In particular after changes to one system it is necessary to check whether the overall SoS still behaves correctly and as intended. Based on an existing monitoring framework we are developing support for capturing and comparing event traces in SoS. Our approach facilitates and partly automates identifying differences in event traces which often indicate undesirable behavior introduced during evolution. In this position paper we motivate capture-and-compare support in SoS using an industrial example and present early research results including a prototype.;
Companion of the 2019 ACM/SPEC International Conference on Performance Engineering;Product line engineering (PLE) is well-known for the savings it brings to organizations. This paper shows how a very large in-service systems and software product line is achieving PLE-based savings in their verification and validation phase of development. The paper addresses how to achieve the sharing across product variants while the products being tested are evolving over time. Additionally we will give a pragmatic set of decision criteria to help answer the longstanding issue in PLE-based testing of whether to test on the domain side or the application (product) side of the product derivation process.;
Proceedings of the Third International Workshop on Conducting Empirical Studies in Industry;The 'clone and own' approach to software product lines assumes that variants are created by cloning and evolve more or less independently afterwards. In this paper we describe a process to manage similarity of such 'cloned and owned' variants along the timeline. The process uses annotations for recording developer intentions and it leverages automatic change propagation. We describe a case study where we manage similarity for clowned-and-owned Haskell-based variants of a simple human-resources management system.;
Proceedings of the 9th International ACM Sigsoft Conference on Quality of Software Architectures;For the development of the Extremely Large Telescope the European Southern Observatory uses state machines to define life cycles and basic behavior of control software components. To provide certain degrees of freedom the component life cycles need to be customizable but to remain compatible they must also conform to specific standard behavior. High customization causes difficulties in maintenance and may also lead to incompatible solutions. On the other hand the introduction of strict compatibility requirements may increase maintainability but it also make the system less flexible. To avoid spending a significant portion of the Assembly Integration and Verification phase in integration hell finding the right balance between variability and compatibility early enough is important.To address this problem we have analyzed different variability realization mechanisms with respect to their applicability for the behavioral customization of state machine models. Based on this analysis an approach has been researched that combines a set of variability realization mechanisms and thereby enables open and step-wise customization systematic reuse and separation of concerns. The approach enhances a framework approach with model manipulation capabilities and mixin composition while also supporting conditional compilation and conditional execution. We demonstrate feasibility and soundness of the elaborated approach using a proof of concept implementation that has already been integrated into a real-world project in scope of the ELT program.;
Proceedings of the 11th International ACM SIGSOFT Conference on Quality of Software Architectures;Big companies use many tools jointly referred to as the toolchain to manage vast amounts of engineering data being generated across an application lifecycle. Individual tools are typically designed to perform specific engineering tasks and rely on specific data formats. This leads to problems when attempting to automate engineering tasks that are not supported by a particular tool and which require data from multiple tools. This paper presents the experiences and lessons learned from an industrial research-project within the heavy vehicle manufacturer Scania where the project goal was to identify and industrialize technologies and principles that solve the above problem. The presented lessons cover architectural technological and organizational aspects of a toolchain development-process. In addition as a consequence of the lessons learned the toolchain architecture and tool-interface architecture is also presented.;
Proceedings of the 21st International Conference on Information Integration and Web-Based Applications &amp Services;In order to manage scale and complexity various modeling techniques have been proposed but they are not scalable enough to develop modern software product lines. We need close investigation of modeling problems in industries to develop actually scalable modeling techniques. In this workshop we focus on the scalability and try to solicit ideas and research directions in this field.;
Proceedings of the 8th ACM SIGPLAN International Workshop on Feature-Oriented Software Development;Nowadays systems are often developed following the product line approach in order to reduce time to market achieve lower cost and ensure high quality. To this end common and variable requirements of product variants are specified as features in a feature model so that each product variant can be configured and customized along the development lifecycle. While developers in family engineering tend to use variability management tools (e.g. pure::variants) for feature modeling and developing core assets for reuse such sophisticated tools might be too complicated and inappropriate for product configuration in application engineering. In order to solve this challenge this paper introduces an Excel-based product configurator called EXConfig which focuses on product line features in the problem space and supports staged product configuration in application engineering. This tool can be easily customized and integrated with other system design tools or variability management tools which connects application engineering and family engineering in development. The usage of this tool and its integration have been validated several times in industry.;
Proceedings of the XXXV Brazilian Symposium on Software Engineering;In an industrial context software systems are rarely developed by a single organization. For software product lines this means that various organizations collaborate to provide and integrate the assets used in a product line. It is not uncommon that these assets themselves are built as product lines a practice which is referred to as multi product lines. This cross-organizational distribution of reusable assets leads to numerous challenges such as inconsistent configuration costly and time-consuming integration diverging evolution speed and direction and inadequate testing.The MultiPLE workshop is aimed at discussing the challenges involved with the development and evolution of multi product lines and the assets used for their production.;
Proceedings of the 2017 International Conference on Management Engineering Software Engineering and Service Sciences;"The disparity of educational technologies pedagogies and learning styles implies a problem of variability when modeling E-learning systems. Furthermore the current learning context which has become very open and heterogeneous raises the problem of automating the modeling development and maintenance of personalized E-learning systems based on various pedagogies. For its part the Software Product Line"" is a paradigm that aims to produce product families based on the principles of reuse configuration and derivation. The main purpose of this literature review is to explore the different potential applications of ""SPL"" in the E-learning domain to figure out the problem of variability. We will adopt a protocol for a systematic review of literature after which we will draw up an analysis report.""";
Proceedings of the 12th International Conference on Intelligent Systems: Theories and Applications;The proliferation of cyber-physical systems has encouraged the emergence of new technologies and paradigms to improve the performance of IoT-based applications. Edge Computing proposes using the nearby devices in the frontier/Edge of the access network for deploying application tasks. However the functionality of cyberphysical systems which is usually distributed in several devices and computers imposes specific requirements on the infrastructure to run properly. The evolution of an application to meet new user requirements and the high diversity of hardware and software technologies in the edge can complicate the deployment of evolved applications.The aim of our approach is to apply Multi Layer Feature Models which capture the variability of applications and the infrastructure to support the deployment in edge-based environments of cyber-physical systems applications. This separation can support the evolution of application and infrastructure. Considering that IoT/Edge/Cloud infrastructures are usually shared by many applications the SPL deployment process has to assure that there will be enough resources for all of them informing developers about the alternatives of deployment. Prior to its deployment and leaning on the infrastructure feature models the developer can calculate what is the configuration of minimal set of devices supporting application requirements of the evolved application. In addition the developer can find which is the application configuration that can be hosted in the current evolved infrastructure.;
Proceedings of the 5th International Workshop on Modeling in Software Engineering;The ecosystem within which a software product line resides is a network of organizations producing and consuming software assets and the linkages among those assets. The complexity of the relationships among the elements in the ecosystem requires analytic techniques to predict the effects of strategic decisions on the network of suppliers buyers collaborators and ecosystem. The STRategic Ecosystem Analysis Method (STREAM) guides the collection of data and structures a model that can be queried.;
Proceedings of the XVII Brazilian Symposium on Information Systems;In Machine Learning (ML) the resolution of anomaly detection problems in time series presents a great diversity of practices as it can correspond to many different contexts. These practices cover both grasping the business problem and designing the solution itself. By practice we designate explicit and implicit steps toward resolving a problem while a solution corresponds to a combination of algorithms selected for their performance on a given problem. Two related issues arise. The first one is that the practices are individual and not explicitly mutualized. The second one is that choosing one solution over another is all the more difficult to justify because the space of solutions and the evaluation criteria are vast and evolve rapidly with the advances in ML. To solve these issues and tame the evolving diversity in ML a Software Product Line (SPL) approach can be envisaged to represent the variable set of solutions. However this requires characterizing an ML business problem through an explicit set of criteria and justifying one ML solution over all others. The resolution of anomaly detection problems is thus different from finding the best configuration workflow from past configurations but lies more in guiding the configuration towards a solution that may never have been studied before. This paper proposes an SPL approach that capitalizes on past practices by exploiting a variability-aware representation to detect new criteria and constraints when practices adopt different solutions to seemingly similar problems. We report on the evaluation of our approach using a set of applications from the literature and an ML software company. We show how the analysis of practices makes it possible to consolidate the knowledge contained in the SPL.;
Proceedings of the 8th International Conference on Software Development and Technologies for Enhancing Accessibility and Fighting Info-Exclusion;Customizing and reusing software processes is a common practice for addressing the diversity of software projects. This fact expanded the number of Software Process Lines (SPrL) researches based on concepts derived from the Software Product Line approach. However SPrL is still incipient with regard to existing literature providing de facto empirical studies on comparing SPrL variability modeling capabilities. In this context approaches such as SMartySPEM and vSPEM both based on the Metamodel Software and System Process Engineering Metamodel (SPEM) were proposed as annotative mechanisms for variabilities representation in SPrL. We compared SMartySPEM and vSPEM for comprehensibility and variability mechanism in a previous controlled quasi-experiment. Results from such study suggested further investigation on variability modeling of both approaches. Therefore this paper presents an empirical study which qualitatively compares such approaches based on Modularity Traceability Error Detection Granularity Adoption and Systematic Variability Management. Experts were invited to contribute to our study. Their feedback was analyzed based on Grounded Theory procedures such as Coding. Results provided initial evidence SMartySPEM had better results compared to vSPEM except for the Adoption criterion. In addition several points of improvement for SMartySPEM were highlighted.;
Proceedings of the 21st ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;This paper proposes a software design modelling approach that uses the Common Variability Language (CVL) to specify and resolve the variability of a software design and the aspect-oriented modelling technique Reusable Aspect Models (RAM) to specify and then compose the detailed structural and behavioural design models corresponding to the chosen variants. This makes it possible to 1) exploit the advanced modularization capabilities of RAM to specify a complex detailed design concern and its variants by means of a set of interdependent aspect models 2) use CVL to provide an easy-to-use product-line interface for the design concern 3) automatically generate a detailed design model for a chosen variant using a custom generic CVL derivation operator and the RAM weaver.;
Proceedings of the VARiability for You Workshop: Variability Modeling Made Useful for Everyone;The Cisco Video Conferencing Systems (VCS) Product Line is composed of many distinct products that can be configured in many different ways. The validation of this product line is currently performed manually during test plan design and test executions' scheduling. For example the testing of a specific VCS product leads to the manual selection of a set of test cases to be executed and scheduled depending on the functionalities that are available on the product. In this paper we develop an alternative approach where the variability of the VCS Product Line is captured by a feature model while the variability within the set of test cases is captured by a component family model. Using the well-known pure::variants tool approach that establishes links between those two models through restrictions we can obtain relevant test cases automatically for the testing of a new VCS product. The novelty in this paper lies in the design of a large component family model that organizes a complex test cases structure. We envision a large gain in terms of man-power when a new product is issued and needs to be tested before being marketed.;
Proceedings of the 25th International Conference on Program Comprehension;The number of software systems in a company typically grows with the business requirements. Therefore IT landscapes in large companies can consist of hundreds or thousands of different software systems. As the evolution of such large-scale landscapes is often uncoordinated they commonly comprise different groups of related software systems using a common core technology (e.g. Java Web-Application) implemented by a variety of architectural components (e.g. different application servers or databases). This leads to increased costs and higher effort for maintaining and evolving these software systems and the entire IT landscape. To alleviate these problems the variability of such technically related software systems has to be reduced. For this purpose experts have to assess and evaluate restructuring potentials in order to take appropriate restructuring decisions. As a manual analysis requires high effort and is not feasible for large-scale IT landscapes experts face a major challenge. To overcome this challenge we introduce a novel approach to automatically support experts in taking reasonable restructuring decisions. By providing automated methods for assessing evaluating and simulating restructuring potentials experts are capable of reducing the variability of related software systems in large-scale IT landscapes. We show suitability of our approach by expert interviews and an industrial case study with architectures of real-world software systems.;
Proceedings of the 28th Annual International Conference on Computer Science and Software Engineering;Aspect-oriented programming makes possible to express changes in a modular way directly at the level of programming language constructs. This is particularly useful in situations that require explicit change manipulation such as change reapplication to another version branch in application customization. However it may be tricky to employ appropriate aspect-oriented constructs in a correct way that accommodates well the change to be implemented. This has been successfully addressed by an approach to aspect-oriented change realization based on a two-level change type model which features a catalog of specification and implementation change types and their relationships primarily targeting the web application domain. In this paper we explore the applicability of the change types gathered in this catalog for the mobile application domain. For this we performed a study that involved a set of hypothetical scenarios and two real mobile applications for Android. The study revealed that the change types known from the web application domain are in their essence applicable to the mobile application domain. It also lead to the discovery of four new specification change types in the mobile application domain and the corresponding specification--implementation change type relationships along with further relationships between known change types.;
Companion Proceedings of the 2nd International Conference on the Art Science and Engineering of Programming;For the purpose of certification manufactures of nowadays highly connected safety-critical systems are expected to engineer their systems according to well-defined engineering processes in compliance with safety and security standards. Certification is an extremely expensive and time-consuming process. Since safety and security standards exhibit a certain degree of commonality certification-related artifacts (e.g. process models) should to some extent be reusable. To enable systematic reuse and customization of process information in this paper we further develop security-informed safety-oriented process line engineering (i.e. engineering of sets of processes including security and safety concerns). More specifically first we consider three tool-supported approaches for process-related commonality and variability management and we apply them to limited but meaningful portions of safety and security standards within airworthiness. Then we discuss our findings. Finally we draw our conclusions and sketch future work.;
Proceedings of the Third International Workshop on Product LinE Approaches in Software Engineering;Software Product Line (SPL) has been successfully consolidated as an approach for systematic reuse. The adoption of the SPL approach aims at increasing the reuse of requirements and artifacts thus reusing documents source code and artifacts and ensuring better quality control to software production in a large-scale. One of the essential activities for SPL management is the modeling of variability. Variability modeling in UML-based SPL has been carried out mostly using the UML Profiling mechanism in which new stereotypes and tagged values are created for such purpose. The available option in general-purpose UML tools for exporting UML models is through XMI files standardized by OMG. This option is important to process XMI files in particular environments or tools for example managing variabilities generating product configurations from an SPL and even collecting metrics and estimating SPLs. However different versions tool restrictions and different file standards compromise operations involving XMI files. In this scenario the industry has increasingly required the supporting tools for the SPL approach. However the current support tools are mainly restricted to the problem space based on feature modeling and present problems with data integration with other tools. Therefore we developed SMartyModeling an environment for engineering UML-based SPLs in which variabilities are modeled as stereotypes using any UML compliant profile. This paper presents an overview of SMartyModeling describing its motivation main components and available features.;
Proceedings of the 2011 Conference of the Center for Advanced Studies on Collaborative Research;Building software is a crucial task to compile test and deploy software systems while continuously ensuring quality. As software is more and more configurable building multiple configurations is a pressing need yet costly and challenging to instrument. The common practice is to independently build (a.k.a. clean build) a software for a subset of configurations. While incremental build has been considered for software evolution and relatively small modifications of the source code it has surprisingly not been considered for software configurations. In this vision paper we formulate the hypothesis that incremental build can reduce the cost of exploring the configuration space of software systems. We detail how we apply incremental build for two real-world application scenarios and conduct a preliminary evaluation on two case studies namely x264 and Linux Kernel. For x264 we found that one can incrementally build configurations in an order such that overall build time is reduced. Nevertheless we could not find any optimal order with the Linux Kernel due to a high distance between random configurations. Therefore we show it is possible to control the process of generating configurations: we could reuse commonality and gain up to 66% of build time compared to only clean builds.;
Proceedings of the ACM/IEEE 44th International Conference on Software Engineering: New Ideas and Emerging Results;In today's systems we often plug together configurable standard components in a modular way. Most software however does not specify its configuration in a way suitable for other software. The aim of our configuration specification language SpecElektra is to fill this gap. It allows us to externally specify the configuration items of non-standardized configuration files. In SpecElektra we assign properties that enable additional validations and transformations. As a result we can safely and easily configure software at run-time. The approach integrates standard software while retaining its modularity. We demonstrate how high-level configuration items help us to cope with changes in system-oriented goals.;
Proceedings of the 2013 Conference of the Center for Advanced Studies on Collaborative Research;Feature-oriented software development still register few cases of adoption in industry. At least to some extent such lower adotion might derive from the lack of evidence of its gains in the overall software project costs. This Ph.D thesis aims to improve the state-of-the-art by adding evidence to the body of knowledge on the adoption of Software Product Line (SPL) hybrid composition approahces.;
Proceedings of the 2014 Conference on Interactive Entertainment;Decision Support Frameworks information systems that guide business and organization choices are often used to help planners and designers make complex choices. These frameworks provide a means of aggregating the data needed to successfully reach a decision while providing a means of logically analyzing the compiled information. The framework can also provide additional information to help acclimate a planner or designer to special considerations of a domain if they are unfamiliar with the area.Dynamic Software Product Lines product lines which can self-adapt their architecture at run-time are complex systems usually constructed to cope with high levels of run-time uncertainty. During construction selecting an appropriate design from among the set of possible designs for a Dynamic Software Product Line is a non-trivial task and no existing Decision Support Framework provides guidance for this process. In this paper we present a framework Structured Intuitive Model for Dynamic Adaptive System Economics for comparing and selecting between designs for a Dynamic Software Product Line.;
Proceedings of the 21st International Systems and Software Product Line Conference - Volume B;Cloning-and-owning in the long run can severely affect evolution as changes in cloned fragments may require modifications in various parts of the system. This problem scales if cloning is used in classes that derive products in a Software Product Line because these classes can impact in several features and products. However it is hard to know to which extent cloning in customization classes can impact in a project. We conduct a study within an SPL that generates mobile software for over 150 countries to analyze cloning practices and how cloned parts relate to the maintainability of customization classes. We collect and identify clones inside customization classes during a period of 13 months involving 70 customization classes and 5 branches. In parallel we collect the respective issues from the issue tracking tool of the SPL project obtaining over 140 issues related to customization classes. We then confront the time spent to solve each issue with its nature (i.e. if it relates to cloned code or not). As first result we verify that issues related to cloning take in average 136% more time to be solved. Our study helps to understand how cloning relates to maintainability in the context of mass customization giving insights about cloned code evolution and its impacts in a software product line project.;
Proceedings of the 12th International Conference on Global Software Engineering;Software systems often serve as the agents of operation for both enterprise systems and embedded systems. Engineering such systems is a knowledge-centric activity. A clear understanding of the relationship between knowledge systems and engineering can help us to establish firm theoretical foundations for software and systems engineering.Currently we have a strong intuitive understanding of how knowledge flows into engineering while our understanding of the relationship between systems and knowledge is part explicit and part tacit. A symptom of this is that we have difficulty in building unified models of large systems such as telescopes and enterprises that span multiple knowledge domains and viewpoints. We are able to build multiple models covering various aspects and particular viewpoints. However we have challenges in integrating them into a single unified model. Another symptom is that software and systems engineering practice are widely viewed as empirical fields without sufficiently strong theoretical foundations.This work attempts to explicate and synthesize our common intuitive understanding in this space to develop a conceptual model of the relationships. It then explores the validity of this model by examining the extent to which it is able to explain and illuminate current engineering practices and issues. This is an initial strawman version of the model presented with a view to obtaining feedback and inputs from the community.;
Proceedings of the 16th Brazilian Symposium on Software Components Architectures and Reuse;Configuring a new variant of a product line is not always a one-time task. In some cases many stakeholders are involved in the configuration process. This is needed for example if different stakeholders are responsible for different parts of the product line and they are not allowed to see specific parts of the product line already configured in previous steps. Thus a partial derivation can be performed where a part of the configuration process can be done by some stakeholders while finishing the rest of the configuration process can be achieved by others.Validating partial configurations is a challenging task since the selection state of some features can still be open. In addition to these open selection states of features values of attributes calculations of expressions as well as constraints are needed to be handled as they can use information which is not defined yet. Thus a validator that ables to address the aforementioned challenges is required. In this paper we discuss how the partial configurations can be validated considering different cases. While these discussed cases can be applied in general we focus in this paper on applying them with respect to the industrial variant management tool pure::variants.;
Proceedings of the on Eclipse Technology EXchange;Software Product Lines (SPLs) are commonly adopted with an extractive approach by performing a reengineering process in legacy systems when dealing with variability and reuse became challenging. As a starting activity of the process the legacy systems are analyzed to retrieve categorize and group their features in terms of commonality and variability. Due to the importance of this feature retrieving we proposed the Prepare Assemble and Execute framework for SPL reengineering (PAxSPL). PAxSPL aims at guiding users to customize the feature retrieval for their scenario. In an initial evaluation of the PAxSPL in a real-world scenario we could observe the need for including scoping activities and implementing a tool to make the framework more adoptable in practice. In this paper we describe how we performed these improvements. We performed the evolution of PAxSPL by including SPL scoping concepts and activities into our framework as well as developing a supporting tool. We also conducted a pilot study to evaluate how PAxSPL allows instantiating a scenario where the SPL reengineering were conducted. The results show that all artifacts activities and techniques from the scenario could be properly represented. However we also identified a potential limitation during the assembly of techniques regarding parallel activities. The main contribution is PAxSPL_v2 that makes the framework more adherent to industries performing the reengineering of legacy systems into SPLs.;
Proceedings of the Winter Simulation Conference;Cloud microservice applications comprise interconnected services packed into containers. Such applications generate complex communication patterns among their microservices. Studying such patterns can support assuring various quality attributes such as autoscaling for satisfying performance availability and scalability or targeted penetration testing for satisfying security and correctness. We study the structure of containerized microservice applications via providing the methodology and the results of a structural graph-based analysis of 103 Docker Compose deployment files from open-sourced Github repositories. Our findings indicate the dominance of a power-law distribution of microservice interconnections. Further analysis highlights the suitability of the Barab\'{a;
Proceedings of the 30th Annual International Conference on Computer Science and Software Engineering;Models are an important tool in conquering the increasing complexity of modern software systems. Key industries are strategically directing their development environments towards more extensive use of modeling techniques. MiSE 2015 aimed to understand through critical analysis the current and future uses of models in the engineering of software-intensive systems. The MiSE workshop series has proven to be an effective forum for discussing modeling techniques from both the MDE and software engineering perspectives. An important goal of this workshop is to foster exchange between these two communities. In 2015 the focus was on considering the current state of tool support and the challenges that need to be addressed to improve the maturity of tools. There was also analysis of successful applications of modeling techniques in specific application domains with attempts to determine how the participants' experiences can be carried over to other domains.;
Proceedings of the 19th Conference on Pattern Languages of Programs;Software Product Line (SPL) consists in an approach that enables software reuse by allowing the creation of software applications through the features composition to address a particular domain. Framework Product Line (FPL) is an extension of SPL whose features composition result in targeted frameworks which are used to address subdomains of applications. Model-Driven Engineering is a promising technique to deal with features in an efficient and producing manner. Nonetheless there is no tool yet that makes the modularization and composition process in the FPL context possible. Thus we have developed the FPLGenerator which supports two main perspectives: (i) Domain Engineers may build a feature model in requirements-level to target FPL and to modularize their legacy frameworks to FPLs and (ii) Application Engineers may select a subset of features from FPL generating the corresponding member ready to be instantiated. The main goal of this tool is to allow the conversion of inflexible frameworks to FPLs through the use of driven feature refactoring. In this paper we revisit the FPL concept and the main characteristics of FPLGenerator are discussed. As an illustrative example an FPL called GRENJ-FPL is used to show the FPLGenerator usage. When it comes to composability and productivity the preliminary results were found to be relevant to the FPL context.;
Proceedings of the 2nd International Workshop on Variability and Complexity in Software Design;"Software developers often need to transfer functionality e.g. a set of commits implementing a new feature or a bug fix from one branch of a configuration management system to another. That can be a challenging task as the existing configuration management tools lack support for matching high-level semantic functionality with low-level version histories. The developer thus has to either manually identify the exact set of semantically-related commits implementing the functionality of interest or sequentially port a specific subset of the change history inheriting"" additional unwanted functionality.In this paper we tackle this problem by providing automated support for identifying the set of semantically-related commits implementing a particular functionality which is defined by a set of tests. We refer to our approach CSLICER as semantic slicing of version histories. We formally define the semantic slicing problem provide an algorithm for identifying a set of commits that constitute a slice and instantiate it in a specific implementation for Java projects managed in Git. We evaluate the correctness and effectiveness of our approach on a set of open-source software repositories. We show that it allows to identify subsets of change histories that maintain the functionality of interest but are substantially smaller than the original ones.""";
Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering;Today's organizations are increasingly pushed to be distributed by space time and capabilities and are involved to leverage synergies by integrating their business processes in order to produce new value-added products and services. Here the importance of integrating whole processes rather than simply integrate databases or software applications. Seeing the duality between products and processes we propose to exploit flexibility provided by the product-line engineering approach for modeling business processes as a Business Process Line (BPL) in order to capture process variability promote reuse and integration and provide the capacity to anticipate process changes. To support process evolution and consistency we suggest the use of decision tables to elicit track and manage all the emerging decision points during business process modeling with the purpose of maintaining the relationships among business needs environmental changes and process tasks. In a real case study we practiced the proposed methodology by leveraging the synergy of feature models variability mechanisms and decision tables. The results prove that the BPL satisfies the requirements for business process flexibility.;
Proceedings of the 21st International Symposium on Distributed Simulation and Real Time Applications;"Several software projects start from an existing project. This practice in the VCS ecosystem is called fork. For instance the Bootstrap project initially developed on Twitter today has more than 68000 forks which indicates that several projects started from the Bootstrap source code at a certain moment and are being customized. The problem occurs when customized projects want to obtain updates from the original project i.e. new features bug fixes etc. The merge of the source code between the original and the customized projects usually generates conflicts that need human resolution. More important the resolution of those conflicts might not be trivial and poses an arduous task for developers. This article therefore proposes an approach for updating forks against the original project where features are modularized documented traceable and can be reused. We claim that the such task can no longer be carried out on an ad hoc basis. In a nutshell instead of modify the method foo from the original project the developer implements it locally and specifies using one of the nine instructions of the proposed DSL something like replace the foo method with local implementation"". We have developed a tool that automates our approach and conducted an evaluation on a large-scale real-world project that is regularly updated against your original project.""";
Proceedings of the Summer Simulation Multi-Conference;There are often concerns about the reliability of simulation results due to improper design of experiments limited support in the execution and analysis of experiments and lack of integrated computational frameworks for model learning through simulation experiments. Such issues result in flawed analysis as well as misdirected human and computational effort. We put forward a methodological basis which aims to (1) explore the utility of viewing models as adaptive agents that mediate among domain theories data requirements principles and analogies (2) underline the role of cognitive assistance for model discovery experimentation and evidence evaluation so as to differentiate between competing models and to attain a balance between model exploration and exploitation and (3) examine strategies for explanatory justification of model assumptions via cognitive models that explicate coherence judgments.;
Proceedings of the 2017 Winter Simulation Conference;The behavior of systems of systems (SoS) emerges only fully during operation and is hard to predict. SoS thus need to be monitored at runtime to detect deviations from important requirements. However existing approaches for checking runtime behavior and performance characteristics are limited with respect to the kinds of checks and the types of technologies supported which impedes their use in industrial SoS. In this tool demonstration paper we describe the ReMinds tool suite for runtime monitoring of SoS developed in response to industrial monitoring scenarios. ReMinds provides comprehensive tool support for instrumenting systems extracting events and data at runtime defining constraints to check expected behavior and properties and visualizing constraint violations to facilitate diagnosis.;
Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;Feature models (FMs) are the de facto standard for modeling variability of software product lines. The research effort is still intensive and aims at increasing the adoption of FMs in practice. Integrated solutions that combine state-of-the-art techniques languages and tools are emerging. We give an overview of complementary languages TVL and FAMILIAR and tools for the purpose of supporting the management (e.g. configuration) of FMs. We report on practical applications of the languages and tools in different domains and for different purposes. Still we are interested in applying our solutions to other contexts (e.g. industrial) in order to determine their applicability and possible adoption by practitioners.;
Proceedings of the 18th International Conference on Model Driven Engineering Languages and Systems;Software is often released in multiple variants to meet all customer requirements. While software product lines address this need by advocating the development of an integrated software platform practitioners frequently rely on ad-hoc reuse based on a principle which is known as clone-and-own. This practice avoids high up-front investments as new variants of a software family are created by simply copying and adapting an existing variant but maintenance costs explode once a critical number of variants is reached. With our research project VariantSync we aim to bridge the gap between clone-and-own and product lines by combining the minimal overhead and flexibility of clone-and-own with the systematic handling of variability in software product lines. The key idea is to transparently integrate product-line concepts with variant management facilities known from version control systems in order to automatically synchronize a set of evolving variants. We believe that VariantSync has the potential to change the way how practitioners develop multi-variant software systems for which it is hard to foresee which variants will be added in the future.;
Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;Model-driven software product lines evolve in both time and space. Consistency control for model versions constitutes a key challenge. We propose a novel approach to consistency control called well-formedness analysis and repair: Instead of attempting to guarantee consistency of each configurable version a priori (which is hard and restrictive) consistency is controlled only when a product version is actually configured. Conflicts i.e. violation of well-formedness constraints are detected and repaired driven by configurable strategies. This approach is generic it is instantiated for feature models (for the variability model) and EMF models (as domain artifacts).;
Proceedings of the 22nd International Conference on Model Driven Engineering Languages and Systems;Software Product Line SPL is a software development strategy in which products are developed from a common set of core assets in a prescribed way with product specific features to satisfy specific market segment [1]. The SPL development process is carried out in two phases: the first phase is about building core assets called domain engineering which has gained a lot of researchers' attention. The second step is about instantiating the specifics of the products by adding to the common part the specific features that identify the product from the other application engineering. For large and complex domains it is argued that organizing and retrieving the development of artifacts from the core asset required by the application under development is a way of shortening the application development time thus reduces the time to market. In this paper we propose an automation mechanism for organizing the core assets using feature based organization to divide the customized domain feature model based on the application features and their dependencies. When that retrieval step where the artifacts are represented by relations that inherit the dependencies between the features in each division of the feature model takes place the final result is a set of development artifacts with their traceability links to be customized based on the application variability model and integrated with the application specific artifacts. To demonstrate our work we applied this mechanism on a watch a case study in the digital watch domain.;
Proceedings of the 2nd International Conference on Interaction Sciences: Information Technology Culture and Human;Cloning is a general approach to create new functionality within variants as well as new system variants. It is a fast flexible intuitive and economical approach to evolve systems in the short run. However in the long run the maintenance effort increases. A common solution to this problem is the extraction of a product line from a set of cloned variants. This process requires a detailed analysis of variants to extract variability information. However clones within a variant are usually not considered in the process but are also a cause for unsustainable software. This thesis proposes an extractive multi product-line engineering approach to re-establish the sustainable development of software variants. We propose an approach to re-engineer intra-system and inter-system clones into reusable configurable components stored in an integrated platform and synthesize a matching multilayer feature model.;
Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;When designing changes to a software product line (SPL) developers are faced with uncertainty about deciding among multiple possible SPL designs. Since each SPL design encodes a set of related products dealing with multiple designs means that developers must reason about sets of sets of products. The additional degree of multiplicity is not well described by existing product line abstractions. In this paper we propose an approach for dealing with design uncertainty within SPLs using a novel composition of variability modelling with an abstraction for capturing and managing design uncertainty. This allows developers to accurately describe the decisions involved in making changes to an SPL during the design stage and provides them with a framework for SPL design space exploration by analyzing and enforcing SPL properties.;
Proceedings of the ACM/IEEE 20th International Conference on Model Driven Engineering Languages and Systems;Software-intensive systems in the automotive domain are often built in different variants notably in order to support different market segments and legislation regions. Model-based concepts are frequently applied to manage complexity in such variable systems. However the considered approaches are often focused on single-product development. In order to support variable products in a model-based systems engineering environment we describe a tool-supported approach that allows us to annotate SysML models with variability data. Such variability information is exchanged between the system modeling tool and variability management tools through the Variability Exchange Language. The contribution of the paper includes the introduction of the model-based product line engineering tool chain and its application on a practical case study at Volvo Construction Equipment. Initial results suggest an improved efficiency in developing such a variable system.;
Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;Exploratory modeling and simulation is an effective strategy when there are substantial contextual uncertainty and representational ambiguity in problem formulation. However two significant challenges impede the use of an ensemble of models in exploratory simulation. The first challenge involves streamlining the maintenance and synthesis of multiple models from plausible features that are identified from and subject to the constraints of the research hypothesis. The second challenge is making sense of the data generated by multi-simulation over a model ensemble. To address both challenges we introduce a computational framework that integrates feature-driven variability management with an anticipatory learning classifier system to generate explanatory rules from multi-simulation data.;
