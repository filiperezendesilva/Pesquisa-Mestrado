Título;Resumo;Selecionado
Threat modeling using formal methods: A new approach to develop secure web applications;Software security problems exist since the early days of computer systems. Operating system level approaches, network level approaches and machine level approaches are not sufficient for the security of software systems. Software security has gained attention in the recent years as an internal security issue of software systems as compared to external protective measures. Threat modeling is a technique being used to model threats into software systems. By applying threat modeling at the early stages of software development life cycle, all possible threats to software systems can be identified and mitigated and hence in this way, a more secure software application can be developed. Various threat modeling approaches such as CLASP, SDL, STRIDE, DREAD, TAM and Touch Points are being used by many organizations for threat modeling into software systems. But all of the approaches being used for threat modeling are based on informal and semi formal techniques. Formal methods are based on mathematics and provide state of the art techniques for secure software development. Formal methods had been used successfully in many critical systems such as CICS, Paris Railway System and British Air Traffic Control System etc. In the proposed approach VDM++, will be used for specification of core components: STRIDE, DREAD and Security Mechanisms. VDM++Tools will be used for type checking and proof obligations;1
Security Requirements Elicitation and Assessment Mechanism (SecREAM);Today, when most of the software are web-based or cloud-based having a variety of stakeholders with intertwined requirements, developing secure software is a complex issue. Usually, security is neglected during the development process. Now, the researchers emphasize on inclusion of security in development process, especially during the early phases. This paper suggests Security Requirements Elicitation and Assessment Mechanism (SecREAM), a novel methodology to imbibe security right from the inception of the software. It is applicable to both kinds of software- on premise and on cloud. The crux of the methodology lies in actively involving all kinds of stakeholders and ranking of the required assets on the basis of certain parameters that will facilitate a well - understood design and help in making better technical and non-technical decisions later during the course of development.;1
Security-aware Software Development Life Cycle (SaSDLC) - Processes and tools;"Today an application is secured using invitro perimeter security. This is the reason for security being considered as nonfunctional requirement in Software Development Life Cycle (SDLC). In Next Generation Internet (NGI), where all applications will be networked, security needs to be in-vivo; security must be functions within the application. Applications running on any device, be it on a mobile or on a fixed platform - need to be security-aware using Securityaware Software Development Life Cycle (SaSDLC), which is the focus of this paper. We also present a tool called Suraksha that comprises of Security Designers' Workbench and Security Testers' Workbench that helps a developer to build Security-aware applications.";1
Exhaustive study of SDLC phases and their best praxctices to create CDP model for process improvement;This paper reveals the study of sub methods of the phases of SDLC i.e. Software Development Life Cycle. Some methods or sub-practices are always required to execute each and every phase. There is always a need of some procedures, steps, methods and processes to build anything whether it is software or anything. Even a recipe needs a proper steps otherwise it will give a bad taste. An appropriate approach or accurate steps are to be followed always to construct a quality product. Various models, standards and processes have been introduced by ISO, CMMi etc to follow a proper approach to reach the destination. There was a need to find a method which would be suitable for company/organization. As companies have to manage each and everything with the existing resources by keeping in mind the quality and goal of customer. This paper represents the exhaustive study of the sub-methods or sub-practices of SDLC phases as per the process areas of CMMi and a model which shows the best suited combinations of various methods to achieve the desired product as per the requirements and existing resources. This is was the part of process improvement of a software organization “Saber Corp(Made-Up)”. This whole paper represents the CDP model which was the output of process improvement process of company Saber Corp.;1
Gauging the Impact of FISMA on Software Security;A newly developed instrument provides sophisticated content analysis to help determine the relevance for software security of the National Institute of Standards and Technology's FISMA-mandated security controls.;1
Data-driven software security: Models and methods;"For computer software, our security models, policies, mechanisms, and means of assurance were primarily conceived and developed before the end of the 1970's. However, since that time, software has changed radically: it is thousands of times larger, comprises countless libraries, layers, and services, and is used for more purposes, in far more complex ways. It is worthwhile to revisit our core computer security concepts. For example, it is unclear whether the Principle of Least Privilege can help dictate security policy, when software is too complex for either its developers or its users to explain its intended behavior.
This paper outlines a data-driven model for software security that takes an empirical, data-driven approach to modern software, and determines its exact, concrete behavior via comprehensive, online monitoring. Specifically, this paper briefly describes methods for efficient, detailed software monitoring, as well as methods for learning detailed software statistics while providing differential privacy for its users, and, finally, how machine learning methods can help discover users' expectations for intended software behavior, and thereby help set security policy. Those methods can be adopted in practice, even at very large scales, and demonstrate that data-driven software security models can provide real-world benefits.";1
Automated security hardening for evolving UML models;Developing security-critical software correctly and securely is difficult. To address this problem, there has been a significant amount of work over the last 10 years on providing model-based development approaches based on the Unified Modeling Language which aim to raise the trustworthiness of security-critical systems, some of them including tools allowing the user to check whether a UML model satisfies the relevant security requirements. However, when the requirements are not satisfied by a given model, it can be challenging for the user to determine which changes to do to the model so that it will indeed satisfy the security requirements. Also, the fact that software continues to evolve on an ongoing basis, even after the implementation has been shipped to the customer, increases the challenge since in principle, the software has to be re-verified after each modification, requiring significant efforts. We present work on automated tool-support that exploits recent work on secure software evolution in the Secure Change project in order to support the security hardening of evolving UML models (within the context of the UML security extension UMLsec).;1
Towards a Comprehensive View of Secure Software Engineering;Secure software engineering is a big challenge. This is mainly due to the increasing complexity, openness and extensibility of modern applications, which make a complete analysis of security requirements very hard. The overall problem space is consequently no longer easily comprehensible for developers. This paper is an attempt to explore some of these issues underlying secure software engineering. We propose a secure software engineering framework, which suggests considering secure software engineering along four different, but complementary, views. Each view is capturing a particular relevant aspect of secure software engineering. Our motivations for developing this framework are to: (a) help understand and clarify the secure software engineering domain, (b) guide in classifying and comparing both secure software and securing approaches and (c) help researchers to identify new research axes.;1
Improving Penetration Testing Methodologies for Security-Based Risk Assessment;The crisis of insecure software has resulted in a drastic increase in the frequency and impact of cyber attacks on businesses and individual users alike. The discipline of secure software engineering has evolved as a response to this trend, with the aim of producing software with fewer coding bugs or design flaws that result in exploitable vulnerabilities. However, secure software engineering is a young discipline, and many software artifacts in current use were created before, or in ignorance of, its development. Software practitioners would benefit greatly from a rigorous methodology for analyzing and validating software that has already entered its maintenance lifecycle. In this paper, we present a combined penetrating testing methodology that incorporates strengths of several existing approaches, with the goal to understand their utility and benefit for analyzing security of existing software programs. We exercise this methodology through a case study applied to a popular tool used by many network security practitioners: Wireshark. As a contribution, our study illustrates the benefits of a combined approach and outlines recommendations for a holistic method that will improve security-based risk assessment. Specifically, we show how application of rigorous test-driven threat modeling can produce better abuse cases, which can in turn be used to inform and more precisely define penetration testing activities.;1
Research on XML Based Static Software Security Analysis;Fatal security vulnerabilities are caused by undefined behaviors of C/C++ language used in Safety-Critical software design. Software static analysis is an important technique for identifying security vulnerabilities from software code and structure. The method of static analysis based on XML intermediate model is proposed in term of safety rules. The source code is interpreted as XML intermediate model, while safety rules are translated into vulnerabilities pattern, and Xquery expression is used to locate security vulnerabilities by this method. The experimental result of a prototype system based on this method shows that this method can effectively detect the software vulnerabilities in violation of safety rules and has the advantage of supporting customization of safety rules.;1
Automated software architecture security risk analysis using formalized signatures;Reviewing software system architecture to pinpoint potential security flaws before proceeding with system development is a critical milestone in secure software development lifecycles. This includes identifying possible attacks or threat scenarios that target the system and may result in breaching of system security. Additionally we may also assess the strength of the system and its security architecture using well-known security metrics such as system attack surface, Compartmentalization, least-privilege, etc. However, existing efforts are limited to specific, predefined security properties or scenarios that are checked either manually or using limited toolsets. We introduce a new approach to support architecture security analysis using security scenarios and metrics. Our approach is based on formalizing attack scenarios and security metrics signature specification using the Object Constraint Language (OCL). Using formal signatures we analyse a target system to locate signature matches (for attack scenarios), or to take measurements (for security metrics). New scenarios and metrics can be incorporated and calculated provided that a formal signature can be specified. Our approach supports defining security metrics and scenarios at architecture, design, and code levels. We have developed a prototype software system architecture security analysis tool. To the best of our knowledge this is the first extensible architecture security risk analysis tool that supports both metric-based and scenario-based architecture security analysis. We have validated our approach by using it to capture and evaluate signatures from the NIST security principals and attack scenarios defined in the CAPEC database.;1
Measuring the Software Security Requirements Engineering Process;Although there has been much research work in security requirements engineering, we do not have adequate ways of measuring this and other security engineering processes. In this paper, we study a measurement approach to security requirements engineering, align it with the Security Quality Requirements Engineering (SQUARE) method, and use both the original and revised security requirements measurement approach to analyze projects that were developed with and without SQUARE.;1
Threat-driven modeling and verification of secure software using aspect-oriented Petri nets;Design-level vulnerabilities are a major source of security risks in software. To improve trustworthiness of software design, this paper presents a formal threat-driven approach, which explores explicit behaviors of security threats as the mediator between security goals and applications of security features. Security threats are potential attacks, i.e., misuses and anomalies that violate the security goals of systems' intended functions. Security threats suggest what, where, and how security features for threat mitigation should be applied. To specify the intended functions, security threats, and threat mitigations of a security design as a whole, we exploit aspect-oriented Petri nets as a unified formalism. Intended functions and security threats are modeled by Petri nets, whereas threat mitigations are modeled by Petri net-based aspects due to the incremental and crosscutting nature of security features. The unified formalism facilitates verifying correctness of security threats against intended functions and verifying absence of security threats from integrated functions and threat mitigations. As a result, our approach can make software design provably secured from anticipated security threats and, thus, reduce significant design-level vulnerabilities. We demonstrate our approach through a systematic case study on the threat-driven modeling and verification of a real-world shopping cart application.;1
The impact of test case reduction and prioritization on software testing effectiveness;Software testing is critical but most expensive phase of Software Development Life Cycle (SDLC). Development organizations desire to thoroughly test the software. But this exhaustive testing is impractical due to resource constraints. A large number of test suites are generated using automated tools. But the real challenge is the selection of subset of test cases and/or high order test cases crucial to validate the System Under Test (SUT). Test case reduction and prioritization techniques help test manager to solve this problem at a little cost. In this paper, we investigate their impact on testing process effectiveness using previous empirical studies. The results indicate that these techniques improve the testing effectiveness significantly. At the end, a case study is presented that suggests different useful combinations of these techniques, which are helpful for different testing scenarios.;1
A portal for software security;One of the real challenges facing the emerging field of software security is the lack of an easily accessible common body of knowledge. We describe a software security portal that the USA Department of Homeland Security (DHS) National Cyber Security Division (NCSD) is developing (along with the Carnegie Mellon Software Engineering Institute (SEI) and Cigital). The launch of this portal is scheduled for October 2005 as part of the US-CERT Web site. The portal aims to provide a common, accessible, well-organized set of information for practitioners wishing to do software security.;1
Risk Analysis in Software Design;Risk analysis is, at best, a good general-purpose yardstick by which we can judge our security design's effectiveness. Because roughly 50 percent of security problems are the result of design flaws, performing a risk analysis at the design level is an important part of a solid software security program. Taking the trouble to apply risk-analysis methods at the design level for any application often yields valuable, business-relevant results. The risk analysis process is continuous and applies to many different levels, at once identifying system-level vulnerabilities, assigning probability arid impact, arid determining reasonable mitigation strategies. The paper looks at how, by considering the resulting ranked risks, business stakeholders can determine how to manage particular risks and what the most cost-effective controls might be.;1
A method of software watermarking;Code obfuscation and software watermarking are the important methods of software security. Code obfuscation increases the difficulty of reverse engineering while software watermarking can provide the copyright information for the software products. In this paper, a scheme of zero-watermarking is proposed which can embed the watermarking information into programs without additional codes. The watermarking information is hidden in the program when the process of code obfuscation is executed. It means that the watermarking information is embedded into the program by the way of code obfuscation. The Combination between software watermarking and code obfuscation would make the reverse engineering more difficult and the software products more secure.;1
Activity and Artifact Views of a Secure Software Development Process;The number of security errors and vulnerabilities can be reduced if a secure software development process (SSDP) is followed. Such a SSDP must cater for security aspects during each phase of development. In this paper, we present a new process that provides ways of addressing security concerns and incorporating security decisions throughout the software development process. Our process has two views: activity and artifact. The activity view presents development activities performed during requirements engineering, design, implementation, and assurance phases. The artifact view, on the other hand, identifies the relationships among the various SSDP artifacts that are produced during development.;1
The merging trend of software security and safety;With rapid development of information technology and software engineering, the software systems have been widely applied in national politics, economics and military. Thus, more and more software systems are both safety- and security-critical, and the safety and security problems of software systems are more and more related to the economic development and national defense. Many researchers are studying on either safety or security field. With the development and more achievements, we have a chance to successfully combine and integrate the software safety with security. The safety and security communities should combine and integrate efforts to design and build the theoretical framework and mechanisms. Based on analyzing the characteristics of software systems, and explaining the differences and relations of safety and security, we proposed some united concepts and universal risk framework of software safety and security.;1
Secure Software Design in Practice;"This paper presents a set of practical techniques and tools for creating secure software with a special focus on the design phase of the development lifecycle. The target group is the ordinary ""developer-on-the- street"", who is not primarily interested in (or knowledgeable about) security, but must focus on designing/implementing as much functionality as possible before the deadline and on budget.";1
A Knowledge Management Approach to Support a Secure Software Development;Organizations that want to increase their profits from reliable and secure software product need to invest in software security approaches. However, secure software is not easily achieved and the actual scenario is that investments in software development process improvement do not assure software that resist from attacks or do not present security vulnerabilities. The PSSS (Process to Support Software Security) may help obtaining secure software as it proposes security activities to be integrated into software development life cycles. This paper resumes the application of the PSSS and proposes the support of a knowledge management environment based, specially, on security inspections of the artifacts generated during the processes execution. It also proposes a checklist to security inspections on the software requirements. This will improve how the security aspects are being considered during the development of secure software and will help to establish the security as an important discipline on the organizational culture.;1
Maintaining software with a security perspective;Testing for software security is a lengthy, complex and costly process. Currently, security testing is done using penetration analysis and formal verification of security kernels. These methods are not complete and are difficult to use. Hence it is essential to focus testing effort in areas that have a greater number of security vulnerabilities to develop secure software as well as meet budget and time constraints. We propose a testing strategy based on a classification of vulnerabilities to develop secure and stable systems. This taxonomy will enable a system testing and maintenance group to understand the distribution of security vulnerabilities and prioritize their testing effort according to the impact the vulnerabilities have on the system. This is based on Landwehr's (1994) classification scheme for security flaws and we evaluated it using a database of 1360 operating system vulnerabilities. This analysis indicates vulnerabilities tend to be focused in relatively few areas and associated with a small number of software engineering issues.;1
On the Secure Software Development Process: CLASP and SDL Compared;Development processes for software construction are common knowledge and mainstream practice in most development organizations. Unfortunately, these processes offer little support in order to meet security requirements. Over the years, research efforts have been invested in specific methodologies and techniques for secure software engineering, yet complete, dedicated processes have been proposed only recently. In this paper, two high-profile processes for the development of secure software, namely OWASP's CLASP and Microsoft's SDL, are evaluated and compared in detail. The paper identifies the commonalities, discusses the specificity of each approach, and proposes suggestions for improvement.;1
Literature Review of the Challenges of Developing Secure Software Using the Agile Approach;A set of challenges of developing secure software using the agile development approach and methods are reported in the literature. This paper reports about a systematic literature review to identify these challenges and evaluates the causes of each of these challenges, with respect to the agile values, the agile principles, and the security assurance practices. We identified in this study 20 challenges, which are reported in 10 publications. We found that 14 of these challenges are valid and 6 are neither caused by the agile values and principles, nor by the security assurance practices. We also found that 2 of the the valid challenges are related to the software development life-cycle, 4are related to incremental development, 4 are related to security assurance, 2 are related to awareness and collaboration, and 2 are related to security management. These results justify the need for research to make developing secure software smooth.;1
Extending the Agile Development Process to Develop Acceptably Secure Software;The agile software development approach makes developing secure software challenging. Existing approaches for extending the agile development process, which enables incremental and iterative software development, fall short of providing a method for efficiently ensuring the security of the software increments produced at the end of each iteration. This article (a) proposes a method for security reassurance of software increments and demonstrates it through a simple case study, (b) integrates security engineering activities into the agile software development process and uses the security reassurance method to ensure producing acceptably secure-by the business owner-software increments at the end of each iteration, and (c) discusses the compliance of the proposed method with the agile values and its ability to produce secure software increments.;1
Secure by design approach to improve security of object oriented software;In order to minimize vulnerabilities and achieve target level security, quantification of security is necessary. Unfortunately, quantitative estimation of security in earlier stage of software development life cycle (SDLC) is largely missing. The design phase of software development provides the foundation for secure software. Reducing vulnerability at this phase minimizes rework in subsequent development phases. In this work author combined existing research findings and tried to evaluate the guideline to designer. These guidelines help to check the security of design so if multiple designs were available then designer can easily choose the secure design or if the designer finds that security of current design is low then can do necessary modification to deliver a secure design, which ultimately improve overall security of software.;1
Risk management assessment using SERIM method;Software development is a complex process that involved many activities and has a big uncertainty to success. It is also a typical of activity that can be costly if mismanaged. Many factors can lead the success and also can cause software project failure. The failure actually can be detected early if we can adopt the concept of risk management and implemented it into software development project.;1
Integrating risk assessment and threat modeling within SDLC process;Risk assessment and threat modeling are conducted for different purpose. The integration of risk assessment and threat modeling process limit the risk of software-based system. Incorporating security in all phases of software development life cycle is a tedious task in many organizations. In design phase of SDLC, the 50 % software defects are identified and detected. Most of the security attacks are happen in application layer. This paper explains the combined use of risk assessment and threat model to understand the security risk of an application. We also discuss how the model may be identifying threats and how to frame threat prioritization for threat category. Finally, we recommend understanding of risk of detection and creating a fair environment to reduce the likelihood of committing criminal acts by attackers.;1
Security in Coding Phase of SDLC;Deployed software is continuously under attack. Hackers have been exploiting vulnerabilities for decades and seem to be increasing their attacks. Firewalls, intrusion detection and antivirus systems simply cannot solve this problem. Only a concerted effort by the software development community to produce more robust and reliable applications can foil attackers and allow users and stakeholders to feel confident that they are protected from exploitation. It is crucial that each phase of the software development process includes the appropriate security analysis, defenses and countermeasures that results in more secure released code. From requirements through design and implementation to testing and deployment, security must be integrated throughout the software development lifecycle (SDLC) in order to provide the user community with the best, most secure software. This paper describes that what actions may be taken for integrating security in coding phase.;1
On Selecting Appropriate Development Processes and Requirements Engineering Methods for Secure Software;To avoid security vulnerabilities, there are many secure software development efforts in the directions of secure software development life cycle processes, security specification languages, and security requirements engineering processes. In this paper, we compare and contrast various secure software development processes based on a number of characteristics that such processes should have. We also analyze security specification languages with respect to desirable properties of such languages. Furthermore, we identify activities that should be performed in a security requirements engineering process to derive comprehensive security requirements. We compare different security requirements engineering processes based on these activities. Our analysis shows that many of the secure software requirements engineering methods lack some of the desired properties. The comparative study presented in this paper will provide guidelines to software developers for selecting specific methods that will fulfill their needs in building secure software applications.;1
Security on Software Life Cycle using Intrusion Detection System;In software development process, many engineering disciplines rely on engineering failure data to improve their designs. We expect that security analysts can use this approach to document and identify commonly occurring attack patterns and that information system designer and analysts can use these patterns to develop more survivable information systems. A formal approach to security in the software life cycle is essential to protect corporate resources. Software security has been treated as an afterthought leading to a cycle of software development. Due to its criticality, security should be integrated as a formal approach in the software life cycle. It includes the critical areas of requirements analysis and specification, design and code issues, and maintenance and decommissioning of software and systems. We propose attack detection method based on clustering technique that provide network intrusion detection systems to identify attacks with a high detection rate and a low false alarm rate in analysis and design phase of software development life cycle. We critically focus on the analysis of security and classification of attack pattern for the software life cycle.;1
Design of a Tool for Checking Integration Testing Coverage of Object-Oriented Software;Software testing is a necessary process in software development life cycle to verify if the developed software follows its specification. One important thing of the testing process is test coverage analysis because defects may exist in uncovered parts and emerge when users try to use them. Test coverage analysis is performed to measure the comprehensiveness or thoroughness of testing. It is necessary and can be applied at every level of testing process. Nowadays, the object-oriented software is gaining interest in software industry which the test method differs from the conventional software, so some of available techniques and tools cannot be applied to object- oriented software. This paper proposes design of a tool for checking integration testing coverage of object- oriented software which can check the integration testing coverage of object oriented software and generate additional test cases in case of the existing test cases cannot cover the code.;1
Using Security Patterns to Combine Security Metrics;Measuring security is an important step in creating and deploying secure applications. In order to efficiently measure the level of security that an application provides, three problems need to be solved: obviously metrics need to be available, a suitable metrics framework needs to be chosen and implemented, and the resulting measurements need to be interpreted. This work focuses on the second and third problem. We propose an approach to facilitate the selection and integration of appropriate security metrics, and to support the aggregation and interpretation of measurements. Our approach associates security metrics to security patterns, and we exploit the relationships between security patterns and security objectives to enable the interpretation of measurements. The approach is illustrated in a case study.;1
Design of enhanced software protection architecture by using theory of inventive problem solving;This paper is dealing with the stochastic maintenance method for the software protection by using the closed queueing model with the unreliable backups. The method shows the theoretical software protection scheme in the security perspective. If software application modules are represented as backups under proposed architecture, the system can be solved by using the stochastic maintenance model with main unreliable and random auxiliary spare resources with replacement policies. In addition, the practical approach of technology enhancement in software engineering by using the technology innovation tool that is called TRIZ. The results are demonstrated in the framework of optimized software allocation problems with unreliable backups.;1
Evaluation of the Pattern-based method for Secure Development (PbSD): A controlled experiment;"Context: Security in general, and database protection from unauthorized access in particular, are crucial for organizations. Although it has been long accepted that the important system requirements should be considered from the early stages of the development process, non-functional requirements such as security tend to get neglected or dealt with only at later stages of the development process. Objective: We present an empirical study conducted to evaluate a Pattern-based method for Secure Development - PbSD - that aims to help developers, in particular database designers, to design database schemata that comply with the organizational security policies regarding authorization, from the early stages of development. The method provides a complete framework to guide, enforce and verify the correct implementation of security policies within a system design, and eventually generate a database schema from that design. Method: The PbSD method was evaluated in comparison with a popular existing method that directly specifies the security requirements in SQL and Oracle's VPD. The two methods were compared with respect to the quality of the created access control specifications, the time it takes to complete the specification, and the perceived quality of the methods. Results: We found that the quality of the access control specifications using the PbSD method for secure development were better with respect to privileges granted in the table, column and row granularity levels. Moreover, subjects who used the PbSD method completed the specification task in less time compared to subjects who used SQL. Finally, the subjects perceived the PbSD method clearer and more easy to use. Conclusion: The pattern-based method for secure development can enhance the quality of security specification of databases, and decrease the software development time and cost. The results of the experiment may also indicate that the use of patterns in general has similar benefits; yet this requires further examinations.";1
A framework to support alignment of secure software engineering with legal regulations;"Regulation compliance is getting more and more important for software systems that process and manage sensitive information. Therefore, identifying and analysing relevant legal regulations and aligning them with security requirements become necessary for the effective development of secure software systems. Nevertheless, Secure Software Engineering Modelling Languages (SSEML) use different concepts and terminology from those used in the legal domain for the description of legal regulations. This situation, together with the lack of appropriate background and knowledge of laws and regulations, introduces a challenge for software developers. In particular, it makes difficult to perform (i) the elicitation of appropriate security requirements from the relevant laws and regulations; and (ii) the correct tracing of the security requirements throughout the development stages. This paper presents a framework to support the consideration of laws and regulations during the development of secure software systems. In particular, the framework enables software developers (i) to correctly elicit security requirements from the appropriate laws and regulations; and (ii) to trace these requirements throughout the development stages in order to ensure that the design indeed supports the required laws and regulations. Our framework is based on existing work from the area of secure software engineering, and it complements this work with a novel and structured process and a well-defined method. A practical case study is employed to demonstrate the applicability of our work.";1
Software Development Initiatives to Identify and Mitigate Security Threats – A Systematic Mapping;The effective building of secure software systems has been ad-dressed by security experts and software development experts through several techniques for identi?ng and mitigating security threats. Many techniques hadbeen theoretically developed, however, for most of these proposals there is few empirical evidence of its application in building secure software systems. A systematic mapping has been conducted to cover the existent technologies foridenti?cation and mitigation of security threats. A total of 10 different techniques covering threats identi?cation and 8 covering the mitigation of threatswere found. All the initiatives were integrated to at least one activity of the Software Development Lifecycle (SDLC), while 7 show signs of being adoptedin the industry. The mapping found only 15 studies that covered 11 different iniatiatives. Only two techniques presented scienti?c evidence of its resultsthrough controlled experiments, while others selected studies presented infor-mal case studies or examples.;1
Survey and analysis on Security Requirements Engineering;"Security Requirements Engineering is a new research area in software engineering, with the realization that security must be analyzed early during the requirements phase. Many researchers are working in this area; however, there is a lack in security requirements treatment. The security requirements are one of the non-functional requirements, which act as constraints on functions of the system. Organizations are depending on information systems for communicating and sharing information. Thus, IT security is becoming central in fulfilling business goals, to guard assets and to create trustworthy systems. To develop systems with adequate security features, it is essential to capture the security requirements. In this paper, we present a view on Security Requirements, issues, types, Security Requirements Engineering (SRE) and methods. We analyzed and compared different methods and found that SQUARE and Security Requirements Engineering Process methods cover most of the important activities of SRE. The developers can adopt these SRE methods and easily identify the security requirements for software systems.";1
A Security Practices Evaluation Framework;Software development teams need guidance on choosing security practices so they can develop code securely. The academic and practitioner literature on software development security practices is large, and expanding. However, published empirical evidence for security practice use in software development is limited and fragmented, making choosing appropriate practices difficult. Measurement frameworks offer a tool for collecting and comparing software engineering data. The goal of this work is to aid software practitioners in evaluating security practice use in the development process by defining and validating a measurement framework for software development security practice use and outcomes. We define the Security Practices Evaluation Framework (SP-EF), a measurement framework for software development security practices. SP-EF supports evidence-based practice selection. To enable comparison of practices across publications and projects, we define an ontology of software development security practices. We evaluate the framework and ontology on historical data and industrial projects.;1
Analytical network process for software security: a design perspective;In today’s world, development organizations are receiving pressure from users to focus on better security design during software development. Security attributes perform a key role in security design. For improvement in design of security, this study evaluates weightage of security attributes. The core aim of this work is to conclude the relations among security factors and their priorities. Here, authors are using analytical network process to identify the priorities of security attributes. The results are offered as a guide for developers. The priority weights of security attributes may be used to analyze trade-off between conflicting software security attributes.;1
Software requirements and architecture modeling for evolving non-secure applications into secure applications;This paper describes an approach to modeling the evolution of non-secure applications into secure applications in terms of the software requirements model and software architecture model. The requirements for security services are captured separately from application requirements, and the security services are encapsulated in connectors in the software architecture, separately from the components providing functional services. The enterprise architecture is described in terms of use case models, static models, and dynamic models. The software architecture is described in terms of components and connectors, which can be deployed to distributed configurations. By separating application concerns from security concerns, the evolution from a non-secure application to a secure application can be achieved with less impact on the application. An electronic commerce system is described to illustrate the approach.;1
Secure information systems development – a survey and comparison;Nowadays, security solutions are mainly focused on providing security defences (such as firewalls, routers, configuration server, password and encryption) instead of solving one of the main reasons of security problems that refers to an appropriate information systems design. Fortunately, there have been developed new methodologies incorporating security into their development processes. This paper makes a comparison of eleven secure systems design methodologies. The analysed methodologies fulfil criteria partially and in this paper, we make it clear that security aspects cannot be completely specified by these methodologies since they have a series of limitations that we have to take into account. At the same time, each one of these methodologies comprises very important aspects concerning security that can be used as a basis for new methodologies or extensions that may be developed.;1
Automated analysis of security requirements through risk-based argumentation;Computer-based systems are increasingly being exposed to evolving security threats, which often reveal new vulnerabilities. A formal analysis of the evolving threats is difficult due to a number of practical considerations such as incomplete knowledge about the design, limited information about attacks, and constraints on organisational resources. In our earlier work on RISA (RIsk assessment in Security Argumentation), we showed that informal risk assessment can complement the formal analysis of security requirements. In this paper, we integrate the formal and informal assessment of security by proposing a unified meta-model and an automated tool for supporting security argumentation called OpenRISA. Using a uniform representation of risks and arguments, our automated checking of formal arguments can identify relevant risks as rebuttals to those arguments, and identify mitigations from publicly available security catalogues when possible. As a result, security engineers are able to make informed and traceable decisions about the security of their computer-based systems. The application of OpenRISA is illustrated with examples from a PIN Entry Device case study.;1
Model-Driven Development for secure information systems;"A security model provides a semantically rich representation in that it permits the functional and structural properties of the security system to be described, and allows the developers to give a high-level definition of the protection requirements and system policies as well as producing a concise and precise. The articles in this special issue
As a previous review of literature has made evident, both Model-Driven Development and its application to the development of secure information systems are at their very peak. Therefore, this special issue compiles relevant advances in the area of Model-Driven Development for Secure Information Systems. In some cases, the papers are evolutions of some of the basis of this discipline, and in others they present new and interesting approaches.";1
Foundations for Designing Secure Architectures;Developing security-critical systems is difficult and there are many well-known examples of security weaknesses exploited in practice. In particular, so far little research has been performed on the soundly based design of secure architectures, which would be urgently needed to develop secure systems reliably and efficiently. In this abstract, we sketch some research on a sound methodology supporting secure architecture design. We give an overview over an extension of UML, called UMLsec, that allows expressing security-relevant information within the diagrams in an architectural design specification. We define foundations for secure architectural design patterns. We present tool-support which has been developed for the UMLsec secure architecture approach.;1
A common criteria based security requirements engineering process for the development of secure information systems;In order to develop security critical Information Systems, specifying security quality requirements is vitally important, although it is a very difficult task. Fortunately, there are several security standards, like the Common Criteria (ISO/IEC 15408), which help us handle security requirements. This article will present a Common Criteria centred and reuse-based process that deals with security requirements at the early stages of software development in a systematic and intuitive way, by providing a security resources repository as well as integrating the Common Criteria into the software lifecycle, so that it unifies the concepts of requirements engineering and security engineering.;1
A systematic review of security requirements engineering;One of the most important aspects in the achievement of secure software systems in the software development process is what is known as Security Requirements Engineering. However, very few reviews focus on this theme in a systematic, thorough and unbiased manner, that is, none of them perform a systematic review of security requirements engineering, and there is not, therefore, a sufficiently good context in which to operate. In this paper we carry out a systematic review of the existing literature concerning security requirements engineering in order to summarize the evidence regarding this issue and to provide a framework/background in which to appropriately position new research activities.;1
When security meets software engineering: a case of modelling secure information systems;"Although security is a crucial issue for information systems, traditionally, it is considered after the definition of the system. This approach often leads to problems, which most of the times translate into security vulnerabilities. From the viewpoint of the traditional security paradigm, it should be possible to eliminate such problems through better integration of security and software engineering. This paper firstly argues for the need to develop a methodology that considers security as an integral part of the whole system development process, and secondly it contributes to the current state of the art by proposing an approach that considers security concerns as an integral part of the entire system development process and by relating this approach with existing work. The different stages of the approach are described with the aid of a real-life case study; a health and social care information system.";1
An extensive systematic review on the Model-Driven Development of secure systems;"Context: Model-Driven Security (MDS) is as a specialised Model-Driven Engineering research area for supporting the development of secure systems. Over a decade of research on MDS has resulted in a large number of publications.
Objective: To provide a detailed analysis of the state of the art in MDS, a systematic literature review (SLR ) is essential.
Method: We conducted an extensive SLR on MDS. Derived from our research questions, we designed a rigorous, extensive search and selection process to identify a set of primary MDS studies that is as complete as possible. Our three-pronged search process consists of automatic searching, manual searching, and snowballing. After discovering and considering more than thousand relevant papers, we identified, strictly selected, and reviewed 108 MDS publications.
Results: The results of our SLR show the overall status of the key artefacts of MDS, and the identified primary MDS studies. For example, regarding security modelling artefact, we found that developing domain-specific languages plays a key role in many MDS approaches. The current limitations in each MDS artefact are pointed out and corresponding potential research directions are suggested. Moreover, we categorise the identified primary MDS studies into 5 significant MDS studies, and other emerging or less common MDS studies. Finally, some trend analyses of MDS research are given.
Conclusion: Our results suggest the need for addressing multiple security concerns more systematically and simultaneously, for tool chains supporting the MDS development cycle, and for more empirical studies on the application of MDS methodologies. To the best of our knowledge, this SLR is the first in the field of Software Engineering that combines a snowballing strategy with database searching. This combination has delivered an extensive literature study on MDS.";1
Best practices for software security: An overview;With the growth of software flaws there is a rise in the demand of security embedding to achieve the goal of secure software development in a more efficient manner. Different practices are in use to keep the software intact. These practices also meant to be scrutinized for better results on the basis of the level of security, efficiency and complexity they are providing. It may also be weighted on the basis of Confidentiality, Integrity and Availability (CIA). Software security is a step by step procedure which can not be achieved just at a specific level but it should be taken into account from the beginning of the Software Development Life Cycle (SDLC). In this paper, we have taken into account some of the best practices for secure software development and categorized them based on the phases in software development lifecycle. The results enable us to draw a clear picture of the best practices in software development which will enable a developer to follow them on a particular SDLC phase.;1
Exploring Software Security Approaches in Software Development Lifecycle: A Systematic Mapping Study;There is an increase use of security driven approaches to support software development activities, such as requirements, design and implementation. The objective of this paper is to identify the existing software security approaches used in the software development lifecycle (SDLC). In order to meet our goal, we conducted a systematic mapping study to identify the primary studies on the use of software security techniques in SDLC. In total, we selected and categorized 118 primary studies. After analyzing the selected studies, we identified 52 security approaches and we categorized them in to five main categories, namely, ‘secure requirements modeling’, ‘vulnerability identification, adaption and mitigation’, ‘software security focused process’, ‘extended UML-based secure modeling profiles’, ‘non UML-based secure modeling notations’. The results show that the most frequently used approaches are static analysis and dynamic analysis that provide security checks in the coding phase. In addition, our results show that many studies in this review considered security checks around the coding stage of software development. This work will assist software development organizations in better understanding the existing software security approaches used in the software development lifecycle. It can also provide researchers with a firm basis on which to develop new software security approaches.;1
Formal analysis and design for engineering security automated derivation of formal software security specifications from goal-oriented security requirements;"Formal methods have long been advocated for the development of provably secure software. However, the lack of formal requirements elaboration and the limited scalability afforded by such methods have led to employing informal or semi-formal methods for large-scale software development. In our effort to produce highly secure software in a systematic, provable and cost-effective manner, the authors have proposed formal analysis and design for engineering security (FADES) as the first goal-oriented software security engineering approach that provides an automated bridge between the goal-oriented semi-formal Knowledge Acquisition for autOmated Specifications (KAOS) framework and the B formal method. Automating the transition from requirements to specifications; considered one of the most difficult steps in the software development lifecycle, is vital to the success of FADES. Further, the automated derivation of a suite of acceptance test cases from the requirements model in FADES provides means to verify security implementation against the requirements model. In this study, the authors propose an automated process using FADES to systematically derive B specifications and a suite of acceptance test cases from goal-oriented security requirements. Further, the authors empirically validate the effectiveness of the FADES automated bridge that paves the grounds for formal design and implementation. The empirical validation involves both security engineering practitioners and experts in formal methods for security. The extensive results obtained demonstrate the effectiveness of the FADES automated bridge in producing secure software in a cost-effective manner.";1
An empirical study to improve software security through the application of code refactoring;"Context
Code bad smells indicate design flaws that can degrade the quality of software and can potentially lead to the introduction of faults. They can be eradicated by applying refactoring techniques. Code bad smells that impact the security perspective of software should be detected and removed from their code base. However, the existing literature is insufficient to support this claim and there are few studies that empirically investigate bad smells and refactoring opportunities from a security perspective.
Objective
In this paper, we investigate how refactoring can improve the security of an application by removing code bad smell.
Method
We analyzed three different code bad smells in five software systems. First, the identified code bad smells are filtered against security attributes. Next, the object-oriented design and security metrics are calculated for the five investigated systems. Later, refactoring is applied to remove security-related code bad smells. The correctness of detection and refactoring of investigated code smells are then validated. Finally, both traditional object-oriented and security metrics are again calculated after removing bad smells to assess its impact on the design and security attributes of systems.
Results
We found ‘feature envy’ to be the most abundant security bad smell in investigated projects. The ‘move method’ and ‘move field’ are commonly applied refactoring techniques because of the abundance of feature envy.
Conclusion
The results of security metrics indicate that refactoring helps improve the security of an application without compromising the overall quality of software systems.";1
Static Code Analysis to Detect Software Security Vulnerabilities - Does Experience Matter?;Code reviews with static analysis tools are today recommended by several security development processes. Developers are expected to use the tools' output to detect the security threats they themselves have introduced in the source code. This approach assumes that all developers can correctly identify a warning from a static analysis tool (SAT) as a security threat that needs to be corrected. We have conducted an industry experiment with a state of the art static analysis tool and real vulnerabilities. We have found that average developers do not correctly identify the security warnings and only developers with specific experiences are better than chance in detecting the security vulnerabilities. Specific SAT experience more than doubled the number of correct answers and a combination of security experience and SAT experience almost tripled the number of correct security answers.;1
Benchmarking SDL and CLASP lifecycle;Processes for secure software development play a crucial role in the software lifecycle. They help organizations to meet security requirements throughout the development lifecycle. Among these processes, OWASP's CLASP and Microsoft's SDL are leaders for security support in the software life cycle. This has prompted researchers to compare and evaluate these two approaches in order to use them in an opportunistic manner. However, these studies focus mainly on the activities identified in each of these approaches. We think that the interested parties point of view is important. So, our research question is: what are the main concerns for the various stakeholders in a secure development lifecycle? And how SDL and CLASP contribute to meet these concerns? This paper aims to study and compare the two approaches with considering three dimensional viewpoints: security and security audit viewpoint, software engineering viewpoint and decider viewpoint according to the stakeholders involved in these processes. Our comparison is based on a number of criteria that we classified according to these 3 viewpoints.;1
Design notations for secure software: a systematic literature review;In the past 10 years, the research community has produced a significant number of design notations to represent security properties and concepts in a design artifact. These notations are aimed at documenting and analyzing security in a software design model. The fragmentation of the research space, however, has resulted in a complex tangle of different techniques. Hence, practitioners are confronted with the challenging task of scouting the right approach from a multitude of proposals. Similarly, it is hard for researchers to keep track of the synergies among the existing notations, in order to identify the existing opportunities for original contributions. This paper presents a systematic literature review that inventorizes the existing notations and provides an in-depth, comparative analysis for each.;1
A process for mastering security evolution in the development lifecycle;"Continuous system evolution makes it challenging to keep software systems permanently secure as changes either in the system itself or its environment may cause new threats and vulnerabilities. Therefore, suitable activities aligned with the software development process are required to master security evolution. This introduction to the special section on eternal security evolution presents a process for handling security evolution throughout the software development lifecycle and uses this process to position the individual contributions. We first present the underlying security development process comprising the phases initialization, security analysis, security design, security implementation, security testing, and security deployment. On this basis, we define the security evolution process comprising the activities security requirements review, adaptation of design models, code fixing and patch development, regression testing as well as re-deployment. Finally, the defined security evolution activities are discussed in context of the four articles on eternal security evolution presented in this special section of the International Journal on Software Tools for Technology
Transfer.";1
Software architectural considerations for the development of secure software systems;Today, many computers are using to manage many applications, like management of bank accounts, to keep medical records, etc. With the progress of computer science and become more complicated, the amount of threats and risks is also increased strongly and attacks in this area have also been complicated and advanced. Today, with this huge amount of vast and complicated threats and attacks on computer systems, security has very important place, because at any moment the amount of threats and attacks in this area is added and these risks in some cases will have to follow heavy and irreparable damages. In the world of computer, software security is one of the important issues all the time. We are insensitive about the threats to the software that we design most of the time and consider security as a solution after the completion of design and constructing programs. In fact, to avoid creating security problems and deal with security threats and attacks properly we must be prevented about fragmented and temporary activities and our activities should have an appropriate structured process and be raised on a specific standard form in this regard. The important point here is if software should have a secure entity, this only is possible by having a secure architecture. There are various techniques that help to develop secure architecture and software systems. These techniques block hackers' ways to attack the applications. This paper tries to clarify the position and importance of software architecture in order to create secure software systems. Also in this article the role of software architecture in order to provide permanent security for software systems, has been described.;1
Should software testers use mutation analysis to augment a test set?;Mutation testing has historically been used to assess the fault-finding effectiveness of a test suite or other verification technique. Mutation analysis, rather, entails augmenting a test suite to detect all killable mutants. Concerns about the time efficiency of mutation analysis may prohibit its widespread, practical use. The goal of our research is to assess the effectiveness of the mutation analysis process when used by software testers to augment a test suite to obtain higher statement coverage scores. We conducted two empirical studies and have shown that mutation analysis can be used by software testers to effectively produce new test cases and to improve statement coverage scores in a feasible amount of time. Additionally, we find that our user study participants view mutation analysis as an effective but relatively expensive technique for writing new test cases. Finally, we have shown that the choice of mutation tool and operator set can play an important role in determining how efficient mutation analysis is for producing new test cases.;1
UML change - specifying model changes with to support security verification of potential evolution;Security certification of complex systems requires a high amount of effort. As a particular challenge, today's systems are increasingly long-living and subject to continuous change. After each change of some part of the system, the whole system needs to be re-certified from scratch (since security properties are not in general modular), which is usually far too much effort. We present a tool-supported approach for security certification that minimizes the amount of effort necessary in the case of re-certification after change. It is based on an approach for model-based development of secure software which makes use of the security extension UMLsec of the Unified Modeling Language (UML). It allows the user to integrate security requirements such as secure information flow and audit security into a system design model, it supported by a security verification tool chain, and has been applied to a number of industrial applications.;1
Development Life-cycle of Critical Software Under FoCaL;"Before their installation, critical systems must be assessed by an independent authority, who ensures that software components are really compliant with a set of requirements described in standards. Such standards describe the framework and the rules to be strictly followed along the development process. Moreover high levels of safety highly recommand the use of formal methods. In this paper, we examine how the FoCaL development environment can help to fulfil these requirements and to ease assessment. This tool aims to help all stages of critical software development, at least when formal methods are required (step-by-step specification and implementation, properties expressed by firstorder formulae, proofs helped by automatic tool). Upon our experience as either software safety assessor or researchers in software engineering and formal methods, we propose a development life cycle adapted to the FoCaL specificity and compliant with independent assessment requirements, through a complete example. We show how features such as inheritance, late binding, redefinition, parametrisation, encapsulation and declarations/definitions, properties/theorems, whole development checked by an independent proof assistant and partially automatic documentation can be used to improve the global safety and the re-use of software
components.";1
Secure software development: Why the development world awoke to the challenge;"From the beginning of the information security age 20 years ago, CIOs have asked over and over, “when will programmers stop making security mistakes?” But other than highly visible efforts by a few large software vendors, the software development community has not heard the question. At least they have not responded until now.
More than 40 large organizations, from Tata Consulting Services (the largest outsourcer in India) to Intel, from Boeing to Siemens, have joined together to raise the visibility of secure software development – and they are having an impact. This article chronicles the forces that brought the consortium together and the steps that they have taken to improve the practice of secure coding throughout the development lifecycle.";1
On the design of more secure software-intensive systems by use of attack patterns;Retrofitting security implementations to a released software-intensive system or to a system under development may require significant architectural or coding changes. These late changes can be difficult and more costly than if performed early in the software process. We have created regular expression-based attack patterns that show the sequential events that occur during an attack. By performing a Security Analysis for Existing Threats (SAFE-T), software engineers can match the symbols of a regular expression to their system design. An architectural analysis that identifies security vulnerabilities early in the software process can prepare software engineers for which security implementations are necessary when coding starts. A case study involving students in an upper-level undergraduate security course suggests that SAFE-T can be performed by relatively inexperienced engineers who are not experts in security. Data from the case study also suggest that the attack patterns do not restrict themselves to vulnerabilities in specific environments.;1
Comparing risk identification techniques for safety and security requirements;When developing systems where safety and security are important aspects, these aspects have to be given special attention throughout the development, in particular in the requirements phase. There are many similar techniques within the safety and security fields, but few comparisons about what lessons that could be learnt and benefits to be gained. In this paper different techniques for identifying risk, hazard and threat of computer-supported systems are compared. This is done by assessing the techniques’ ability to identify different risks in computer-supported systems in the environment where they operate. The purpose of this paper is therefore to investigate whether and how the techniques can mutually strengthen each other. The result aids practitioners in the selection and combination of techniques and researchers in focusing on gaps between the two fields. Among other things, the findings suggest that many safety techniques enforce a creative and systematic process by applying guide-words and structuring the results in worksheets, while security techniques tend to integrate system models with security models.;1
Time for Addressing Software Security Issues: Prediction Models and Impacting Factors;Finding and fixing software vulnerabilities have become a major struggle for most software development companies. While generally without alternative, such fixing efforts are a major cost factor, which is why companies have a vital interest in focusing their secure software development activities such that they obtain an optimal return on this investment. We investigate, in this paper, quantitatively the major factors that impact the time it takes to fix a given security issue based on data collected automatically within SAP’s secure development process, and we show how the issue fix time could be used to monitor the fixing process. We use three machine learning methods and evaluate their predictive power in predicting the time to fix issues. Interestingly, the models indicate that vulnerability type has less dominant impact on issue fix time than previously believed. The time it takes to fix an issue instead seems much more related to the component in which the potential vulnerability resides, the project related to the issue, the development groups that address the issue, and the closeness of the software release date. This indicates that the software structure, the fixing processes, and the development groups are the dominant factors that impact the time spent to address security issues. SAP can use the models to implement a continuous improvement of its secure software development process and to measure the impact of individual improvements. The development teams at SAP develop different types of software, adopt different internal development processes, use different programming languages and platforms, and are located in different cities and countries. Other organizations, may use the results—with precaution—and be learning organizations.;1
FOSS version differentiation as a benchmark for static analysis security testing tools;We propose a novel methodology that allows automatic construction of benchmarks for Static Analysis Security Testing (SAST) tools based on real-world software projects by differencing vulnerable and fixed versions in FOSS repositories. The methodology allows us to evaluate ``actual'' performance of SAST tools (without unrelated alarms). To test our approach, we benchmarked 7 SAST tools (although we report only results for the two best tools), against 70 revisions of four major versions of Apache Tomcat with 62 distinct CVEs as the source of ground truth vulnerabilities.;1
Towards a structured unified process for software security;Security is often an afterthought when developing software, and is often bolted on late in development or even during deployment or maintenance, through activities such as penetration testing, add-on security software and penetrate-and patch maintenance. We believe that security needs to be built in to the software from the beginning, and that security activities need to take place throughout the software lifecycle. Accomplishing this effectively and efficiently requires structured approach combining a detailed understanding on what causes vulnerabilities, and how specific activities combine to prevent them.In this paper we introduce key elements of the approach we are taking: vulnerability cause graphs, which encode information about vulnerability causes, and security activity graphs, which encode information about security activities. We discuss how these can be applied to design software development processes (or changes to processes) that eliminate software vulnerabilities.;1
A Security Practices Evaluation Framework;Software development teams need guidance on choosing security practices so they can develop code securely. The academic and practitioner literature on software development security practices is large, and expanding. However, published empirical evidence for security practice use in software development is limited and fragmented, making choosing appropriate practices difficult. Measurement frameworks offer a tool for collecting and comparing software engineering data. The goal of this work is to aid software practitioners in evaluating security practice use in the development process by defining and validating a measurement framework for software development security practice use and outcomes. We define the Security Practices Evaluation Framework (SP-EF), a measurement framework for software development security practices. SP-EF supports evidence-based practice selection. To enable comparison of practices across publications and projects, we define an ontology of software development security practices. We evaluate the framework and ontology on historical data and industrial projects.;1
Synthesis of secure software development controls;A study of the available approaches aimed at mitigating vulnerabilities in the software development, and their applicability during the software compliance evaluation was carried out. Having systematized the standards and guidelines on the development of secure software, we made a list of basic requirements that enables us, among other things, to assess the software development processes for compliance with secure software requirements. We present an original conceptual model for analysis and synthesis of controls for secure software development, which allows software developers to select reasonable controls for developing secure software.;1
Unified modeling of attacks, vulnerabilities and security activities;"Security is becoming recognized as an important aspect of software development, leading to the development of many different security-enhancing techniques, many of which use some kind of custom modeling language. Models in these different languages cannot readily be related to each other, which is an obstacle to using several techniques together. The sheer number of languages is, in itself, also an obstacle to adoption by developers.
In this paper we present a modeling language that can be used in place of four existing modeling languages: attack trees, vulnerability cause graphs, security activity graphs, and security goal indicator trees. Models in our language can be more precise than earlier models, which allows them to be used in automated applications, such as automatic testing and static analysis. Models in the new language can be derived automatically from models in the existing languages, and can be viewed using existing notation.
Our modeling language exploits a data model, also presented in this paper, that permits rich interconnections between various items of security knowledge. In this data model it is straightforward to relate different kinds of models, and thereby different software security techniques, to each other.";1
MAC and UML for secure software design;Security must be a first class citizen in the design of large scale, interacting, software applications, at early and all stages of the lifecycle, for accurate and precise policy definition, authorization, authentication, enforcement, and assurance. One of the dominant players in software design is the <i>unified modeling language, UML, a language for specifying, visualizing, constructing and documenting software artifacts. In UML, diagrams provide alternate perspectives for different stakeholders, e.g.: use case diagrams for the interaction of users with system components, class diagrams for the static classes and relationships among them, and sequence diagrams for the dynamic behavior of instances of the class diagram. However, UML's support for the definition of security requirements for these diagrams and their constituent elements (e.g., actors, systems, use cases, classes, instances, include/extend/generalize relationships, methods, data, etc.) is lacking. In this paper, we address this issue by incorporating <i>mandatory access control (MAC) into use case, class, and sequence diagrams, providing support for the definition of clearances and classifications for relevant UML elements. In addition, we provide a framework for security assurance as users are defining and evolving use case, class, and sequence diagrams, bridging the gap between software engineers and an organization's security personnel in support of <i>secure software design. To demonstrate the feasibility and utility of our work on secure software design, our MAC enhancements for UML have been integrated into Borland's Together Control Center Environment.;1
Bringing security home: a process for developing secure and usable systems;The aim of this paper is to provide better support for the development of secure systems. We argue that current development practice suffers from two key problems:1. Security requirements tend to be kept separate from other system requirements, and not integrated into any overall strategy.2. The impact of security measures on users and the operational cost of these measures on a day-to-day basis are usually not considered.Our new paradigm is the full integration of security and usability concerns into the software development process, thus enabling developers to build secure systems that work in the real world. We present AEGIS, a secure software engineering method which integrates asset identification, risk and threat analysis and context of use, bound together through the use of UML, and report its application to case studies on Grid projects. An additional benefit of the method is that the involvement of stakeholders in the high-level security analysis improves their understanding of security, and increases their motivation to comply with policies.;1
Formal derivation of security design specifications from security requirements;Engineering secure software remains a significant challenge for today's software organizations as they struggle to understand the implications of security o the system and develop systems that guarantee specified software security properties. Despite many software engineering advances, current methods for deriving a design from a set of requirements that guarantee the retention of the intended security properties remains difficult and often unachievable. If security requirements are formalized and transformed into design using formal methods, the result would reduce the potential for security vulnerabilities through better clarity, completeness, and consistency. To this end, we outline a requirements-driven security engineering approach for deriving design specifications from security requirements that guarantee security properties specified in requirements are retained. We build on the goal-oriented KAOS (Knowledge Acquisition in autOmated Specifications) framework to formally construct a complete, consistent, and clear security requirements model. The resulting model is then transformed to the B language to derive security design specifications. Using B enables us to further implement the design while preserving requirements relevant security properties. Using the B refinement mechanism, we generate design specifications and ultimately implementation. The approach treats security-specific elements in a systematic and constructive way while considering security early in the development lifecycle with assurance of completeness, consistency and clarity throughout the development. Moreover, our approach allows for requirement traceability at the various phases of development that helps security evaluators to have more confidence in the target of evaluation.;1
Secure Code Generation for Web Applications;A large percentage of recent security problems, such as Cross-site Scripting or SQL injection, is caused by string-based code injection vulnerabilities. These vulnerabilities exist because of implicit code creation through string serialization. Based on an analysis of the vulnerability class’ underlying mechanisms, we propose a general approach to outfit modern programming languages with mandatory means for explicit and secure code generation which provide strict separation between data and code. Using an exemplified implementation for the languages Java and HTML/JavaScript respectively, we show how our approach can be realized and enforced.;1
Guiding the selection of security patterns based on security requirements and pattern classification;Security pattern-based system and software engineering (PBSE) approaches aim at building secure software and systems by capturing and reusing artifacts that encapsulate security expert's knowledge called security patterns. In this context, security patterns are selected by developers based on security requirements. On the other hand, security risk management is an iterative approach that consists of: (1) a risk assessment activity for identifying, analyzing and evaluating security risks and (2) a risk treatment activity to mitigate these risks which result in issuing security requirements. Hence, risk management and security PBSE can be used together. In this context, this paper aims at guiding the selection of security patterns in security PBSE based on security risk management results and pattern classification. For illustration purposes, we consider an example of a SCADA (Supervisory Control And Data Acquisition) system.;1
Research on software design level security vulnerabilities;One of the major problems in software security is the lack of knowledge about security among software developers. Even if a developer has good knowledge about current software vulnerabilities, they generally have little or no idea about the causes and measures that can avoid those vulnerabilities. Now it is established fact that most of the vulnerabilities arise in design phase of the software development lifecycle. Keeping in view the importance of software design level security, a study of current software design level vulnerabilities and their cause is conducted. In this paper, we discuss current practices in specific software design tasks, vulnerabilities and mitigation mechanism. On the basis of the critical review, areas of research are identified that warrant further investigation.;1
Build It, Break It, Fix It: Contesting Secure Development;Typical security contests focus on breaking or mitigating the impact of buggy systems. We present the Build-it, Break-it, Fix-it (BIBIFI) contest, which aims to assess the ability to securely build software, not just break it. In BIBIFI, teams build specified software with the goal of maximizing correctness, performance, and security. The latter is tested when teams attempt to break other teams’ submissions. Winners are chosen from among the best builders and the best breakers. BIBIFI was designed to be open-ended—teams can use any language, tool, process, and so on, that they like. As such, contest outcomes shed light on factors that correlate with successfully building secure software and breaking insecure software. We ran three contests involving a total of 156 teams and three different programming problems. Quantitative analysis from these contests found that the most efficient build-it submissions used C/C++, but submissions coded in a statically type safe language were 11× less likely to have a security flaw than C/C++ submissions. Break-it teams that were also successful build-it teams were significantly better at finding security bugs.;1
A threat-driven approach to modeling and verifying secure software;This paper presents a formal approach to threat-driven modeling and verification of secure software using aspect-oriented Petri nets. Based on the behavior model of intended functions, we identify and build formal models of security threats, which are potential misuses and anomalies of the intended functions that violate security goals. Threat mitigations are further modeled in an aspect-oriented paradigm. Taking Petri nets as a formal basis for modeling behaviors, threats, and mitigations as a whole, we verify properties of and consistency between behaviors and threats, and absence of identified threats from the integrated model of functions and threat mitigations. This makes it possible to achieve a design that is provably resistant to the anticipated threats and thus reduce significant design-level vulnerabilities.;1
Research on software security awareness: problems and prospects;People attack software deliberately to steal highly sensitive as well as personal information with the sole intention of carrying out well-funded, destructive and unethical goals that could harm individuals, nations or the whole world. Available technological controls could be implemented to tighten access and minimize persistent threats but the complete solution of secure software could only be provided by changing the behavior of the people involved. This can be achieved through effective security awareness techniques implemented by individuals because they are, in most cases, the first target for gaining access into the system. This paper highlights the utility of security awareness with the help of recent published work for building more secure software. In addition, areas that need further investigations are identified in the paper.;1
Failure-driven software safety;Software safety and software risk management are two of the most important facets of modern software engineering. To understand safety requires that we understand first what is not safe. This paper examines the concept of failure in software engineering and describes an approach to failure-driven software design (FDSD).;1
Towards the Integration of Security Practices in the Software Implementation Process of ISO/IEC 29110: A Mapping;Secure software practices are gradually gaining relevance among software practitioners and researchers. This is happening because today more than ever software is becoming part of our lives and cybercrimes are constantly appearing. Despite its importance, its current practice in the software industry is still scarce. Indeed, software security problems are divided 50/50 between bugs and flaws. In particular, it remains a significant challenge for software practitioners in small software companies. Therefore, there is a need to support small companies in changing their existing ways of work to integrate these new and unfamiliar practices. The aim of this study is twofold. First, to help building an awareness of the software security process among practitioners in small companies. Second, to help the integration of these practices with software implementation process of ISO/IEC 29110 which results in an extension of the latter with additional activities identified from the industry best practices. Nevertheless, the extension proposal is to be performed selectively, based on the value of the software as an asset to the stakeholders and on stakeholders needs.;1
The risks analysis like a practice of secure software development. A revision of models and methodologies;The following document, presents and analyzes the Risks Analysis in the whole software development life cycle, framed like one of the recommended practices for secure software development. It present and compare a set of Risk Analysis methodologies and strategies, considering like criteria some classifications propose by different authors and the objectives that they persecute to orient them towards of evaluation criterion for the secure software development.;1
SecSDM: A Model for Integrating Security into the Software Development Life Cycle;Most traditional software development methodologies do not explicitly include a standardised method for incorporating information security into their life cycles. It is argued that security considerations should provide input into every phase of the Software Development Life Cycle (SDLC), from requirements gathering to design, implementation, testing and deployment. Therefore, to build more secure software applications, an improved software development process is required. The Secure Software Development Model (SecSDM), as described in this paper, is based on many of the recommendations provided by relevant international standards and best practices, for example, the ISO 7498-2 (1989) standard which addresses the underlying security services and mechanisms that form an integral part of the model.;1
From misuse cases to mal-activity diagrams: Bridging the gap between functional security analysis and design;Secure software engineering is concerned with developing software systems that will continue delivering its intended functionality despite a multitude of harmful software technologies that can attack these systems from anywhere and at anytime. Misuse cases and mal-activity diagrams are two techniques to model functional security requirements address security concerns early in the development life cycle. This allows system designers to equip their systems with security mechanisms built within system design rather than relying on external defensive mechanisms. In a model-driven engineering process, misuse cases are expected to drive the construction of mal-activity diagrams. However, a systematic approach to transform misuse cases into mal-activity diagrams is missing. Therefore, this process remains dependent on human skill and judgment, which raises the risk of developing mal-activity diagrams that are inconsistent with the security requirements described in misuse cases, leading to the development of an insecure system. This paper presents an authoring structure for misuse cases and a transformation technique to systematically perform this desired model transformation. A study was conducted to evaluate the proposed technique using 46 attack stories outlined in a book by a former well-known hacker (Mitnick and Simon in The art of deception: controlling the human element of security, Wiley, Indianapolis, 2002). The results indicate that applying the proposed technique produces correct mal-activity diagrams from misuse cases.;1
A framework to support alignment of secure software engineering with legal regulations;"Regulation compliance is getting more and more important for software systems that process and manage sensitive information. Therefore, identifying and analysing relevant legal regulations and aligning them with security requirements become necessary for the effective development of secure software systems. Nevertheless, Secure Software Engineering Modelling Languages (SSEML) use different concepts and terminology from those used in the legal domain for the description of legal regulations. This situation, together with the lack of appropriate background and knowledge of laws and regulations, introduces a challenge for software developers. In particular, it makes difficult to perform (i) the elicitation of appropriate security requirements from the relevant laws and regulations; and (ii) the correct tracing of the security requirements throughout the development stages. This paper presents a framework to support the consideration of laws and regulations during the development of secure software systems. In particular, the framework enables software developers (i) to correctly elicit security requirements from the appropriate laws and regulations; and (ii) to trace these requirements throughout the development stages in order to ensure that the design indeed supports the required laws and regulations. Our framework is based on existing work from the area of secure software engineering, and it complements this work with a novel and structured process and a well-defined method. A practical case study is employed to demonstrate the applicability of our work.";1
Software Security: Building Security In;"Summary form only given. Software security has come a long way in the last few years, but we've really only just begun. I will present a detailed approach to getting past theory and putting software security into practice. The three pillars of software security are applied risk management, software security best practices (which I call touchpoints), and knowledge. By describing a manageably small set of touchpoints based around the software artifacts that you already produce, I avoid religious warfare over process and get on with the business of software security. That means you can adopt the touchpoints without radically changing the way you work. The touchpoints I will describe include: code review using static analysis tools; architectural risk analysis; penetration testing; security testing; abuse case development; and security requirements. Like the yin and the yang, software security requires a careful balance-attack and defense, exploiting and designing, breaking and building-bound into a coherent package. Create your own Security Development Lifecycle by enhancing your existing software development lifecycle with the touchpoints";1
Security modeling for service-oriented systems using security pattern refinement approach;Security is one of the critical aspects of current systems, which are based on loosely coupled and technology-agnostic service-oriented architectures (SOA). Though SOA is the driving force for enterprises to open their ends for global business collaborations, nevertheless it evolves many challenges for modeling and enforcing security. One of the main problems for designing secure systems is the lack of consistent frameworks and methodologies for modeling security concerns. Traditional approaches consider security at the end of system development, which evolves inflexible and un-configurable systems, which are too difficult to maintain and manage. The other major problem with current approaches is that they assume pre-defined and hard-coded security patterns and mechanisms for secure system design. Whereas, the evolving SOA systems require configurable security to realize different security patterns and security policies in a variety of business scenarios. To solve these problems, it is necessary to model security concerns from the beginning of system modeling in a platform-independent way. This paper proposes a pattern refinement approach for security modeling to achieve configurable and declarative security, based on the principles of abstraction, refinement, separation-of-concerns and maintainability to achieve flexible configurations of SOA security. In the proposed approach, a Domain Expert defines abstract policies using common security vocabulary and a Security Expert models security with patterns and refines them for a target architecture in successive systematic refinements. Furthermore, it facilitates the transformation of abstract security models into executable security policies for the target platforms.;1
Improving software security with static automated code analysis in an industry setting;Software security can be improved by identifying and correcting vulnerabilities. In order to reduce the cost of rework, vulnerabilities should be detected as early and efficiently as possible. Static automated code analysis is an approach for early detection. So far, only few empirical studies have been conducted in an industrial context to evaluate static automated code analysis. A case study was conducted to evaluate static code analysis in industry focusing on defect detection capability, deployment, and usage of static automated code analysis with a focus on software security. We identified that the tool was capable of detecting memory related vulnerabilities, but few vulnerabilities of other types. The deployment of the tool played an important role in its success as an early vulnerability detector, but also the developers perception of the tools merit. Classifying the warnings from the tool was harder for the developers than to correct them. The correction of false positives in some cases created new vulnerabilities in previously safe code. With regard to defect detection ability, we conclude that static code analysis is able to identify vulnerabilities in different categories. In terms of deployment, we conclude that the tool should be integrated with bug reporting systems, and developers need to share the responsibility for classifying and reporting warnings. With regard to tool usage by developers, we propose to use multiple persons (at least two) in classifying a warning. The same goes for making the decision of how to act based on the warning.;1
Measuring systems security;Security metrics have evolved side by side with the advent of security tools and techniques. They have been derived from the techniques rather than specified as system requirements. This paper surveys the evolution and state of the practice of security metrics from both a technical and historical perspective. It describes the evolution of currently popular security metrics, and classifies them to illustrate their utility in systems engineering verification and validation activities. It provides criteria with which to evaluate security metrics based on system purpose and architecture. The criteria are illustrated using a case study of Cloud System security.;1
Software Security Requirements Engineering: State of the Art;Software Engineering has established techniques, methods and technology over two decades. However, due to the lack of understanding of software security vulnerabilities, we have not been so successful in applying software engineering principles that have been established for the past at least 25 years, when developing secure software systems. Therefore, software security can not be just added after a system has been built and delivered to customers as seen in today’s software applications. This keynote paper provides concise methods, techniques, and best practice requirements guidelines on software security and also discusses an Integrated-Secure SDLC model (IS-SDLC), which will benefit practitioners, researchers, learners, and educators.;1
Model-Based Security Testing: A Taxonomy and Systematic Classification;Model-based security testing relies on models to test whether a software system meets its security requirements. It is an active research field of high relevance for industrial applications, with many approaches and notable results published in recent years. This article provides a taxonomy for model-based security testing approaches. It comprises filter criteria (i.e., model of system security, security model of the environment, and explicit test selection criteria) as well as evidence criteria (i.e., maturity of evaluated system, evidence measures, and evidence level). The taxonomy is based on a comprehensive analysis of existing classification schemes for model-based testing and security testing. To demonstrate its adequacy, 119 publications on model-based security testing are systematically extracted from the five most relevant digital libraries by three researchers and classified according to the defined filter and evidence criteria. On the basis of the classified publications the article provides an overview of the state of the art in model-based security testing and discusses promising research directions with regard to security properties, coverage criteria, as well as the feasibility and return on investment of model-based security testing.;1
Security engineering: systems engineering of security through the adaptation and application of risk management;This paper presents an ongoing research project that is a sequel to an earlier work on the Development of Enterprise Information Security Management (EISM) Tool Suite for different stages like Requirement and Risk Analysis, Policy Development, Infrastructure Advisory Generation, and Testing of the Security Engineering Life Cycle. The present project attempts to develop a set of web-based information security management services using web-service technologies. The study also aims at developing a unified formal model of Enterprise Information System Security and suitable metrics for its measurement.;1
The practice of secure software development in SDLC: an investigation through existing model and a case study: The practice of secure software development in SDLC;Software security is an essential requirement for software systems. However, recent investigation indicates that many software development methodologies do not explicitly include methods for incorporating information security into the software development life cycles (SDLC). This research investigates, using case study, the methodologies being used in software development in Saudi Arabia and describes a model for integrating security into the SDLC. The aim is to identify the appropriate means of introducing security measures much earlier in the SDLC. This model is designed to be an extension to the existing SDLC. For achieving the research objectives and answering the research questions, the research followed a case study research design in an information-based organization. The research identified various important elements as security standards, policies, processes being practiced, and tools used within SDLC projects. In this regard, recommendations and verification were gathered to elicit the actual activities that are appropriate to be conducted at each phase of SDLC. The non-functional security requirements were also found, to the use of fortify and hp alm for source code review and web application testing.;1
Unified threat model for analyzing and evaluating software threats;Design-level vulnerabilities are a major source of security problems in software programs. For the purpose of improving the trustworthiness of software designs, this paper presents a unified threat model for representing, analyzing, and evaluating software threats at various design stages. Unified threat models represent software threats via tree structures with AND/OR logical relationships and evaluates software threats in a cost-effective way based on attack paths. Mitigation measures for software threats are designed and prioritized based on the evaluation results, which make it possible to design high-quality software security programs that resist identified software threats. A case study for an online banking system is given to systematically demonstrate the application of unified threat models in software threat analysis and evaluation. The results from the case study demonstrate that the unified threat model is superior to traditional threat trees in accurately evaluating results, designing mitigation measures, and guiding software security testing.;1
A threat model-based approach to security testing;"Software security issues have been a major concern in the cyberspace community, so a great deal of research on security testing has been performed, and various security testing techniques have been developed. Threat modeling provides a systematic way to identify threats that might compromise security, and it has been a well-accepted practice by the industry, but test case generation from threat models has not been addressed yet. Thus, in this paper, we propose a threat model-based security testing approach that automatically generates security test sequences from threat trees and transforms them into executable tests. The security testing approach we consider consists of three activities in large: building threat models with threat trees; generating security test sequences from threat trees; and creating executable test cases by considering valid and invalid inputs. To support our approach, we implemented security test generation techniques, and we also conducted an empirical study to assess the effectiveness of our approach. The results of our study show that our threat tree-based approach is effective in exposing vulnerabilities";1
A security framework for developing service-oriented software architectures;The usually heterogeneous and decentralized nature of entities in the service-oriented architecture has paved the ground for the implementation of approaches distributed according to the constantly changing needs of business. Also, as the distribution of entities and processes increases, the need to provide security over software and hardware sources, which have reached the public thanks to an open space as a result of the service-oriented architecture, is felt. Therefore, security modeling at the level of service-oriented architecture can boost system reliability and enhance its stability once applied and employed. This research provides a secure framework through which to develop software based on the service-oriented architecture. The proposed framework has been modeled using the SoaML profile, which has been introduced for modeling service-oriented environments. The framework's security aspects have been tested by the modeling and specification language Alloy, which is based on the first-order logic. Its accuracy has also been well investigated. Tapping into the model-driven development, this framework can provide an answer to existing security challenges for service-oriented architecture software;1
Mapping the Field of Software Security Metrics;"While security, or its absence, is a property of running software, many aspects of software requirements, design, implementation, and testing contribute to the presence or absence of security in the finished product. Assessing whether a given piece of software meets a set of security objectives is a multi-dimensional problem, and we do not yet
have a clear picture of all of the dimensions. The goal of this research is to support researcher and practitioner use of security measurement by cataloging available metrics, their validation, and the subjects they measure through conducting a systematic mapping study. Our study began with 1,561 papers and narrowed down to 63 papers reporting on 346 metrics. For each metric, we identify the subject being measured, how the metric has been evaluated by researcher(s), and how the metric is being used. Approximately 85% of security-specific metrics have been proposed and evaluated solely by their authors. Approximately 40% of the metrics are not empirically evaluated, and many artifacts and processes remain unmeasured. Approximately 15% of the metrics focus on the early stages of development or on testing (1.5%). At present, despite the abundance of metrics found in the literature, those available give us an incomplete, disjointed, hazy view of software security.";1
A secure software design methodology;Present times demand security to be an inevitable part of almost any software. To achieve this, the security requirements of the software ought to be efficiently elicited and modeled. The modeling languages available today like Unified Modeling Language (UML) are not efficient enough to model such requirements. Within this research work, a new modeling scheme is presented that first, effectively gathers and analyzes the security concerns of all stakeholders and then represents them through novel diagrams.;1
Improving security in software development process: Case Tieto AS;Especially in software development information security is an everlasting race against changing threat landscape. Modern intertwined software solutions offer growing amount of attack targets as applications communicate with each other through internet. The more the attack possibilities grow, the more security should be taken into account. Security in software development should not be thought as an add-on feature to be stamped over otherwise ready application. Security in software should be built in and taken into account in all phases of software development lifecycle. The purpose of this thesis was to evaluate the current status of Secure software development process at Tieto by evaluating it against updated security standards and commonly acknowledged best practices. The main objective was the evaluation and development of the current secure software process, in addition to supporting training material. The research was concluded using action research method, aiming for a change in the studied subject. The analysis for the research was mainly conducted by observations, in addition to use of questionnaire and process evaluation tools. In addition to literature, commonly acknowledged best practice guides were used for the evaluation of the current status of the secure software development process, along with the creation of the process action baseline. Results from the research indicated that the process and the supporting training material at Tieto are in a reasonable state, yet in need of development. The study showed that security awareness is one of the key factors in the secure software development lifecycle. Accordingly, as an outcome from the research, new security awareness training material was created. By forming the best practice baseline based on selected guidelines and literature, a more descriptive process description was created.;1
Top Fifty Software Risk Factors and the Best Thirty Risk Management Techniques in Software Development Lifecycle for Successful Software Projects;The concern of this study is to identify software risks and controls in the software development lifecycle. The aim of this study is to rank the software risks factors according to their importance and occurrence frequency based on the data source. The survey questionnaire is used to collect data and method of sample selection referred to as ‘snowball’ and distribution personal regular sampling was used. The seventy six software project managers have participated in this study who works in the Palestinian software development. Fifty software risk factors in all phases SDLC and thirty risk management techniques were presented to respondents. The results show that all risks in software projects were significant and important in software project manager's perspective. However, the ranking of the importance of the risks is assigned according to it: Analysis, planning, maintenance, design, and implementation. In addition, the top ten software risk factors in software development are selected and used for further analysis such as: Risk13, Risk 14, Risk15, Risk16, Risk11, Risk18, Risk12, Risk50, Risk19, and Risk 9. The concern of this paper the top ten controls are used to model its relationship with the risk, such as: C29, C30, C20, C27, C21, C19, C28, C25, C26, and C23. Software risks can be modelled empirically with risk management control techniques. We recommended applying more studies in software risk management practices with real world companies and building tools to identification and analysis software risks based on quantitative and intelligent techniques.;1
A Secure Software Pattern Generation with Design Level Information;In software engineering, a software pattern is a reusable solution to solve recurring software design problems. Traditionally, suitable patterns are identified by software designers to satisfy a set of requirements. A part of appropriate patterns is then applied to a recurring software design problem. However, the existing software patterns part has to be properly integrated to specific design problems. Therefore, the introduction of formalization is required to describe this integration accurately. In this paper, we propose a framework of UML class diagrams and software patterns integration prepared for formal specification to solve different software designer’s experiences. The integration rules in this formal framework is intended to complement existing textual and graphical descriptions.;1
Systematic Mapping Study on Security Approaches in Secure Software Engineering;In the modern digital era, software systems are extensively adapted and have become an integral component of human society. Such wide use of software systems consists of large and more critical data that inevitably needs to be secured. It is imperative to make sure that these software systems not only satisfy the users' needs or functional requirements, but it is equally important to make sure the security of these software systems. However, recent research shows that many software development methods do not explicitly include software security measures during software development as they move from demand engineering to their final losses. Integrating software security at each stage of the software development life cycle (SDLC) has become an urgent need. Tackling software security, various methods, techniques, and models have been suggested and developed, however, only a few of them provide strong evidence for building secure software applications. The main purpose of this research is to study security measures in the context of the development of secure software (SSD) during the study of systematic mapping (SMS). Based on the inclusion and exclusion criteria, 116 studies were selected. After the data extraction from the selected 116 papers, these were classified based on the quality assessment, software security method, SDLC phases, publication venue, and SWOT analysis. The results indicate that this domain is still immature and sufficient research work needs to be carried out particularly on empirically evaluated solutions.;1
Constructing Authorization Systems Using Assurance Management Framework;Model-driven approach has recently received much attention in developing secure software and systems. In addition, software developers have attempted to employ such an emerging approach in the early stage of software development life cycle. However, security concerns are rarely considered and practiced due to the lack of appropriate systematic mechanisms and tools. In this paper, we introduce a multilayered software development life cycle (SDLC), which is based on an assurance management framework (AMF), focusing on the development of authorization systems. AMF facilitates comprehensive realization of formal security model, security policy specification and verification, generation of security enforcement codes, and rigorous conformance testing. We also articulate our experience in analyzing role-based authorization requirements and realizing those requirements in constructing a role-based authorization system.;1
Software Security: The Dangerous Afterthought;As users of many different types of software, one of the last things we think about when deciding which is best for the task at hand is the security of the software. This of course depends on the type of software as well. If it is banking or tax software then, security is of concern. However, in most cases the thought rarely crosses the average users mind. That is until something happens to the system or information the system may hold. This way of thinking is very similar to the way some software is created. The software's features, usability, and interface are normally at the forefront. On the other hand the software's security is just an afterthought for many developers. While software is developed in a very intricate process, it does not currently stress security. In this paper, we will describe different approaches that have been recently researched to help create more secure software. Although these approaches will be introduced separately, using a combination of two or all three together would be the most secure combination.;1
Comparison of SETAM with security use case and security misuse case: A software security testing study;A software security testing behavior model, SETAM, was proposed in our previous work as the integrated model for describing software security testing requirements behavior, which is not only compatible with security functions and latent typical misuse behaviors, but also with the interaction of them. In this paper, we analyze the differences between SETAM with security use case and security misuse case in different types of security test requirements. To illustrate the effectiveness of SETAM, we compare them in a practical case study by the number of test cases and the number of faults detected by them. The results show that SETAM could decrease about 34.87% use cases on average, and the number of faults detected by SETAM increased by 71.67% in average, which means that our model can detect more faults with fewer test cases for software security testing.;1
Specification, verification, and quantification of security in model-based systems;Modern systems are more and more complex and security has become a key component in the success of software and systems development. The main challenge encountered in industry as well as in academia is to develop secure products, prove their security correctness, measure their resilience to attacks, and check if vulnerabilities exist. In this paper, we review the state-of-the-art related to security specification, verification, and quantification for software and systems that are modeled by using UML or SysML language. The reviewed work fall into the field of secure software and systems engineering that aims at fulfilling the security as an afterthought in the development of secure systems.;1
Model-based systems security quantification;In this paper, we address the issue of security verification and evaluation of systems at the design level. To this end, we elaborate a practical and formal framework that enables security risk assessment and security requirements verification on systems that are designed using SysML activity diagrams. Our approach is based on probabilistic adversarial interactions between potential attackers and the system design models. These interactions result in a global model that is used to quantify security risks by applying probabilistic model-checking. We rely on a standard catalogue of attack patterns to build a library of attacks' design patterns. To demonstrate the effectiveness of our approach, we apply it on a real-life case study related to the Secure Real Time Streaming Protocol.;1
A Systematic Review of Agent-Based Test Case Generation for Regression Testing;There is an urgent need to create awareness about the potential benefits of using agents in software test case generation and to identify the need to develop agent-based regression testing techniques and approaches. It may help in reducing time and cost required for testing. This study reports systematic literature review of existing test case generation approaches for regression testing and agent-based software testing systems. The emphasis is articulated on agent-based regression test case generation. Further research directions are recommended. In the systematic literature review, we framed three sets of research questions. Based on our inclusion and exclusion criteria, we identified 115 potential research papers on test case generation in regression testing and agent-based software testing. We explored journals, international conferences, workshops and identified 59 studies in test case generation for regression testing and 56 studies in agent-based software testing. The data extracted from our study are classified into seven broader areas of agent-based software testing. Based on our systematic literature survey, we recognized available techniques, approaches, platforms as well as methodologies for regression test case generation and developing agent-based software testing systems. This study will benefit the researchers to carry forward their work in the domain of regression test case generation and agent-based software testing. To cut down on schedule and cost, mobile agent-based software testing can be a promising alternative.;1
A systematic classification of security regression testing approaches;The openness of modern IT systems and their permanent change make it challenging to keep these systems secure. A combination of regression and security testing called security regression testing, which ensures that changes made to a system do not harm its security, are therefore of high significance and the interest in such approaches has steadily increased. In this article we present a systematic classification of available security regression testing approaches based on a solid study of background and related work to sketch which parts of the research area seem to be well understood and evaluated, and which ones require further research. For this purpose we extract approaches relevant to security regression testing from computer science digital libraries based on a rigorous search and selection strategy. Then, we provide a classification of these according to security regression approach criteria: abstraction level, security issue, regression testing techniques, and tool support, as well as evaluation criteria, for instance evaluated system, maturity of the system, and evaluation measures. From the resulting classification we derive observations with regard to the abstraction level, regression testing techniques, tool support as well as evaluation, and finally identify several potential directions of future research.;1
Investigating security threats in architectural context: Experimental evaluations of misuse case maps;Many techniques have been proposed for eliciting software security requirements during the early requirements engineering phase. However, few techniques so far provide dedicated views of security issues in a software systems architecture context. This is a problem, because almost all requirements work today happens in a given architectural context, and understanding this architecture is vital for identifying security vulnerabilities and corresponding mitigations. Misuse case maps attempt to provide an integrated view of security and architecture by augmenting use case maps with misuse case concepts. This paper evaluates misuse case maps through two controlled experiments where 33 and 54 ICT students worked on complex real-life intrusions described in the literature. The students who used misuse case maps showed significantly better understanding of intrusions and better ability to suggest mitigations than students who used a combination of two existing techniques as an alternative treatment. Misuse case maps were also perceived more favourably overall than the alternative treatment, and participants reported using misuse case maps more when solving their tasks.;1
Security test generation using threat trees;"Software security issues have been a major concern to the cyberspace community, so a great deal of research on security testing has been performed, and various security testing techniques have been developed. Most of these techniques, however, have focused on testing software systems after their implementation is completed. To build secure and dependable software systems in a cost-effective way, however, it is necessary to put more effort upfront during the software development life cycle. In this paper, we provided a security testing approach that derives test cases from design-level artifacts. The security testing approach we consider consists of four activities: building threat trees from threat modeling; generating security tests from threat trees; generating test inputs including valid and invalid inputs; and assigning input values to parameters. We also conducted an empirical study to show feasibility of our approach.";1
Evaluating the cost reduction of static code analysis for software security;Automated static code analysis is an efficient technique to increase the quality of software during early development. This paper presents a case study in which mature software with known vulnerabilities is subjected to a static analysis tool. The value of the tool is estimated based on reported failures from customers. An average of 17% cost savings would have been possible if the static analysis tool was used. The tool also had a 30% success rate in detecting known vulnerabilities and at the same time found 59 new vulnerabilities in the three examined products.;1
Security metrics for source code structures;Software security metrics are measurements to assess security related imperfections (or perfections) introduced during software development. A number of security metrics have been proposed. However, all the perspectives of a software system have not been provided specific attention. While most security metrics evaluate software from a system-level perspective, it can also be useful to analyze defects at a lower level, i.e., at the source code level. To address this issue, we propose some code-level security metrics which can be used to suggest the level of security of a code segment. We provide guidelines about where and how these metrics can be used to improve source code structures. We have also conducted two case studies to demonstrate the applicability of the proposed metrics.;1
A UML-based static verification framework for security;Secure software engineering is a new research area that has been proposed to address security issues during the development of software systems. This new area of research advocates that security characteristics should be considered from the early stages of the software development life cycle and should not be added as another layer in the system on an ad-hoc basis after the system is built. In this paper, we describe a UML-based Static Verification Framework (USVF) to support the design and verification of secure software systems in early stages of the software development life-cycle taking into consideration security and general requirements of the software system. USVF performs static verification on UML models consisting of UML class and state machine diagrams extended by an action language. We present an operational semantics of UML models, define a property specification language designed to reason about temporal and general properties of UML state machines using the semantic domains of the former, and implement the model checking process by translating models and properties into Promela, the input language of the SPIN model checker. We show that the methodology can be applied to the verification of security properties by representing the main aspects of security, namely availability, integrity and confidentiality, in the USVF property specification language.;1
A framework for development of secure software;To design, build and deploy secure systems, we must integrate security into our application development life cycle and adapt current software engineering practices and methodologies to include specific security-related activities. Developers enforces security measures during design phase of software development processes which may end up in specifying security related architecture constraints that are not really necessary. To eliminate this problem, we propose a Framework for Security Engineering Process that involves converting security requirements and threats into design decisions to mitigate the identified security threats. The identified design attributes are prioritized and a security design template is prepared. We have stored various cryptographic techniques and their analytic attributes in the repository to find out the specific cryptographic technique that would eventually help in the later stages of the design process by eliminating unnecessary design constraints in a particular scenario.;1
Model-driven secure development lifecycle;Building security into software development lifecycles and doing it right is hard. To address the challenge, several prominent organizations have published process-oriented security guidelines to bring security activities into a structured way. Although these efforts contribute to measurable improvements in software and system security, they are often too verbose and fuzzy to be implementable in a development lifecycle involving people (e.g., security experts, developers, and managers) with different skillsets. In this paper, we propose the model-driven secure development lifecycle (MD-SDL), an approach that leverages on modeling methods and the advances in model-driven security to simplify the process of efficiently integrating security into development lifecycles for the development of security-critical software and systems.;1
The State of the Art on Secure Software Engineering: A Systematic Mapping Study;"Secure Software Development (SSD) is becoming a major challenge due to the increasing complexity openness and extensibility of Information and Communication Technologies (ICTs). These make the overall security requirements analysis very difficult. Many techniques have been theoretically developed however there is a lack of empirical evidence of its application in building secure software system. A Systematic Mapping Study (SMS) has been conducted in this paper to examine the existence of software security frameworks models and methods. In total we selected 116 primary studies. After examining the selected studies we identified 37 Secure Software Engineering (SSE) paradigms/frameworks/models. The results show that the most frequently used SSE frameworks/models are Microsoft Software Development Life Cycle (MS-SDL)"" ""Misuse case modeling"" ""Abuse case modeling"" ""Knowledge Acquisition for Automated Specification"" ""System Security Engineering-Capability Maturity Model (SSE-CMM)"" and ""Secure Tropos Methodology"". This work will help organizations in the development of software to better understand existing security initiatives used in the development of secure software. It can also provide researchers with a basis for designing and developing new methods of software security and identifying new axis of research.""";
Proceedings of the 24th International Conference on Evaluation and Assessment in Software Engineering;Building more secure software is a recent concern for software engineers due to increasing incidences of data breaches and other types of cyber attacks. However software security through the introduction of specialized practices in the software development life cycle leads to an increase in the development cost. Although there are many studies on software cost models few address the additional costs required to build secure software. We conducted a systematic review in the form of a mapping study to classify and analyze the literature related to the impact of security in software development costs. Our search strategy strove to achieve high completeness by the identification of a quasi-gold-standard set of papers which we then used to establish a search string and retrieve papers from research databases automatically. The application of inclusion/exclusion criteria resulted in a final set of 54 papers which were categorized according to the approach to software security cost analysis. Perform Security Review Apply Threat Modeling and Perform Security Testing were the three most frequent activities related to cost and Common Criteria was the most applied standard. We also identified ten approaches to estimating software security costs for development projects however their validation remains a challenge which could be addressed in future studies.;
Proceedings of the 14th International Conference on Availability Reliability and Security;Recent years have seen rapid increases in cybercrime. The use of effective software security activities plays an important part in preventing the harm involved. Objective research on industry use of software security practices is needed to help development teams academic researchers and educators to focus their activities.  Since 2008 a team of researchers including two of the authors has been gathering objective data on the use of 121 software security activities. The Building Security In Maturity Model (BSIMM) study explores the activity use of 675000 software developers in companies including some of the worldâ€™s largest and most security-focused.  Our analysis of the study data shows little consistent growth in security activity adoption industry-wide until 2015. Since then the data shows a strong increasing trend along with the adoption of new activities to support cloud-based deployment an emphasis on component security and a reduction in security professionalsâ€™ policing role. Exploring patterns of adoption activities related to detecting and responding to vulnerabilities are adopted marginally earlier than activities related to preventing vulnerabilities and activities related to particular job roles tend to be used together. We also found that 12 developer security activities are adopted early together and notably more often than any others.  From these results we offer recommendations for software and security engineers and corresponding education and research suggestions for academia. These recommendations offer a strong contribution to improving security in development teams in the future.;
Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;Software security is an important aspect that needs to be considered during the entire software development life cycle (SDLC). Integrating software security at each phase of SDLC has become an urgent need. To address software security various approaches techniques methods practices and models have been proposed and developed. However recent research shows that many software development methodologies do not explicitly include methods for incorporating software security during the development of software as it evolves from requirements engineering to its final disposal. The primary objective of this research is to study the state-of-the-art of security in the context of SDLC by following systematic mapping study (SMS). In the second phase we will identify through systematic literature review (SLR) and empirical study in the industry the software security contributions security challenges and their practices for global software development (GSD) vendors. The ultimate aim is to develop a Software Security Assurance Model (SSAM) to assist GSD vendor organisations in measuring their readiness towards the development of secure software.;
Proceedings of the 13th International Conference on Global Software Engineering;Application development for the cloud is already challenging because of the complexity caused by the ubiquitous interconnected and scalable nature of the cloud paradigm. But when modern secure and privacy aware cloud applications require the integration of cryptographic algorithms developers even need to face additional challenges: An incorrect application may not only lead to a loss of the intended strong security properties but may also open up additional loopholes for potential breaches some time in the near or far future. To avoid these pitfalls and to achieve dependable security and privacy by design cryptography needs to be systematically designed into the software and from scratch. We present a system architecture providing a practical abstraction for the many specialists involved in such a development process plus a suitable cryptographic software development life cycle methodology on top of the architecture. The methodology is complemented with additional tools supporting structured inter--domain communication and thus the generation of consistent results: cloud security and privacy patterns and modelling of cloud service level agreements. We conclude with an assessment of the use of the Cryptographic Software Design Life Cycle (CryptSDLC) in a EU research project.;
Proceedings of the 13th International Conference on Availability Reliability and Security;"It is our great pleasure to welcome you to the 3rd International Workshop on Software PROtection - SPRO-2019. For the third year this one-day workshop hopes to bring researchers and practitioners from academia and from industry together in Europe to focus on all matters relevant to the protection of software against man-at-the-end attacks.For this third edition we received eight papers from Europe and the United States of which six were selected for presentation and publication. The papers cover the research areas of reverse engineering protected code de-obfuscation with machine learning malware mutation virtualization obfuscation code guards and runtime verification. We are sure the six presentations spread over two research paper sessions will help you in acquiring new insights and will spark interesting discussions.We also encourage attendees to attend the two keynote presentations: one keynote from industry titled Modern Static Analysis of Obfuscated Code"" by Rusty Wagner (BinaryNinja - Vector35) and another keynote from academia titled ""Cheat Protection in Online Games"" by Stijn Volckaert (KU Leuven). Furthermore we look forward to the tutorial on the Ghidra open source reverse engineering tool that will be presented by Roman Rohleder (Thales Group).This valuable and insightful talk discussion and hands-on demonstration will guide us to a better understanding of the current state-of-the-art and of the challenges our community should focus and collaborate on in the near future.""";
A Preliminary Systematic Mapping on Software Engineering for Robotic Systems: A Software Quality Perspective;Robotic systems have been increasingly employed in everyday tasks. Considering that software plays a crucial point in robot systems to investigate how software engineering concepts in a software quality perspective can improve robotic systems. In this work we present a systematic mapping to identify and classify the state-of-art of software engineering for robotic systems in a quality software perspective. We selected and systematically analyzed a final set of 35 primary studies extracted from an automated search on Scopus digital library.This work presents three main contributions. Firstly we organize a catalogue of research studies about software engineering more specifically software quality applied in robotic systems. Next we systematically analyze software quality areas used in robotic systems. Finally we discuss insights into research opportunities and gaps in software engineering to robotic systems for future studies.As a result we observed that there are studies in the robotic systems area addressing in a combined way software engineering approaches and software quality aspects. The less investigated software quality aspect is security. Due to this fact we presented an overview of the state-of-art on blockchain applying in robotics systems. Blockchain brings opportunities for changing the ways that robots interact with humans. Finally we identify research opportunities and gaps in software quality on robotic systems presenting an overview for future studies.;
Proceedings of the IEEE/ACM 42nd International Conference on Software Engineering Workshops;Software Protection techniques aim to defend the confidentiality and integrity of software applications that are exposed to an adversary that shares the execution host and access privileges of the application. This scenario is often denoted as protection against MATE (Man-At-The-End) attacks. This is an area of growing importance for industry: in many cases the deployment of such techniques is crucial to ensure business continuity. Following the second SPRO workshop co-located with CCS-2016 in Vienna Austria this third edition aims to establish a tradition where academics and industrial experts in software protection can meet to confront the challenges in designing stronger protections and in developing better integration with industrial software development life cycle requirements.;
Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security;A common type of security analysis involves checking whether a system is capable of establishing a set of security requirements under a particular threat model. Building an accurate threat model however is a challenging task due to the uncertain and evolving nature of a malicious environment in which the system is deployed. In this paper as a complementary analysis we propose a systematic approach for evaluating the design of a system with respect to its robustness against an adversarial environment i.e. the degree of assumptions about attacker capabilities under which the system is capable of maintaining its security requirements. We argue that robustness is an important property that should be considered as part of any secure development process. In this paper we propose a formal definition of robustness and describe a technique for automatically evaluating the robustness of a system. We demonstrate potential applications of the robustness concept using an example involving the OAuth authentication protocol.;
Proceedings of the 3rd ACM SIGSOFT International Workshop on Software Security from Design to Deployment;Agile methods are becoming increasingly popular and compared to traditional methods offer higher adaptability quicker response to changing requirements and more efficient customer-developer collaboration throughout the entire software development process. However they may not be the best way for achieving satisfactory security of the developed software due to their focus on the functional requirements. To address this issue we developed a novel approach for achieving secure software with agile methods without adding unnecessary complexity or rigidity which is a key drawback of existing approaches eroding the agility. The proposed approach builds on delegation of responsibility for security generic security user stories and game of votes.;
Proceedings of the Third Central European Cybersecurity Conference;"Protecting software from illegal access intentional modification or reverse engineering is an inherently difficult practical problem involving code obfuscation techniques and real-time cryptographic protection of code. In traditional systems a secure element (the dongle"") is used to protect software. However this approach suffers from several technical and economical drawbacks such as the dongle being lost or broken.We present a system that provides such dongles as a cloud service and more importantly provides the required cryptographic material to control access to software functionality in real-time.This system is developed as part of an ongoing nationally funded research project and is now entering a first trial stage with stakeholders from different industrial sectors.""";
Proceedings of the 24th ACM Symposium on Access Control Models and Technologies;DLR as research organization increasingly faces the task to share its self-developed software with partners or publish openly. Hence it is very important to harden the softwares to avoid opening attack vectors. Especially since DLR software is typically not developed by software engineering or security experts. In this paper we describe the data-oriented approach of our new found secure software engineering group to improve the software development process towards more secure software. Therefore we have a look at the automated security evaluation of software as well as the possibilities to capture information about the development process. Our aim is to use our information sources to improve software development processes to produce high quality secure software.;
Proceedings of the 1st International Workshop on Security Awareness from Design to Deployment;Pushed by market forces software development has become fast-paced. As a consequence modern development projects are assembled from 3rd-party components. Security &amp privacy assurance techniques once designed for large controlled updates over months or years must now cope with small continuous changes taking place within a week and happening in sub-components that are controlled by third-party developers one might not even know they existed. In this paper we aim to provide an overview of the current software security approaches and evaluate their appropriateness in the face of the changed nature in software development. Software security assurance could benefit by switching from a process-based to an artefact-based approach. Further security evaluation might need to be more incremental automated and decentralized. We believe this can be achieved by supporting mechanisms for lightweight and scalable screenings that are applicable to the entire population of software components albeit there might be a price to pay.;
Proceedings of the 43rd International Conference on Software Engineering: New Ideas and Emerging Results;In the ASPIRE research project a software protection tool flow was designed and prototyped that targets native ARM Android code. This tool flow supports the deployment of a number of protections against man-at-the-end attacks. In this tutorial an overview of the tool flow will be presented and attendants will participate to a hands-on demonstration. In addition we will present an overview of the decision support systems developed in the project to facilitate the use of the protection tool flow.;
Proceedings of the 2016 ACM Workshop on Software PROtection;Today's software development projects need to consider security as one of the qualities the software should possess. However overspending on security will imply that the software will become more expensive and often also delayed. This paper discusses the role of objectivity in assessing and researching the goal of good enough security. Different understandings of objectivity are introduced and the paper explores how these can guide the way forward in improving judgements on what level of security is good enough. The paper recommends adopting and improving upon methods that include different perspectives support the building of interactive expertise and support confirmability by keeping documentation of the basis on which judgements were made.;
Proceedings of the 2021 European Symposium on Usable Security;The security of a company's software products is of paramount importance of course and arguably even more important than software reliability and the other key quality attributes. But companies are currently faced with a troublesome dilemma: Supplying customers with more features at greater speeds than in the past has become the norm high feature velocity fairly static engineering headcounts and shorter release cycles are conspiring to threaten both software reliability and security. The work described in this paper is an attempt to baseline and (internally) benchmark the state of our company's software security and also includes some data regarding the state of software reliability across the company's products. Of particular interest in this study is learning more about the extent of software vulnerabilities emanating from the open source software that we import and use in our commercial products. Prior evidence had been building that suggested that such `third-party software' (TPS) is inherently more vulnerable to security (and reliability) problems. We have examined the software vulnerability occurrences across all the company's software in the aggregate and have found that the TPS used in our products primarily open source software initially contains more vulnerabilities than internally-produced software. Security and reliability problems both in terms of bug counts and percentages of total code volume correlate quite well and examples of this are also shown but we cannot rely on this concurrence in our study: Software security on its own has been examined in detail and while some findings are documented here many questions remain.;
Proceedings of the 35th Annual ACM Symposium on Applied Computing;Security is an essential component of the software development lifecycle. Researchers and practitioners have developed educational interventions guidelines security analysis tools and new APIs aimed at improving security. However measuring any resulting improvement in secure development skill is challenging. As a proxy for skill we propose to measure self-efficacy which has been shown to correlate with skill in other contexts. Here we present a validated scale measuring secure software-development self-efficacy (SSD-SES). We first reviewed popular secure-development frameworks and surveyed 22 secure-development experts to identify 58 unique tasks. Next we asked 311 developers - over multiple rounds - to rate their skill at each task. We iteratively updated our questions to ensure they were easily understandable showed adequate variance between participants and demonstrated reliability. Our final 15-item scale contains two sub-scales measuring belief in ability to perform vulnerability identification and mitigation as well as security communications tasks.;
Proceedings of the 2020 CHI Conference on Human Factors in Computing Systems;The introduction of agile software development methods has brought about diverse benefits to the industry. These range from rapid deployment of software products to satisfying the ever changing customer requirements among others. These have in turn fueled the rapid adoption of these methodologies within the industry. On the down side agile approach has been proved to be weak in handling security and therefore not appropriate for developing secure systems. The framework we present in this paper addresses this by ensuring that security is in the development process from the beginning of the project to the end. It is modeled after the SSE-CMM as a standard for security engineering. Considering its process areas it aims to achieve the intended security goals within the agile process to appropriate levels by adopting agility in the implementation of these activities. The criteria of implementation are agility plus the SSE-CMM process areas goals. The framework is tested through a case study to check the capability levels achieved and the agility of the resultant process.;
Proceedings of the 11th International Conference on Information Communication and Management;Huge numbers of worldwide-deployed software suffer from poor quality and possess vulnerabilities with serious impact. Meanwhile people are using such software to save and manage their valuable information including their monetary data. This has increased the hackers' appetite to attack software. Henceforth researchers and practitioners are convinced that software security is not an added value or a gold-plating need. Consequently security requirements specification and implementation become vital during the software development process. Unfortunately researchers and practitioners are doing so in a rush. This has made them mix concepts and practices up in a way that can terribly make the problem of delivering software overdue more chronic which will result in a security and technical debt. This research represents a corrective study that sheds light on what has been achieved in analyzing and designing secure software and what are the problems committed and how to handle them.;
Proceedings of the New Security Paradigms Workshop 2020;Learning software security has become a complex and difficult task today than it was even a decade ago. With the increased complexity of computer systems and a variety of applications it is hard for software developers to master the expertise required to deal with the variety of security concepts methods and technologies that are required in software projects. Although a large number of security learning materials are widely available in books open literature or on the Internet they are difficult for learners to understand the rationale of security topics and correlate the concepts with real software scenarios. We argue that the traditional approach which usually organizes knowledge content topically with security-centric is not suitable to motivate learners and stimulate learners' interest. To tackle this learning issue our research is focused on forging a contextualized learning environment for software security where learners can explore security knowledge and relate it to the context that they are familiar with. This learning system is developed base on our proposed context-based learning approach and based on ontological technologies. In this paper we present our evaluation study in the open source software (OSS) development environment. Our results demonstrate that contextualized learning can help OSS developers identify their necessary security information improve learning efficiency and make security knowledge more meaningful for their software development tasks;
Proceedings of the 40th International Conference on Software Engineering;There has been a surge in number of software security threats and vulnerabilities in recent times. At the same time expectations towards software and data security are growing. Thus there is a need to ensure that security-related tasks are effectively integrated in the software development process. However integrating security practices with agile software development is not trivial due to for instance differences in process dynamics and concentration on functional vs non-functional requirements. In this short paper we present a literature review on challenges and solutions when adopting security in agile software development contexts. Our findings show that there are ongoing efforts to integrate security-practices in agile methods but more research is needed to make the processes more optimized and simpler for developers.;
Proceedings of the 19th International Conference on Agile Software Development: Companion;This case study addresses how we applied user centered design (UCD) to the software development lifecycle for the new City of Austin Utilities Online Customer Care website. The case study focuses on the use of personas prototypes and user testing discusses what worked well and provides lessons learned.;
CHI '12 Extended Abstracts on Human Factors in Computing Systems;Several disastrous security attacks can be attributed to delays in patching software vulnerabilities. While researchers and practitioners have paid significant attention to automate vulnerabilities identification and patch development activities of software security patch management there has been relatively little effort dedicated to gain an in-depth understanding of the socio-technical aspects e.g. coordination of interdependent activities of the patching process and patching decisions that may cause delays in applying security patches. We report on a Grounded Theory study of the role of coordination in security patch management. The reported theory consists of four inter-related dimensions i.e. causes breakdowns constraints and mechanisms. The theory explains the causes that define the need for coordination among interdependent software/hardware components and multiple stakeholdersâ€™ decisions the constraints that can negatively impact coordination the breakdowns in coordination and the potential corrective measures. This study provides potentially useful insights for researchers and practitioners who can carefully consider the needs of and devise suitable solutions for supporting the coordination of interdependencies involved in security patch management.;
Proceedings of the 14th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);In this work we provide a metric to calculate the most significant software security weaknesses as defined by an aggregate metric of the frequency exploitability and impact of related vulnerabilities. The Common Weakness Enumeration (CWE) is a well-known and used list of software security weaknesses. The CWE community publishes such an aggregate metric to calculate the â€˜Most Dangerous Software Errorsâ€™. However we find that the published equation highly biases frequency and almost ignores exploitability and impact in generating top lists of varying sizes. This is due to the differences in the distributions of the component metric values. To mitigate this we linearize the frequency distribution using a double log function. We then propose a variety of other improvements provide top lists of the most significant CWEs for 2019 provide an analysis of the identified software security weaknesses and compare them against previously published top lists.;
Proceedings of the 36th Annual Computer Security Applications Conference;Over the past 15 years the topic of information security economics has grown to become a large and diverse field influencing security thinking on issues as diverse as bitcoin markets and cybersecurity insurance. An aspect yet to receive much attention in this respect is that of secure software development or 'SWSec' --- another area that has seen a surge of research since 2000. SWSec provides paradigms practices and procedures that offer some promise to address current security problems yet those solutions face financial and technical barriers that necessitate a more thorough approach to planning and execution. Meanwhile information security economics has developed theory and practice to support a particular world-view however it has yet to account for the investments constructs and benefits of SWSec. As the frequency and severity of computer misuse has increased both areas have struggled to impart a new mindset for addressing the inherent issues that arise in a diverse connected and functionality-driven landscape.This paper presents a call for the establishment of an economics of secure software development. We present the primary challenges facing practice citing relevant literature from both communities to illustrate where commonalities lie --- and where further work is needed. Those challenges are decomposed into a research agenda deriving from the application of principles in both themes a lack of models representation and analysis in practice. A framework emerges that facilitates discussions of security theory and practice.;
Proceedings of the 2016 New Security Paradigms Workshop;Software security has been a subject of plethora studies for the past decades. A relatively large number of frameworks coding standards and guidelines have been developed and published by security committees in publications or on the internet. We argue that the huge mass of information has resulted in a form of information overload to software developers who come from many disciplines and have different levels of programming knowledge. We consider that the knowledge contents of software security should be organized as scaffold learning by breaking down complex materials into component parts. In this paper we present a concept map approach to model the knowledge of software security in a graphical and visualized format. The concept maps are constructed in accordance with the pre-developed software security domain model which reduces the difficulties and complexity in developing concept maps. For operationalization the proposed concept maps consider different learning preferences and form security metal models among developers.;
Proceedings of the 2nd International Conference on E-Society E-Education and E-Technology;"It is our great pleasure to welcome you to the 2nd International Workshop on Software PROtection -- SPRO'16. For the second year this one-day workshop hopes to bring researchers and practitioners from academies and from industry together in Europe to focus on all matters relevant to the protection of software against man-at-the-end attacks.For this second edition we received fourteen papers of which eight were eventually selected for presentation and publication. The papers cover the research areas of white-box cryptography integrity checking obfuscation and software vulnerabilities. We are sure the eight presentations spread over three research paper sessions will help you in acquiring new insights and will spark interesting discussions.We also encourage attendees to attend the keynote presentation titled Intel Software Guard Extensions - Introduction and Open Research Challenges"" by Matthias Schunter (Intel) as well as the panel (and public!) discussion on the topic ""Software Protection Research in Europe where are we going?"". Furthermore we look forward to the tutorial on the ASPIRE Framework for Software Protection that will be presented by the ASPIRE project consortium.This valuable and insightful talk discussion and hands-on demonstration will guide us to a better understanding of the current state-of-the-art and of the challenges our community should focus and collaborate on in the near future.""";
Applying Software Protection to White-Box Cryptography;White-box cryptography sits at the intersection of software protection and cryptography. Software protection is aimed at preventing attackers from modifying software or extracting secrets from it through reverse-engineering or other means. Software protection becomes white-box cryptography when it is applied to software implementations of cryptographic algorithms.;
Proceedings of the 5th Program Protection and Reverse Engineering Workshop;Existing anti-debugging protections are relatively weak. In existing self-debugger approaches a custom debugger is attached to the main application of which the control flow is obfuscated by redirecting it through the debugger. The coupling between the debugger and the main application is then quite loose and not that hard to break by an attacker. In the tightly-coupled self-debugging technique proposed in this paper full code fragments are migrated from the application to the debugger making it harder for the attacker to reverse-engineer the program and to deconstruct it into the original unprotected program to attach a debugger or to collect traces. We evaluate a prototype implementation on three complex real-world Android use cases and present the results of tests conducted by professional penetration testers.;
Proceedings of the 6th Workshop on Software Security Protection and Reverse Engineering;Many software services are currently created using DevOps where developers and operations personnel are more tightly integrated. The DevOps paradigm enables shorter development cycles but increased speed has raised concerns over whether security issues may be overlooked. However perfect security is never achievable and in addition to the proactive software security efforts we also need a reactive effort to handle flaws and bugs that are not discovered before they are used in an attack. In this paper we explore how focus on incident management and collaboration with developers can contribute to improved software security.;
Interventions for software security: creating a lightweight program of assurance techniques for developers;Though some software development teams are highly effective at delivering security others either do not care or do not have access to security experts to teach them how. Unfortunately these latter teams are still responsible for the security of the systems they build: systems that are ever more important to ever more people. We propose that a series of lightweight interventions six hours of facilitated workshops delivered over three months can improve a team's motivation to consider security and awareness of assurance techniques changing its security culture even when no security experts are involved. The interventions were developed after an Appreciative Inquiry and Grounded Theory survey of security professionals to find out what approaches work best. They were then validated in fieldwork with a Participatory Action Research study that delivered the workshops to three development organizations. This approach has the potential to be applied by many development teams improving the security of software worldwide.;
Proceedings of the 41st International Conference on Software Engineering: Software Engineering in Practice;Combining security engineering and software engineering is shaping the software development processes and shifting the emphasis of information security from the operation environment into the main information asset: the software itself. To protect software and data assets software development is subjected to an increasing amount of external regulation and organizational security requirements. To fulfill these requirements the practitioners producing secure software have plenty of models guidelines standards and security instructions to follow but very little scientific knowledge about effectiveness of the security they take.In this paper we present the current state of security engineering surveys and present results from our industrial survey (n = 62) performed in early 2018. The survey was conducted among selected software and security professionals employed by a selected set of 303 Finnish software companies. Results are compared to a commercial survey the BSIMM version 8 and the similarities and distinct differences are discussed. Also an analysis of the composition of security development life cycle models is presented suggesting regulation to be the driving force behind security engineering in software industry.;
Proceedings of the 8th International Conference on Security of Information and Networks;Software Protection techniques aim to defend the confidentiality and integrity of software applications that are exposed to an adversary that shares the execution host and access privileges of the application. This scenario is often denoted as protection against MATE (Man-At-The-End) attacks. This is an area of growing importance. For industry in many cases the deployment of such techniques is crucial to ensure business continuity. Following the first SPRO workshop co-located with ICSE 2015 in Florence Italy this second edition aims to establish a tradition where academics and industrial experts in software protection can meet to confront the challenges in designing stronger protections and in developing better support to deploy those protections and to make them compatible with industrial software development life cycle requirements.;
Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security;This paper considers the pure software solution to security. It compares the advantages and disadvantages of this approach to a range of solutions supported by hardware extensions to processors.;
Proceedings of the 1st International Workshop on Software Protection;We present the EU FP7 ASPIRE project with a focus on its design of a decision support system that will enable non-expert users to configure a complex software protection tool chain to protect the assets in their software.;
Proceedings of the 24th Conference on Pattern Languages of Programs;This paper proposes network security enhancement solution aiming to improving the level of performance in the detection of cyber-attacks on Software Defined Network (SDN) it will prevent against Denial of Service Attack. We are going to employ two solution and comparing on the SDN attack detection performance. The first approach is the performance accuracy of the SDN with IDS procedural and the second approach is the integration of SDN with Machine Learning. The project serves the organization generally in the field of information security network security and cybersecurity awareness. The system performance evaluation results prove the system is capable to provide the effective DDoS attack detection and provide security enhancement in Software Defined Network.;
Proceedings of the 4th International Conference on Future Networks and Distributed Systems;The 4+1 principles document common principles of software safety assurance that can be observed from software safety standards and best practice. These principles are constant across domains and across projects and can be regarded as the immutable core of any software safety justification. The principles also help maintain understanding of the 'big picture' of software safety issues whilst examining and negotiating the detail of individual standards and provide a reference model for cross-sector certification. This document discusses the challenges posed when applying these principles to Scrum and makes initial recommendations for how the principles can be accommodated within a Scrum development.;
Proceedings of the Scientific Workshop Proceedings of XP2016;Security is an important software quality attribute albeit as a nonfunctional requirement often overlooked. Although several approaches for security requirements engineering exist it is not clear how to adapt security requirements to software end users. This poster aims to fill in this gap by developing a novel approach for acquiring security requirements by leveraging end user analysis and a security body of knowledge. To achieve this aim we divide security requirements into two categories. Software security requirements are those that need to be technically implemented in the developed software. Training security requirements are those that aim to provide the necessary training to the end users that need it. The proposed approach may help security experts in security requirements engineering tailored to the characteristics of end users.;
Proceedings of the 2020 European Interdisciplinary Cybersecurity Conference;Lack of security expertise among software practitioners is a problem with many implications. First there is a deficit of security professionals to meet current needs. Additionally even practitioners who do not plan to work in security may benefit from increased understanding of security. The goal of this paper is to aid software engineering educators in designing a comprehensive software security course by sharing an experience running a software security course for the eleventh time. Through all the eleven years of running the software security course the course objectives have been comprehensive - ranging from security testing to secure design and coding to security requirements to security risk management. For the first time in this eleventh year a theme of the course assignments was to map vulnerability discovery to the security controls of the Open Web Application Security Project (OWASP) Application Security Verification Standard (ASVS). Based upon student performance on a final exploratory penetration testing project this mapping may have increased students' depth of understanding of a wider range of security topics. The students efficiently detected 191 unique and verified vulnerabilities of 28 different Common Weakness Enumeration (CWE) types during a three-hour period in the OpenMRS project an electronic health record application in active use.;
Proceedings of the 43rd International Conference on Software Engineering: Joint Track on Software Engineering Education and Training;This paper provides an approach to address the secure software update weakness in the car Infotainment software. It elaborates the importance of software update and the recent happenings that showcase the vulnerabilities in the process and practice by car manufactures. It also discusses on the effort by industry alliance to address the challenges by the growth in software percentage in the passenger vehicles. The paper highlights how a combination of secure software update approaches in the automotive and consumer electronic devices industry can be solution to the problems and challenges faced by the car manufactures.;
Proceedings of the 10th Innovations in Software Engineering Conference;Virtualization is becoming a prominent field of research not only in distributed systems but also in software protection and obfuscation. Software virtualization has given rise to advanced techniques that may provide intellectual property protection and anti-cloning resilience. We present results of an empirical study that answers whether integrity of execution can be preserved for process-level virtualization protection schemes in the face of adversarial analysis. Our particular approach considers exploits that target the virtual execution environment itself and how it interacts with the underlying host operating system and hardware. We give initial results that indicate such protection mechanisms may be vulnerable at the level where the virtualized code interacts with the underlying operating system. The resolution of whether such attacks can undermine security will help create better detection and analysis methods for malware that also employ software virtualization. Our findings help frame research for additional mitigation techniques using hardware-based integration or hybrid virtualization techniques that can better defend legitimate uses of virtualized software protection.;
Proceedings of the 4th Program Protection and Reverse Engineering Workshop;Learning software security is a big challenging task in the information technology sector due to the vast amount of security knowledge and the difficulties in understanding the practical applications. The traditional teaching and learning materials which are usually organized topically and security-centric have fewer linkages with learners' experience and prior knowledge that they bring to the learning sessions. Learners often do not associate vulnerabilities or coding practices with programs similar to what they were writing in their previous time. Consequently their motivation for learning is not touched by conventional methods. The aim of this paper is the presentation of an ontology-based learning system for software security with contextualized learning approaches and of the results of an initial evaluation using a controlled quasi-experiment in a university learning environment. This system facilitates the contextual learning process by providing contextualized access to security knowledge via real software application scenarios in which learners can explore and relate the security knowledge to the context they are already familiar with. The experiment results show that the prototyped system with the proposed learning approach not only yields significant knowledge gain compared to the conventional learning approach but also gains better learning satisfaction of students.;
Proceedings of the 23rd International Conference on Evaluation and Assessment in Software Engineering;The DevOps paradigm means that development and operations for an organisation blend together. For security this implies that information on detected attacks can be fed back to the development enabling faster eradication of vulnerabilities in software. This is particularly important in cloud installations where release cycles can be less than a day. This paper argues that DevOps can be employed for overall improved software security.;
Proceedings of the 12th International Conference on Availability Reliability and Security;When studying work practices it is important to obtain accurate and reliable information about how work is actually done. Action research is an interactive inquiry process that balances problem solving actions implemented in a collaborative context with data-driven collaborative analysis or research to understand underlying causes enabling future predictions about personal and organizational change. Our research team has been engaged in action research in software organizations in Norway for two years. In this paper we describe some of the challenges in performing canonical action research in software security. We have structured the discussion of the challenges based on the principles of canonical action research and we draw some lessons learned and future work towards improving the adoption of action research in software security research.;
Proceedings of the 5th Annual Symposium and Bootcamp on Hot Topics in the Science of Security;The analysis of binary code is a common step of Man-At-The-End attacks to identify code sections crucial to implement attacks such as identifying private key hidden in the code identifying sensitive algorithms or tamper with the code to disable protections (e.g. license checks or DRM) embedded in binary code or use the software in an unauthorized manner. Code Mobility can be used to thwart code analysis and debugging by removing parts of the code from the deployed software program and installing it at run-time by downloading binary code blocks from a trusted server. The proposed architecture of the code mobility protection downloads mobile code blocks which are allocated dynamically at addresses determined at run-time control transfers into and out of mobile code blocks are rewritten using the Diablo binary-rewriter tool.;
Proceedings of the Second ACM Workshop on Moving Target Defense;On behalf of the entire workshop committee it is our great pleasure to welcome you to the Third International Workshop on Software Security from Design to Deployment (SEAD) held on November 9 2020 and co-located with the ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE) 2020.;
Measuring Software Security from the Design of Software;With the increasing use of mobile phones in contemporary society more and more networked computers are connected to each other. This has brought along security issues. To solve these issues both research and development communities are trying to build more secure software. However there is the question that how the secure software is defined and how the security could be measured. In this paper we study this problem by studying what kinds of security measurement tools (i.e. metrics) are available and what these tools and metrics reveal about the security of software. As the result of the study we noticed that security verification activities fall into two main categories evaluation and assurance. There exist 34 metrics for measuring the security from which 29 are assurance metrics and 5 are evaluation metrics. Evaluating and studying these metrics lead us to the conclusion that the general quality of the security metrics are not in a satisfying level that could be suitably used in daily engineering work flows. They have both theoretical and practical issues that require further research and need to be improved.;
Proceedings of the 18th International Conference on Computer Systems and Technologies;The integration of usability activities into software development lifecycles still remains to be a challenge. Most of the existing integration approaches appear to be on an operational level and cannot be transferred to other processes. Furthermore UE standards and methods are hardly applied. How can organizations be supported in understanding and using this existing knowledge? The approach in this paper focuses on the constellation of standards to integrate UE and SE. Therefore current development processes and standards will be analyzed and discussed to formulate recommendations for activities. In this manner a toolset will be established to support the selection of suitable methods the documentation and communication of intermediary results as well as the definition of competencies.;
Proceedings of the 4th ACM SIGCHI Symposium on Engineering Interactive Computing Systems;Google Search is where most developers start their Web journey looking for code examples to reuse. It is highly likely that code that is linked to the top results will be among those candidates that find their way into production software. However as a large amount of secure and insecure code has been identified on the Web the question arises how the providing webpages are ranked by Google and whether the ranking has an effect on software security. We investigate how secure and insecure cryptographic code examples from Stack Overflow are ranked by Google Search. Our results show that insecure code ends up in the top results and is clicked on more often. There is at least a 22.8% chance that one out of the top three Google Search results leads to insecure code. We introduce security-based re-ranking where the rank of Google Search is updated based on the security and relevance of the provided source code in the results. We tested our re-ranking approach and compared it to Google's original ranking in an online developer study. Participants that used our modified search engine to look for help online submitted more secure and functional results with statistical significance. In contrast to prior work on helping developers to write secure code security-based re-ranking completely eradicates the requirement for any action performed by developers. Our intervention remains completely invisible and therefore the probability of adoption is greatly increased. We believe security-based re-ranking allows Internet-wide improvement of code security and prevents the far-reaching spread of insecure code found on the Web.;
Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security;Massively Open Online Courses (MOOCs) provide a unique opportunity to reach out to students who would not normally be reached by alleviating the need to be physically present in the classroom. However teaching software security coursework outside of a classroom setting can be challenging. What are the challenges when converting security material from an on-campus course to the MOOC format? The goal of this research is to assist educators in constructing software security coursework by providing a comparison of classroom courses and MOOCs. In this work we compare demographic information student motivations and student results from an on-campus software security course and a MOOC version of the same course. We found that the two populations of students differed with the MOOC reaching a more diverse set of students than the on-campus course. We found that students in the on-campus course had higher quiz scores on average than students in the MOOC. Finally we document our experience running the courses and what we would do differently to assist future educators constructing similar MOOC's.;
Proceedings of the 38th International Conference on Software Engineering Companion;There are many reasons to protect software: your banking app needs to be protected to prevent fraud software operating on critical infrastructures needs to be protected against vulnerability discovery software vendors and service companies need it to protect their business etc. In the past decade many techniques to protect software have been presented ... and broken. Beyond making individual techniques better the challenge includes to be able to deploy them in practice and be able to evaluate them. This is the objective of SPRO the first International Workshop on Software Protection: to bring together researchers and industrial practitioners both from software protection and the wider software engineering community to share experience and provide directions for future research in order to stimulate the use of software engineering techniques in novel aspects of software protection. This first edition of the workshop is held at ICSE 2015 in Florence (Italy) with the aim of creating a community working in this new growing area of security and to highlight its synergies with different research fields of software engineering like: formal models program analysis reverse engineering code transformations empirical evaluation and software metrics. This paper presents the research themes and challenges of the workshop describes the workshop organization and summarizes the research papers.;
Proceedings of the 37th International Conference on Software Engineering - Volume 2;Both academia and industry advocate the security by design principle to stress the importance of dealing with security from the earliest stages in software development. Nevertheless designers often have to resort to their own knowledge and experience to pro-actively identify and mitigate potential security problems. Moreover research shows that correctly applying security solutions is a much more significant challenge for designers rather than finding an adequate solution. Therefore there is a need for techniques that ensure a correct application of a security design solution. The contribution of this paper is a model in which the security-relevant aspects of a design can be precisely expressed in an integrated manner enabling thorough reasoning about these aspects. We illustrate this model with a sizeable model of a banking system and show how the precise semantics of this model enables the tool-supported construction of proofs about the correctness of the applied design solutions. Our proposal thus enables designers to obtain stronger guarantees ensuring the correctness of their solutions. The presented model can serve as the foundation for security by design in time enabling automated security verification throughout the software development cycle.;
Proceedings of the 5th International FME Workshop on Formal Methods in Software Engineering;To improve the security of computer systems information and the cyber space it is critical to engineer more secure software. To develop secure and reliable software software developers need to have the mindset of an attacker. Attack patterns such as CAPEC are valuable resources to help software developers to think like an attacker and have the potential to be used in each phase of the secure software development life cycle. However systematic processes or methods for utilizing existing attack pattern resources are needed. As a first step this paper describes our ongoing effort of developing a tool to retrieve relevant CAPEC attack patterns for software development. This tool can retrieve attack patterns most relevant to a particular STRIDE type as well as most useful to the software being developed. It can be used in conjunction with the Microsoft SDL threat modeling tool. It also allows developers to search for CAPEC attack patterns using keywords.;
Proceedings of the 9th Annual Cyber and Information Security Research Conference;Using scientific disciplines as inspiration some researchers have called for the creation of general theories for software engineering. I present a contrary view drawing on recent work in the philosophy of engineering. Engineering theories are different to scientific theories and are not judged by the same criteria. Software engineering researchers should strive to create valid theories about the uses of software-based systems even if that leads to a multitude of theories that have narrow overlapping scopes are approximate and have little explanatory power. The engineering imperative is that the predictions of software engineering theories should be consistent with actual behaviour of software-based systems and that theories and should support assurances and explicit justification that systems will meet their requirements. Process theories are about the organisation of work and project management and are relevant to cost and schedule requirements in software engineering. However to directly provide evidence that software-based systems meet their main functional and non-functional requirements software engineering researchers should focus on product theories about the specifications designs code and behaviours of software-based systems.;
Proceedings of the Fourth SEMAT Workshop on General Theory of Software Engineering;Since Gamma et al. published their design patterns patterns are very popular in the area of software engineering. They provide best practice to handle recurring problems during the software development phase. Three years later security patterns appeared and provided solutions for security problems. Besides the name analogy design and security patterns should be very similar except for the security factor. In research and industry software engineering with design patterns is widespread. However some researchers suspect that security-pattern engineering is made difficult by some issues such as terminology or description form. Detecting adoption problems can help to improve security patterns in future. Thus they can promote the awareness of security especially in the software maintenance phase where many programmers first give attention to security problems. Therefore we will compare design and security patterns to find indicators for negative impact on security pattern engineering in software development. We address this issue on inspecting the aspects classification description form provided code examples and usage in the software life-cycle. We determine the degree of maturity of software-security patterns by comparing them to the well-explored design patterns. To achieve the objective we inspect the pattern terminology and conducted a study on the used description forms including provided UML diagrams and code examples. Moreover a literature review is conducted to compare their state of research w.r.t. the software life-cycle. The maturity degree of security patterns compared to common design patterns differs and we depict further research opportunities on security patterns.;
Proceedings of the 20th European Conference on Pattern Languages of Programs;It is within highly integrated technology environments that information security is becoming a focal point for designing developing and deploying software applications. Ensuring a high level of trust in the security and quality of these applications is crucial to their ultimate success. Information security has therefore become a core requirement for software applications driven by the need to protect critical assets and the need to build and preserve widespread trust in computing. The aim of this paper is to provide guidance to software designers and developers by defining a set of guidelines for secure software development. The guidelines established are based on various internationally recognised standards and best practices and some of the processes developed by many key role players.;
Proceedings of the 2008 Annual Research Conference of the South African Institute of Computer Scientists and Information Technologists on IT Research in Developing Countries: Riding the Wave of Technology;This paper explores the use of domain-specific languages for improving software security which deals with developing software in a way that is not maliciously exploitable. Specifically we demonstrate how modular extension of the C programming language can help with technical and process-related aspects of software security. Some of these examples are already implemented some are analytical extrapolations from related work we have done in the past a detailed empirical evaluation has not yet been done. We rely on mbeddr an extensible version of C developed with the JetBrains MPS language workbench. We conclude the paper with a discussion of the potential drawbacks of the approach and how these can be addressed in the future.;
Proceedings of the Workshop on Domain-Specific Modeling;"Where do security technologies come from? Academics propose research and government (sometimes) funds it. Startups move technologies across the research valley of death"" to early adopters. Global corporations make technology widely available by acquiring startups. At every step there are gaps and pitfalls. Adoption is the acid test of innovation. Idea-generation is perhaps ten per cent of innovation most of the work is on technology transfer and adoption. Chance plays a big role in creating opportunities (e.g. R&ampD involves a lot of luck) but a company's success depends on its ability to make opportunities more likely to occur and to capitalize on those opportunities when they arise. Passionate individuals drive technology transfer more than does process indeed some people believe that the original researchers need to be involved all the way along the chain. Prototyping is an important practice often resulting in ""researchware"" that proves a concept but is not ready for wide use. Transforming a prototype from the lab to the real-world is a multi-stage multi-year undertaking.This talk will use the decade-long evolution of static analysis in code review as a driver for discussion. We'll talk startups big companies venture capital research agencies and subject-matter expertise. In general technologists don't appreciate business people enough and business people don't appreciate technology enough. Most successful companies are brilliant at one but also need to be adequate at the other.""";
Proceedings of the Companion Publication of the 2014 ACM SIGPLAN Conference on Systems Programming and Applications: Software for Humanity;A program exhibits trigger-based behavior if it performs undocumented often malicious functions when the environmental conditions and/or specific input values match some pre-specified criteria. Checking whether such hidden functions exist in the program is important for increasing trustworthiness of software. In this paper we propose a framework to effectively detect trigger-based behavior at the source code level. Our approach is semi-automated: We use automated source code instrumentation and mixed concrete and symbolic execution to generate potentially suspicious test cases that may trigger hidden potentially malicious functions. The test cases must be investigated by a human analyst manually to decide which of them are real triggers. While our approach is not fully automated it greatly reduces manual work by allowing analysts to focus on a few test cases found by our automated tools.;
Proceedings of the 50th Annual ACM Southeast Conference;The commodity status of Field Programmable Gate Arrays (FPGAs) has allowed computationally intensive algorithms such as cryptographic protocols to take advantage of faster hardware speed while simultaneously leveraging the reconfigurability and lower cost of software. Numerous security applications have been transitioned into FPGA implementations allowing security applications to operate at real-time speeds such as firewall and packet scanning on high speed networks. However the utilization of FPGAs to directly secure software vulnerabilities is seemingly non-existent.Protecting program integrity and confidentiality is crucial as malicious attacks through injected code are becoming increasingly prevalent. This paper lays the foundation of continuing research in how to protect software by partitioning critical sections using reconfigurable hardware. This approach is similar to a traditional coprocessor approach to scheduling opcodes for execution on specialized hardware as opposed to running on the native processor. However the partitioned program model enables the programmer the ability to split portions of an application to reconfigurable hardware at compile time. The fundamental underlying hypothesis is that synthesizing portions of programs onto hardware can mitigate potential software vulnerabilities. Further this approach provides an avenue for randomization or diversity for software layout and circuit variation.;
Proceedings of the First ACM Workshop on Moving Target Defense;In organizations that use DevOps practices software changes can be deployed as fast as 500 times or more per day. Without adequate involvement of the security team rapidly deployed software changes are more likely to contain vulnerabilities due to lack of adequate reviews. The goal of this paper is to aid software practitioners in integrating security and DevOps by summarizing experiences in utilizing security practices in a DevOps environment. We analyzed a selected set of Internet artifacts and surveyed representatives of nine organizations that are using DevOps to systematically explore experiences in utilizing security practices. We observe that the majority of the software practitioners have expressed the potential of common DevOps activities such as automated monitoring to improve the security of a system. Furthermore organizations that integrate DevOps and security utilize additional security activities such as security requirements analysis and performing security configurations. Additionally these teams also have established collaboration between the security team and the development and operations teams.;
Proceedings of the International Workshop on Continuous Software Evolution and Delivery;Process-level Virtual machines (PVMs) often play a crucial role in program protection. In particular virtualization-based tools like VMProtect and CodeVirtualizer have been shown to provide desirable obfuscation properties (i.e. resistance to disassembly and code analysis). To be efficient many tools cache frequently-executed code in a code cache. This code is run directly on hardware and consequently may be susceptible to unintended malicious modification after it has been generated.To thwart such modifications this work presents a novel methodology that imparts tamper detection at run time to PVM-protected applications. Our scheme centers around the run-time creation of a network of software knots (an instruction sequence that checksums portions of the code) to detect tamper. These knots are used to check the integrity of cached code although our techniques could be applied to check any software-protection properties. Used in conjunction with established static techniques our solution provides a mechanism for protecting PVM-generated code from modification.We have implemented a PVM system that automatically inserts code into an application to dynamically generate polymorphic software knots. Our experiments show that PVMs do indeed provide a suitable platform for extending guard protection without the addition of high overheads to run-time performance and memory. Our evaluations demonstrate that these knots add less than 10% overhead while providing frequent integrity checks.;
Proceedings of the 2nd ACM SIGPLAN Program Protection and Reverse Engineering Workshop;Diversification and obfuscation methods are promising approaches used to secure software and prevent malware from functioning. Diversification makes each software instance unique so that malware attacks cannot rely on the knowledge of the program's execution environment and/or internal structure anymore. We present a systematic literature review on the state of-the-art of diversification and obfuscation research aiming to improve software security between 1993 and 2014. As the result of systematic search in the final phase 209 related papers were included in this study. In this study we focus on two specific research questions: what are the aims of diversification and obfuscation techniques and what are the environments they are applied to. The former question includes the languages and the execution environments that can benefit from these two techniques while the second question presents the goals of the techniques and also the type of attacks they mitigate.;
Proceedings of the 17th International Conference on Computer Systems and Technologies 2016;For computer software our security models policies mechanisms and means of assurance were primarily conceived and developed before the end of the 1970's. However since that time software has changed radically: it is thousands of times larger comprises countless libraries layers and services and is used for more purposes in far more complex ways. As a consequence it is necessary to revisit many of our core computer security concepts. For example it is unclear how the Principle of Least Privilege can be applied to set security policy when software is too complex for either its developers or its users to explain its intended behavior in detail.One possibility is to take an empirical data-driven approach to modern software and determine its exact concrete behavior via comprehensive online monitoring. Such an approach can be a practical effective basis for security--as demonstrated by its success in spam and abuse fighting--but its use to constrain software behavior raises many questions. In particular two questions seem critical. First is it possible to learn the details of how software *is* behaving without intruding on the privacy of its users' Second are those details a good foundation for deriving security policies that constrain how software *should* behave? This talk answers both these questions in the affirmative as part of an overall approach to data-driven security. It also considers what hardware support is necessary to perform comprehensive software monitoring with privacy and without prohibitive overhead.;
Proceedings of the 2017 Workshop on Attacks and Solutions in Hardware Security;"Stack canaries are a well-known and effective technique for detecting and defeating stack overflow attacks. However they are not perfect. For programs compiled using gcc the reference canary value is randomly generated at program invocation and fixed throughout execution. Moreover for software running on the Linux operating system canary values are inherited from the parent process and only changed if/when the child process exec()s a different program. Researchers and others have exploited these behaviors to craft real-world attacks that bypass the protections of stack canaries. This paper describes a moving-target stack canary technique that prevents such attacks. The Dynamic Canary Randomization technique (DCR) rerandomizes stack canaries at runtime. DCR is applied directly to the binary using a static binary rewriter (i.e. it does not require access to the program's source code). DCR operates with minimal overhead and gives the user the flexibility to specify the conditions under which to rerandomize the canary. DCR is an improvement over existing canary rerandomizers because it allows rerandomization to be applied at any point during execution and at any frequency. We show that DCR improves software security by demonstrating its ability to prevent real-world attacks on well-known software (e.g. nginx) protected"" by traditional stack canaries.""";
Proceedings of the 11th Annual Cyber and Information Security Research Conference;In this case study we examine software safety risk in three flight hardware systems in NASA's Constellation spaceflight program. We applied our Technical and Process Risk Measurement (TPRM) methodology to the Constellation hazard analysis process to quantify the technical and process risks involving software safety in the early design phase of these projects. We analyzed 154 hazard reports and collected metrics to measure the prevalence of software in hazards and the specificity of descriptions of software causes of hazardous conditions. We found that 49-70% of 154 hazardous conditions could be caused by software or software was involved in the prevention of the hazardous condition. We also found that 12-17% of the 2013 hazard causes involved software and that 23-29% of all causes had a software control. The application of the TRPM methodology identified process risks in the application of the hazard analysis process itself that may lead to software safety risk.;
Proceedings of the 33rd International Conference on Software Engineering;"Widely publicized breaches regularly occur involving insecure software. This is due to the fact that the vast majority of software in use today was not designed to withstand attacks encountered when deployed on hostile networks such as the Internet. What limited vulnerability statistics that exist confirm that most modern software includes coding flaws and design errors that put sensitive customer data at risk. Unfortunately security officers and software project owners still struggle to justify investment to build secure software. Initial efforts to build justification models have not been embraced beyond the most security conscious organizations. Concepts like the Rugged Software"" are gaining traction but have yet to make a deep impact. How does an organization - short of a breach - justify expending critical resources to build more secure software? Is it realistic to believe that an industry-driven solution such as the Payment Card Industry's Data Security Standard (PCI-DSS) can drive secure software investment before headlines prompt government to demand top-down regulation to ""fix"" the security of software?This presentation will attempt to characterize the current landscape of software security from the perspective of a practitioner who regularly works with Fortune 500 chief security officers to build business cases for software security initiatives. Given the current status of software security efforts and the struggles for business justification industry would be well-served to look further afield to other competing models to identify future justification efforts. There is still much that can be learned from models outside the security and information technology fields. For example the history of food safety provides lessons that the software security industry can draw from when developing justification models. We can also learn from building code adoption by earthquake-prone communities and draw comparisons to communities that have less rigorous building codes. Finally we can learn much from certain financial regulations that have or have not improved confidence in our financial system.""";
Proceedings of the First ACM Conference on Data and Application Security and Privacy;Industrial Internet of Things (IIoT) application provide a whole new set of possibilities to drive efficiency of industrial production forward. However with the higher degree of integration among systems comes a plethora of new threats to the latter as they are not yet designed to be broadly reachable and interoperable. To mitigate these vast amount of new threats systematic and automated test methods are necessary. This comprehensiveness can be achieved by thorough threat modeling. In order to automate security test we present an approach to automate the testing process from threat modeling onward closing the gap between threat modeling and automated test case generation.;
Proceedings of the Third ACM SIGPLAN Workshop on Programming Languages and Analysis for Security;Security patterns describe best practices to handle recurring security problems. Patterns are presented with a special description form that depicts the pattern's specific properties. A description form consists of different sections such as Motivation Problem or Solution. Many security patterns exist and their description forms are very different. This heterogeneity is a problem for comparing security patterns their comprehension and application in the software design and usage in tools that should support their selection in the software development process. Some researchers desire a unique description form and others suggest description forms with new sections that capture security-specific aspects. In order to assess whether additional security-specific facets are actually needed we assess existing descriptions of software-security patterns in depth. We compare the sections of software-security patterns publications to the common GoF and POSA design pattern templates to identify additionally used sections. Moreover we align these additionally used sections of software-security patterns to the sections of the aforementioned description forms. Finally we scan the additional sections to identify sections that possibly capture security-specific properties.;
Proceedings of the 19th European Conference on Pattern Languages of Programs;Microsoft is developing wide-spread software solutions like the Windows operating system and the Office suite. In order to improve security of their products they have introduced the Microsoft Security Development Lifecycle (MS-SDL). Ample documentation about the MS-SDL is available thus allowing other companies to adopt the lifecycle as well. We were wondering whether an adoption of the lifecycle is possible and useful for real small development teams e.g. for a single developing person. In order to find out we have done a practical test i.e. we have used the MS-SDL for the development of a small but real-world software project. The findings will be presented in this paper.;
Proceedings of the 13th International Conference on Information Integration and Web-Based Applications and Services;The use of Evolutionary Algorithms (EAs) is one method for securing software configurations in a changing environment. Using this approach configurations are modeled as biological chromosomes and a continual sequence of selection recombination and mutation processes is performed. While this approach can evolve secure configurations based on current conditions it is also possible to inadvertently lose solutions to previous threats during the evolution process. This paper improves the performance of EA-based configuration management by incorporating parameter-setting history. Over the generations (EA iterations) counts are maintained regarding the parameter-settings and the security of the configuration. Probability densities are then developed and used during mutation to encourage the selection of previously secure settings. As a result these secure settings are likely to be maintained as attacks alternate between vulnerabilities. Experimental results using configuration parameters from RedHat Linux installed Apache web-servers indicate the addition of parameter history significantly improves the ability to maintain secure settings as an attacker alternates between different threats.;
Proceedings of the 2015 Workshop on Automated Decision Making for Active Cyber Defense;"The use of virtual machine technology has become a popular approach for defending software applications from attacks by adversaries that wish to compromise the integrity and confidentiality of an application. In addition to providing some inherent obfuscation of the execution of the software application the use of virtual machine technology can make both static and dynamic analysis more difficult for the adversary. However a major point of concern is the protection of the virtual machine itself. The major weakness is that the virtual machine presents a inviting target for the adversary. If an adversary can render the virtual machine ineffective they can focus their energy and attention on the software application. One possible approach is to protect the virtual machine by composing or nesting virtualization layers to impart virtual machine protection techniques to the inner virtual machines closest"" to the software application. This paper explores the concept and feasibility of nested virtualization for software protection using a high-performance software dynamic translation system. Using two metrics for measuring the strength of protection the preliminary results show that nesting virtual machines can strengthen protection of the software application. While the nesting of virtual machines does increase run-time overhead initial results indicate that with careful application of the technique run-time overhead could be reduced to reasonable levels.""";
Proceedings of the 2009 ACM Symposium on Applied Computing;We report on a preliminary case study to examine software safety risk in the early design phase of the NASA Constellation spaceflight program. Our goal is to provide NASA quality assurance managers with information regarding the ongoing state of software safety across the program. We examined 154 hazard reports created during the preliminary design phase of three major flight hardware systems within the Constellation program. Our purpose was two-fold: 1) to quantify the relative importance of software with respect to system safety and 2) to identify potential risks due to incorrect application of the safety process deficiencies in the safety process or the lack of a defined process. One early outcome of this work was to show that there are structural deficiencies in collecting valid safety data that make software safety different from hardware safety. In our conclusions we present some of these deficiencies.;
Proceedings of the 2010 ACM-IEEE International Symposium on Empirical Software Engineering and Measurement;A method of creating tamper resistant software that is resistant to unauthorized modification is proposed. It utilizes a primitive that combines self-modifying based instruction camouflage and self integrity verification and a method to construct a structure in which the multiple primitives are interlocked each other. Tamper resistant software created by the proposed method contains multiple camouflaged instructions in the object program so that it is difficult for attacker to correctly understand the content of processing using static analysis. When attacker tries to do dynamic analysis anti-debugging techniques prevent the attempt. The tamper resistant software at runtime continuously executes detecting and preventing dynamic analysis verifying its integrity and self-modifying itself in such a way that target of self-modifying is dynamically determined according to result of self integrity verification. If unauthorized modification is detected then it self-modifies a part of instruction which is different from the part of camouflaged instruction to be self-modified and executes different instructions from its original. As a result it generates a series of unpredictable abnormal self destructive behaviors such as error or termination so that attacker's analysis and modification are strongly disturbed. Cost of analysis is increased as the numbers of self integrity verification and instruction camouflage are increased hence the tamper resistance can be strengthened quantitatively.;
Proceedings of the 6th ACM Symposium on Information Computer and Communications Security;Self-checksumming (SC) is a tamper-proofing technique that ensures certain program segments (code) in memory hash to known values at runtime. SC has few restrictions on application and hence can protect a vast majority of programs. The code verification in SC requires computation of the expected hashes after compilation as the machine-code is not known before. This means the expected hash values need to be adjusted in the binary executable hence combining SC with other protections is limited due to this adjustment step. However obfuscation protections are often necessary as SC protections can be otherwise easily detected and disabled via pattern matching. In this paper we present a layered protection using virtualization obfuscation yielding an architecture-agnostic SC protection that requires no post-compilation adjustment. We evaluate the performance of our scheme using a dataset of 25 real-world programs (MiBench and 3 CLI games). Our results show that the SC scheme induces an average overhead of 43% for a complete protection (100% coverage). The overhead is tolerable for less CPU-intensive programs (e.g. games) and when only parts of programs (e.g. license checking) are protected. However large overheads stemming from the virtualization obfuscation were encountered.;
Proceedings of the 3rd ACM Workshop on Software Protection;All kinds of human factors can deeply affect the results and efficiency of software risk management. This paper focuses on our ongoing work of studying human factors in security risk management. The human factors are identified and classified for the categories of individual team management and stakeholder as well as for the activities of security risk identification analysis and mitigation. Then some considerations and recommendations for mitigating these factors and risks are presented and the generic framework of evolving them into the secure software architecture is also figured.;
Proceedings of the First International Workshop on Leadership and Management in Software Architecture;Safety-critical systems are embedded systems that may cause injury loss of human life or great damage to the property if they fail. Architectural Patterns give solutions to the commonly recurring design problems in different applications and help the designers and architects to choose suitable design solutions. In this paper different architectural patterns for safety critical systems are presented and their advantages and limitations are discussed. Different architectural patterns presented in this paper are N-Version programming protected single channel and dual channel patterns TMR pattern Monitor-Actuator and watch dog pattern. A safety critical Microcontroller based Four Fingered Robotic hand is designed and software safety issues are discussed.;
Proceedings of the 2011 International Conference on Communication Computing &amp Security;Protecting the intellectual property of software that is distributed to third-party devices which are not under full control of the software author is difficult to achieve on commodity hardware today. Modern techniques of reverse engineering such as static and dynamic program analysis with system privileges are increasingly powerful and despite possibilities of encryption software eventually needs to be processed in clear by the CPU. To anyhow be able to protect software on these devices a small part of the hardware must be considered trusted. In the past general purpose trusted computing bases added to desktop computers resulted in costly and rather heavyweight solutions. In contrast we present Soteria a lightweight solution for low-cost embedded systems. At its heart Soteria is a program-counter based memory access control extension for the TI MSP430 microprocessor. Based on our open implementation of Soteria as an openMSP430 extension and our FPGA-based evaluation we show that the proposed solution has a minimal performance size and cost overhead while effectively protecting the confidentiality and integrity of an application's code against all kinds of software attacks including attacks from the system level.;
Proceedings of the 31st Annual Computer Security Applications Conference;Security improvement is the foremost concern for both industry professional and academician. Measurement is one of the most powerful techniques to control an activity. Experts are continuously trying to explore the importance of design knowledge of security. Security of object-oriented software is highly dependent on software design. In order to achieve the security a metric to quantify the same may be used. Security metrics are high-level quantifiable measures. In order to quantify security security metric suite is required. Several security models security metrics and object-oriented metrics are available in literature. But most of the metric available in literature is not validated and hence are unutilized or under utilized. In absence of any standard framework identifying validated and reliable metric it seems to be worthwhile developing a viable framework for the development of security metric. The framework proposed in this paper provides a systematic way to identify security metric suite and if unavailable develop a validated design security metric;
Proceedings of the International Conference on Advances in Computing Communication and Control;We expect that in future commodity hardware will be used in safety critical applications. But the used commodity microprocessors will become less reliable because of decreasing feature size and reduced power supply. Thus software-implemented approaches to deal with unreliable hardware will be required. As one basic step to software-implemented hardware-fault tolerance (SIHFT) we aim at providing failure virtualization by turning arbitrary value failures caused by erroneous execution into crash failures which are easier to handle. Existing SIHFT approaches either are not broadly applicable or lack the ability to reliably deal with permanent hardware faults. In contrast Forin [7] introduced the Vital Coded Microprocessor which reliably detects transient and permanent hardware errors but is not applicable to arbitrary programs and requires special hardware. We discuss different approaches to generalize Forin's approach and make it applicable to modern infrastructures.;
Proceedings of the Conference on Design Automation and Test in Europe;Most organizations want assurance that their software has been tested for known security issues. Government industry and academia are working together to make this more economical and effective. In addition to the obvious relevance to software development groups acquisition groups in large government and private organizations are also moving to require that these types of testing be part of contracts. The capabilities for evaluating code design and architecture are maturing however there are currently no standards defining these types of capabilities and how to evaluate them. This lack of defined standards leaves open the question of which technique service or tool is most appropriate for particular jobs and how effective they are at performing them.;
Proceedings of the 4th Annual Workshop on Cyber Security and Information Intelligence Research: Developing Strategies to Meet the Cyber Security and Information Intelligence Challenges Ahead;Risk analysis is a process for considering possible risks and determining which are the most significant for any particular effort. Determining which risks to address and the optimum strategy for mitigating said risks is often an intuitive and qualitative process. An objective view of the risks inherent in a development effort requires a quantitative risk model. Quantitative risk models used in determining which risk factors to focus on tend to use a traditional approach of annualized loss expectancy (ALE). This research uses empirical data that reflects the security posture of each vulnerability to calculate Loss Expectancy a risk impact estimator. Data from open source vulnerability databases and results of predicted threat models are used as input to the risk model. Security factors that take into account the innate characteristics of each vulnerability are incorporated into the calculation of the risk model resulting in an empirical assessment of the potential threats to a development effort based on the risk metric calculation.;
Proceedings of the 2007 ACM Workshop on Quality of Protection;Software protection is a difficult task especially for managed code which executes only on a runtime environment such as C# or Java. Applications developed in such languages can be accurately decompiled as opposed to x86 machine code. This facilitates reverse engineering attacks with the goal of extracting proprietary algorithms. Due to the ease of distributing software copies across different jurisdictions software developers cannot only rely on legal means for protection against reverse engineering attacks. Therefore they have to employ technical means for software protection such as obfuscation. This paper presents an open source tool for virtualization obfuscation of programs written in the C# language called VOT4CS. Our tool offers several possibilities for randomization that aim to confuse attacks based on pattern recognition. An evaluation of VOT4CS is performed based on several case-studies which show the performance-security trade-off offered by the tool.;
Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering: Companion Proceedings;Development processes for software construction are common knowledge and mainstream practice in most development organizations. Unfortunately these processes offer little support in order to meet security requirements. Over the years research efforts have been invested in specific methodologies and techniques for secure software engineering yet complete dedicated processes have been proposed only recently. In this paper two high-profile processes for the development of secure software namely OWASP's CLASP and Microsoft's SDL are evaluated and compared in detail. The paper identifies the commonalities discusses the specificity of each approach and proposes suggestions for improvement.;
Proceedings of the Third International Workshop on Software Engineering for Secure Systems;Cost effective development of secure software is a key goal for many software organizations as they seek to manage the risks of misbehaving software. Employing Formal Methods (FMs) in the Model-Based Software Engineering (MBSE) paradigm that systematically produces software systems through modeling simulation reuse and automation provides a reasonable approach for developing highly secure software in a productive manner. MBSE approaches introduce some complexities at the beginning of the lifecycle but save substantial time in production and delivery by identifying and resolving defects/errors early and reducing rework. On the other hand the expertise needed for FMs and the concomitant costs often inhibit their wide employment in securing large and complex software systems. In this paper we report our experience with Formal Analysis and Design for Engineering Security (FADES) an approach we introduced two years ago at this venue. Through systematic and automated transformation from semiformal requirements specifications to formal design FADES facilitates embedding FMs into the development lifecycle of secure software systems. We outline the case studies and validation of FADES feasibility for the design and implementation of secure software systems. Promising experience with FADES was a necessary precursor to our work on generalizing FADES and our proposal to direct FADES toward being an MBSE approach. We discuss how the formality transformation reuse and automation in FADES may further enhance the MBSE-based production and delivery of secure software.;
Proceedings of the Sixth Annual Workshop on Cyber Security and Information Intelligence Research;In the area of physical attacks system-on-chip (SoC) designs have not received the same level of attention as simpler micro-controllers. We try to model the behavior of secure software running on a superscalar out-of-order microprocessor typical of more complex SoC in the presence of electromagnetic (EM) pulses. We first show that it is possible in a black box approach to corrupt the loop iteration count of both original and hardened versions of two sensitive loops. We propose a characterization methodology based on very simple codes to understand and classify the fault effects at the level of the instruction set architecture (ISA). The resulting classification includes the well established instruction skip and register corruption models as well as new effects specific to more complex processors such as operand substitution multiple correlated register corruptions advanced control-flow hijacking and combinations of all reported effects. This diversity and complexity of effects can lead to powerful attacks. The proposed methodology and fault classification at ISA level is a first step towards a more complete characterization. It is also a tool supporting the designers of software and hardware countermeasures.;
Proceedings of the 26th Annual Computer Security Applications Conference;In the world of software engineering security remains a critical issue. Companies lose billions each year because commercial vendors continue to produce exploitable applications. Over 8000 vulnerabilities were cataloged by the Computer Emergency Response Team in 2006 alone. Despite this alarming statistic companies still grip the same train-and-certify approach for cultivating security-minded programmers. However exhibited by the prevalent vulnerabilities still appearing in cyberspace a new ambitious plan for robust software development must be implemented. This paper addresses the inadequacy of training and encourages the academic community to adopt modern software security essentials into the undergraduate computer science curriculum. This paper also proposes a unique software engineering course targeted to senior-level computer science students that underlines design methods tools and standards applicable to writing secure code.;
Proceedings of the 14th Western Canadian Conference on Computing Education;Security breaches are often caused by software bugs which may frequently be due to developers' memory lapses lack of attention/ focus and knowledge gaps. Developers have to contend with heavy cognitive loads to deal with issues such as functional requirements deadlines security and runtime performance. We propose to integrate secure programming support seamlessly into Integrated Development Environments (IDEs) in order to help developers cope with their heavy cognitive load and reduce security errors. As proof of concept we developed a plugin for Eclipse's Java development environment. Developers will be alerted to potential secure programming concerns such as input validation data encoding and access control as well as encouraged to comply with secure coding standards.;
Proceedings of the Third International Conference on Engineering Secure Software and Systems;Software protection aims to prevent unauthorized use analysis modification and distribution of software. This goal is hard to achieve especially for a program running on a platform (e.g. physical device) controlled by an adversary also known as man-at-the-end (MATE) attacker. Self-checking is one technique for protecting the integrity of software by having the code check itself. In this paper we present the design and implementation of a self-checking tool called StIns4CS. Our tool implements self-checking via state inspection by source code transformations of programs written in the C# language. More specifically StIns4CS augments code by adding runtime checkers to it. We discuss the effectiveness of StIns4CS by implementing attacks targeting our approach and measuring different aspects of the effectiveness stealth and cost of the protection. Based on the evaluation we show the trade-off between the efficiency and effectiveness of StIns4CS in protecting software against unauthorized modification. We propose an approach to improve stealth of the code added by StIns4CS and we show further improvements of stealth by combining selfchecking with virtualization obfuscation.;
Proceedings of the Ninth International Symposium on Visualization for Cyber Security;Static analysis tools have improved significantly in recent years with advances in intermediate representations symbolic execution constraint solving control flow recovery and static data flow analysis. Scripting of static analysis has improved at an even faster pace with new APIs allowing easy access to extend or modify the building blocks that static analysis tools are built upon.One of code obfuscation's common goals is to make it more difficult for a reverse engineer to analyze or understand the code. With today's more powerful static analysis tools what code obfuscation techniques are still effective against static reverse engineering and which are now easy to remove?This talk first explores how modern static analysis tools analyze binary code. An overview of how these tools recover a program's control flow from a binary is presented as well as a look at the analysis features that are available to scripts built upon them.Various obfuscation techniques are then discussed to explore the impact of modern static analysis tools on them. Such impacts include obfuscation techniques that have been defeated by modern toolsscripting features that have made some obfuscation techniques easier to removeobfuscation techniques that are still difficult for static analysis to resolvecode patterns that remain difficult to analyze even with an expert reverse engineer interacting with the tool.;
Proceedings of the Ninth ACM Conference on Data and Application Security and Privacy;The Rowhammer vulnerability common to many modern DRAM chips allows attackers to trigger bit flips in a row of memory cells by accessing the adjacent rows at high frequencies. As a result they are able to corrupt sensitive data structures (such as page tables cryptographic keys object pointers or even instructions in a program) and circumvent all existing defenses.This paper introduces ZebRAM a novel and comprehensive software-level protection against Rowhammer. ZebRAM isolates every DRAM row that contains data with guard rows that absorb any Rowhammer-induced bit flips the only known method to protect against all forms of Rowhammer. Rather than leaving guard rows unused ZebRAM improves performance by using the guard rows as efficient integrity-checked and optionally compressed swap space. ZebRAM requires no hardware modifications and builds on virtualization extensions in commodity processors to transparently control data placement in DRAM. Our evaluation shows that ZebRAM provides strong security guarantees while utilizing all available memory.;
Proceedings of the 13th USENIX Conference on Operating Systems Design and Implementation;The VM (Virtual effective solution to protect software making it extremely a Machine)-based software protection technique provides difficulty to analyze and crack. In this paper we improve it from two aspects. Firstly the time diversity is to fight against cumulative attack by making software executing along variant paths in different running time. Secondly transform instructions in an execution path with reducing performance penalty through controlling deformation strategy. At last we design and develop a VM-based protection with time diversity system named TDVMP and carry out some experiments with it. The results show that the improvements are effective.;
Proceedings of ACM SIGPLAN on Program Protection and Reverse Engineering Workshop 2014;Sophistication and flexibility of software development make it easy to leave security vulnerabilities in software applications for attackers. It is critical to educate and train software engineers to avoid introducing vulnerabilities in software applications in the first place such as adopting secure coding mechanisms and conducting security testing. A number of websites provide training grounds to train people's hacking skills which are highly related to security testing skills and train people's secure coding skills. However there exists no interactive gaming platform for instilling gaming aspects into the education and training of secure coding. To address this issue we propose to construct secure coding duels in Code Hunt a high-impact serious gaming platform released by Microsoft Research. In Code Hunt a coding duel consists of two code segments: a secret code segment and a player-visible code segment. To solve a coding duel a player iteratively modifies the player-visible code segment to match the functional behaviors of the secret code segment. During the duel-solving process the player is given clues as a set of automatically generated test cases to characterize sample functional behaviors of the secret code segment. The game aspect in Code Hunt is to recognize a pattern from the test cases and to re-engineer the player-visible code segment to exhibit the expected behaviors. Secure coding duels proposed in this work are coding duels that are carefully designed to train players' secure coding skills such as sufficient input validation and access control.;
Proceedings of the 2015 Symposium and Bootcamp on the Science of Security;Software defined radio (SDR) is a rapidly evolving technology which implements some functional modules of a radio system in software executing on a programmable processor. SDR provides a flexible mechanism to reconfigure the radio enabling networked devices to easily adapt to user preferences and the operating environment. However the very mechanisms that provide the ability to reconfigure the radio through software also give rise to serious security concerns such as unauthorized modification of the software leading to radio malfunction and interference with other users' communications. Both the SDR device and the network need to be protected from such malicious radio reconfiguration.In this paper we propose a new architecture to protect SDR devices from malicious reconfiguration. The proposed architecture is based on robust separation of the radio operation environment and user application environment through the use of virtualization. A secure radio middleware layer is used to intercept all attempts to reconfigure the radio and a security policy monitor checks the target configuration against security policies that represent the interests of various parties. Therefore secure reconfiguration can be ensured in the radio operation environment even if the operating system in the user application environment is compromised. We have prototyped the proposed secure SDR architecture using VMware and the GNU Radio toolkit and demonstrate that the overheads incurred by the architecture are small and tolerable. Therefore we believe that the proposed solution could be applied to address SDR security concerns in a wide range of both general-purpose and embedded computing systems.;
Proceedings of the 3rd Symposium on Usable Privacy and Security;Software security has become one of the active areas of research due to various cyber threats and attacks that can be very dangerous. A majority of these software threats directly affects the security aspects such as confidentiality integrity and accessibility. These software threats such as reverse engineering tampering etc. exploit the authenticated data of the software. Various techniques have been developed to deal with the software threats and attacks. But most of the existing software protection techniques do not provide reliable security against various attacks. Recently Cryptographic approaches are found to be very effective in handling the software threats and attacks. Code encryption has received much attention in the field of software security. This paper proposes a novel software protection code encryption scheme based on the index table. This approach uses a novel and efficient encryption technique called quasigroup encryption for encryption the indexed table. It provides least resemblance of the original data when encrypted. Quasigroups effectively produce an astronomical number of keys which confuses the hackers in identifying the original data. But quasi group encryption is not efficient in diffusing the statistics of the plain text. Hence this approach uses chained Hadamard transforms and Number Theoretic Transforms to introduce diffusion along with the quasigroup transformation. The experimental results evaluate the performance of the proposed encryption approach based on the time cost and space cost and it is observed that the proposed approach provides significant results.;
Proceedings of the Second International Conference on Computational Science Engineering and Information Technology;Previous researchers have argued that method purity (absence of side-effects) in object-oriented languages allows code to be more easily reasoned about with beneficial effects for software security. However many different forms of purity have been proposed which poses a challenge for verifying this idea empirically. Furthermore previous purity analyses of code have provided only coarse-grained results. We propose a finer-grained classification of levels of method purity and analyse a portion of real-world code to determine the prevalence of different levels.;
Proceedings of the Australasian Computer Science Week Multiconference;Many opportunities of use of systems also open doors for their misuse. Misuse of a system could manifest itself in a variety of forms. One common misuse of a system lies in security breaches. This research investigates tracing requirements and threats through a series of models to identify maintain the visibility of and ultimately help mitigate security threats to a system. The proposed Tracking of REquirements And Threats (TREAT) approach is a model driven framework which blends together several known modeling techniques to conceptualize and design a secure software system. TREAT considers security requirements along with system requirements from the very inception of the software and traces them throughout the software lifecycle in between various software artifacts.;
Proceedings of the 46th Annual ACM Southeast Conference;Competitive online video gaming (or eSports for short) is a booming industry. Current estimates predict global revenues of well over 1 billion dollars by the end of this year Twitch.tv the largest eSports streaming network is now one of the biggest sites on the internet and the International Olympic Committee is even considering to include eSports in the 2024 Summer Olympics. With this rising popularity comes a dark side in the form of cheating however. Cheaters are willing to subvert the rules of the game by any means necessary. Many of them pay monthly subscription fees to get access to exclusive cheating software created by hackers.In this talk I will discuss the most prevalent types of cheats used in online games and show how they give players a competitive advantage.I will then highlight the various steps that go into creating a cheat and give an overview of the various techniques and tools hackers use in each step ranging from debuggers differential data analysis tools API hooking bytehacking etc.Next I will present cheat mitigation strategies that can be incorporated into a game's design and detection techniques that can be applied in both client-side and server-side cheat-protection software.Finally I will zoom in on some of the most popular client-side anti-cheat solutions and highlight some of their capabilities.;
Proceeding of the 44th ACM Technical Symposium on Computer Science Education;More and more functionality is provided by mobile phones today this trend will continue over the next years. However with the increasing functionality new risks go along. This not only applies to security-critical mobile applications such as m-banking or m-commerce applications. The end user's privacy may also be in danger or the operator may be the target of an attack. In this paper we discuss security risks introduced by mobile phones considering the perspectives of the different parties involved in telecommunications systems. Specifically we demonstrate those risks by means of a security hole discovered in a large number of mobile phones. The security hole can be exploited to obtain manufacturer or even operator permissions. In particular we implemented a Java-based Trojan horse. This way the compromised mobile phone can be used as an eavesdropping device by an attacker. All in all this demonstrates that the risks are not only theoretical but also real. We also sketch a methodology for the security analysis of mobile phone software.;
Proceedings of the 2011 ACM Symposium on Applied Computing;Debugging could be a threat to system security when adopted by malicious attackers. The major challenges of software-only anti-debugging are compromised strategy and lack of self-protection. Leveraging hardware virtualization we proposes a strategy of software protection through anti-debugging which imperceptibly monitors the debug event on a higher privilege level than the conventional kernel space. Our prototype can effectively prohibit the debugging behavior from selected popular debuggers in the replication experiment.;
Proceedings of the 4th ACM Workshop on Quality of Protection;Information systems (IS) outsourcing is a serious commitment -- a formal relationship underpinned by a contractual agreement with long-term consequences among two or more organisations. Many organisations end up frustrated as they learn that their attempts at IS outsourcing have failed. However some failures could be avoided with knowledge of common pitfalls and critical success factors of such IS outsourcing contracts. This paper investigates essential aspects of IS outsourcing management during the software development life cycle. The survey results are reported in conjunction with findings in the literature of similar studies in other markets and unique contributors to IS outsourcing in this particular context in the South African corporate market are identified.;
Proceedings of the 2010 Annual Research Conference of the South African Institute of Computer Scientists and Information Technologists;Software complexity is often hypothesized to be the enemy of software security. We performed statistical analysis on nine code complexity metrics from the JavaScript Engine in the Mozilla application framework to investigate if this hypothesis is true. Our initial results show that the nine complexity measures have weak correlation (Ï=0.30 at best) with security problems for Mozilla JavaScript Engine. The study should be replicated on more products with design and code-level metrics. It may be necessary to create new complexity metrics to embody the type of complexity that leads to security problems.;
Proceedings of the 5th Workshop on Evaluation and Usability of Programming Languages and Tools;Software development teams need guidance on choosing security practices so they can develop code securely. The academic and practitioner literature on software development security practices is large and expanding. However published empirical evidence for security practice use in software development is limited and fragmented making choosing appropriate practices difficult. Measurement frameworks offer a tool for collecting and comparing software engineering data. The goal of this work is to aid software practitioners in evaluating security practice use in the development process by defining and validating a measurement framework for software development security practice use and outcomes. We define the Security Practices Evaluation Framework (SP-EF) a measurement framework for software development security practices. SP-EF supports evidence-based practice selection. To enable comparison of practices across publications and projects we define an ontology of software development security practices. We evaluate the framework and ontology on historical data and industrial projects.;
Companion to the 22nd ACM SIGPLAN Conference on Object-Oriented Programming Systems and Applications Companion;Software defect data provide an invaluable source of information for developers testers and so forth. A concise view of a software profile its development process and their relationships can be systematically extracted and analyzed to deduce adequate corrective measures based on previously discovered weaknesses. This kind of approach is being widely used in various projects to improve the quality of a software system. This paper builds on top of the orthogonal defect classification (ODC) scheme to provide a structured security-specific defect classification. We perform a detailed analysis on the classified data and obtain in-process feedback so that the next version of the software can be more secure and reliable. We experimented our customized methodology on Firefox and Chrome defect repositories using six consecutive versions and milestones respectively. We found that in-process feedback can help development team to take corrective actions as early as possible. We also studied the correlations between software defect types and software development lifecycle to understand development improvement.;
Proceedings of the 28th Annual ACM Symposium on Applied Computing;Testing is the primary approach for detecting software defects. A major challenge faced by testers lies in crafting efficient test suites able to detect a maximum number of bugs with manageable effort. To do so they rely on coverage criteria which define some precise test objectives to be covered. However many common criteria specify a significant number of objectives that occur to be infeasible or redundant in practice like covering dead code or semantically equal mutants. Such objectives are well-known to be harmful to the design of test suites impacting both the efficiency and precision of the tester's effort. This work introduces a sound and scalable technique to prune out a significant part of the infeasible and redundant objectives produced by a panel of white-box criteria. In a nutshell we reduce this task to proving the validity of logical assertions in the code under test. The technique is implemented in a tool that relies on weakest-precondition calculus and SMT solving for proving the assertions. The tool is built on top of the Frama-C verification platform which we carefully tune for our specific scalability needs. The experiments reveal that the pruning capabilities of the tool can reduce the number of targeted test objectives in a program by up to 27% and scale to real programs of 200K lines making it possible to automate a painstaking part of their current testing process.;
Proceedings of the 15th ACM Conference on Computer and Communications Security;Obfuscation is a software protection technique that aims to increase the difficulty and amount of resources required to understand programs from the perspective of a malicious end user. The order and number of obfuscating transformations is determined by an obfuscation executive and the optimal arrangement of transformation defines the phase ordering problem. In this paper we report on a case study evaluation for determining the optimal phase ordering for an obfuscation executive. We analyze obfuscation effectiveness of variants generated by Tigress a dynamic virtualizing obfuscator with four transformation types. We test the evaluation of multiple orderings against a symbolic virtual machine to determine the strengths and weaknesses of each combination. We use overhead (cost) and effectiveness as the tradeoff space to determine the best sequence and ordering of transformations within this context. Our results show that ideally applying control flow transformation data encoding abstract transforms and then dynamic virtualization provides the highest effectiveness on average against symbolic execution attacks.;
Proceedings of the 7th Software Security Protection and Reverse Engineering / Software Security and Protection Workshop;In recent years software has grown in size and software safety incidents have also increased. Guidelines and Methods for Conducting the Safety Assessment Process on Civil Airborne Systems and Equipment (ARP4761) is an aerospace recommended practice from SAE International it provides a safety assessment process of the system to solve the safety problem of the system. In ARP4761 the process FHA and FTA determine the software development level based on the software development standard (such as DO-178C) and safety reviewer thought that the software is safe as long as it's development processes are guided by software development standards. However increasing airborne software scale is causing more and more software safety problems and the development standard of software can't guarantee that there is no safety problem in software. It is especially important to analyze the safety of the software. This paper presents the application method of FMEA in software safety analysis based on ARP4761 and improves the software safety evaluation of ARP4761.;
Proceedings of the 2019 3rd International Conference on Management Engineering Software Engineering and Service Sciences;In the software development lifecycle a software process model provides a standardized format for planning organizing and executing a software project. Dozens of different models exist and are used in the software industries but many of them has only some minor variations on a small number of basic software engineering models. Nevertheless in real life scenario software developer does not implement most of process models that we have seen theoretically exists because there are many modes available and it is very difficult to analysis which models should be implemented in which stage of the software development process. Hence this study presents a hybrid framework that describes three categories of process models based on the project characteristics such as small medium and large. And provides an analysis of finding which model supports which types of project and what steps need to be followed. The contribution of this study lays on the software engineer who will be assisted with the hybrid framework to take informed decisions about the model selection based on making query about the project characteristics such as project requirements risk factors involved in the project availability of the customers budget and expenses incur in the project etc.;
Proceedings of the International Conference on Computing Advancements;The Software Assurance Metrics and Tool Evaluation (SAMATE) project at the National Institute of Standards and Technology (NIST) has created the Software Assurance Reference Dataset (SARD) to provide researchers and software security assurance tool developers with a set of known security flaws. As part of an empirical evaluation of a runtime monitoring framework two test suites were executed and monitored revealing deficiencies which led to a collaboration with the NIST SAMATE team to provide replacements. Test Suites 45 and 46 are analyzed discussed and updated to improve accuracy consistency preciseness and automation. Empirical results show metrics such as recall precision and F-Measure are all impacted by invalid base assumptions regarding the test suites.;
Proceedings of the 20th International Conference on Evaluation and Assessment in Software Engineering;Process control systems using wireless sensor nodes are large and complex environments built to last for a long time. Cryptographic keys are typically preloaded in the wireless nodes prior to deployment and used for the rest of their lifetime. To reduce the risk of successful cryptanalysis new keys must be established (rekeying). We have designed a rekeying scheme that provides both backward and forward secrecy.Furthermore since these nodes are used for extensive periods of time there is a need to update the software on the nodes. Different types of sensors run different types and versions of software. We therefore establish group keys to update the software on groups of nodes. The software binary is split into fragments to construct a hash chain that is then signed by the network manager. The nodes can thus verify the authenticity and the integrity of the new software binary. We extend this protocol by encrypting the packets with the group key such that only the intended receivers can access the new software binary.;
Proceedings of the First ACM Conference on Wireless Network Security;In recent years software safety has been a problem for safety-critical systems. Software requires multiple states to describe the behavior of system. The state transition condition control the control signals that determine the state of a system. The control signal must be able to interface reasonably and can not be contradictory and the output state output time and timing of control signals can not be wrong in the process of system state transition. However in the process of developing system there may be some errors with control signals in the convergence between the state output status output time and output timing and it will cause the system abnormally. In response to this problem we present a method which based on the combination of finite state machine (FSM) and model checking technology. First build a FSM model. After that transform FSM model into SMV program. At last use NuSMV to detect dangerous control signals of SMV program. Results indicate that this method is able to find the software safety problem.;
Proceedings of the 2018 2nd International Conference on Management Engineering Software Engineering and Service Sciences;"Research in the area of Cyber-Physical Systems (CPS) is hampered by the lack of available project environments in which to explore open challenges and to propose and rigorously evaluate solutions. In this New Ideas and Emerging Results"" paper we introduce a CPS research incubator - based upon a system and its associated project environment for managing and coordinating the flight of small Unmanned Aerial Systems (sUAS). The research incubator provides a new community resource making available diverse high-quality project artifacts produced across multiple releases of a safety-critical CPS. It enables researchers to experiment with their own novel solutions within a fully-executable runtime environment that supports both high-fidelity sUAS simulations as well as physical sUAS. Early collaborators from the software engineering community have shown broad and enthusiastic support for the project and its role as a research incubator and have indicated their intention to leverage the environment to address their own research areas of goal modeling runtime adaptation safety-assurance and software evolution.""";
Proceedings of the 40th International Conference on Software Engineering: New Ideas and Emerging Results;This paper presents the development and configuration of a virtually air-gapped cloud environment in AWS to secure the production software workloads and patient data (ePHI) and to achieve HIPAA compliance.;
Proceedings of the 9th European Workshop on System Security;"Open source software is often considered to be secure because large developer communities can be leveraged to find and fix security vulnerabilities. Eric Raymond states Linus' Law as many eyes make all bugs shallow"" reasoning that a diverse set of perspectives improves the quality of a software product. However at what point does the multitude of developers become ""too many cooks in the kitchen"" causing the system's security to suffer as a result? In a previous study we quantified Linus' Law and ""too many cooks in the kitchen"" with developer activity metrics and found a statistical association between these metrics and security vulnerabilities in the Linux kernel. In the replication study reported in this paper we performed our analysis on two additional projects: the PHP programming language and the Wireshark network protocol analyzer. We also updated our Linux kernel case study with 18 additional months of newly-discovered vulnerabilities. In all three case studies files changed by six developers or more were at least four times more likely to have a vulnerability than files changed by fewer than six developers. Furthermore we found that our predictive models improved on average when combining data from multiple projects indicating that models can be transferred from one project to another.""";
Proceedings of the ACM International Workshop on Security in Software Defined Networks &amp Network Function Virtualization;"There have been many evolutions of the software development lifecycle (SDLC). These differing models have moved software development groups from sequential development to a more agile and iterative development model. Increasing awareness and research focused on the cyber security landscape has resulted in a large push for shifting security left"" in the SDLC. With security engineering teams engaged earlier and more often throughout the SDLC security issues will be found and fixed earlier which increases efficiency while lowering cost and overhead. While this has been an important cultural and infrastructural shift for many technology companies there is still a gap in this feedback loop that needs to be bridged: the gap between user experience designers and the software security and IT/operations engineers. Trade-offs have been made between security and usability---a challenge known as ""usability versus security."" Much of the research that propose how to change these two fields from opposing forces to being cross-functional allies offer simplified solutions but don't go into granular detail about solving the problem. This paper covers the evolution of the SDLC from the Waterfall model through the DevSecOps agile methodology and proposes a new development model: the Technology Development Lifecycle (TDLC). This TDLC model aims to keep designers software engineers security engineers and IT/operations all within a tight feedback loop throughout a continuous integration/continuous development pipeline. We will discuss various workflows use cases and technologies that can be used later on to implement a working environment that can enforce the TDLC model.""";
Proceedings of the 20th Annual SIG Conference on Information Technology Education;Automated static code analysis is an efficient technique to increase the quality of software during early development. This paper presents a case study in which mature software with known vulnerabilities is subjected to a static analysis tool. The value of the tool is estimated based on reported failures from customers. An average of 17% cost savings would have been possible if the static analysis tool was used. The tool also had a 30% success rate in detecting known vulnerabilities and at the same time found 59 new vulnerabilities in the three examined products.;
Proceedings of the 39th International Conference on Software Engineering Companion;This paper presents and evaluates the Boundary Diagram Tool for change impact analysis of large Simulink designs of embedded systems. In our previous work we developed the Reach/Coreach Tool for model slicing within a single Simulink model. The current work extends the Reach/Coreach Tool to trace the impact of model changes through multiple models comprising an embedded system including network interfaces. The change impact analysis results are represented using various diagrams motivated by industrial needs. Several techniques are used to improve understanding of impact analyses of large industrial systems. The tool has been integrated into the software development process of a large automotive OEM (Original Equipment Manufacturer) to support the following activities: change request analysis and evaluation implementation verification and integration. The tool also aids impact analyses required for compliance with functional safety standards. The toolâ€™s effectiveness has been demonstrated on production-scale models.;
Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;Anti-tampering is a form of software protection conceived to detect and avoid the execution of tampered programs. Tamper detection assesses programs' integrity with load or execution-time checks. Avoidance reacts to tampered programs by stopping or rendering them unusable. General purpose reactions (such as halting the execution) stand out like a lighthouse in the code and are quite easy to defeat by an attacker. More sophisticated reactions which degrade the user experience or the quality of service are less easy to locate and remove but are too tangled with the program's business logic and are thus difficult to automate by a general purpose protection tool. In the present paper we propose a novel approach to anti-tampering that (i) fully automatically applies to a target program (ii) uses Remote Attestation for detection purposes and (iii) adopts a server-side reaction that is difficult to block by an attacker. By means of Client/Server Code Splitting a crucial part of the program is removed from the client and executed on a remote trusted server in sync with the client. If a client program provides evidences of its integrity the part moved to the server is executed. Otherwise a server-side reaction logic may (temporarily or definitely) decide to stop serving it. Therefore a tampered client application can not continue its execution. We assessed our automatic protection tool on a case study Android application. Experimental results show that all the original and tampered executions are correctly detected reactions are promptly applied and execution overhead is on an acceptable level.;
Proceedings of the 43rd International Conference on Software Engineering;Common Mode Analysis (CMA) is an important part of the civil aircraft system safety assessment which runs through the whole process of aircraft design and manufacturing. Common mode analysis is used to verify the independence of systems functions or components to meet safety requirements. At present common-mode analysis research focuses on the hardware in the system and there are few studies on common-mode analysis of software and a relatively complete method has not yet been formed. In recent years the role scale and complexity of software in the aviation field have been rising and many problems have also arisen. For example the application of the Integrated Modular Avionics (IMA) system has greatly increased the comprehensiveness and complexity of aircraft functions. This can lead to an increased probability of fault propagation potentially leading to common mode failure of the software. Analysis of the common mode failure of software has become a potential future demand for the aviation industry. Based on the analysis method of common mode analysis in Guidelines and Methods for Conducting the Safety Assessment Process on Civil Airborne Systems and Equipment (ARP4761) this paper presents a common mode analysis method that can be used for aviation airborne software. It can solve the common mode analysis problem of aviation airborne software and reduce the safety problems caused by software common mode.;
Proceedings of the 11th Innovations in Software Engineering Conference;With the rise of new AI technologies autonomous systems are moving towards a paradigm in which increasing levels of responsibility are shifted from the human to the system creating a transition from human-in-the-loop systems to human-on-the-loop (HoTL) systems. This has a significant impact on the safety analysis of such systems as new types of errors occurring at the boundaries of human-machine interactions need to be taken into consideration. Traditional safety analysis typically focuses on system-level hazards with little focus on user-related or user-induced hazards that can cause critical system failures. To address this issue we construct domain-level safety analysis assets for sUAS (small unmanned aerial systems) applications and describe the process we followed to explicitly and systematically identify Human Interaction Points (HiPs) Hazard Factors and Mitigations from system hazards. We evaluate our approach by first investigating the extent to which recent sUAS incidents are covered by our hazard trees and second by performing a study with six domain experts using our hazard trees to identify and document hazards for sUAS usage scenarios. Our study showed that our hazard trees provided effective coverage for a wide variety of sUAS application scenarios and were useful for stimulating safety thinking and helping users to identify and potentially mitigate human-interaction hazards.;
Proceedings of the 2021 5th International Conference on Electronic Information Technology and Computer Engineering;In a world of ubiquitous computers and interconnected systems security is crucial and secure coding is an essential prerequisite for making systems secure. In order to achieve this secure coding must not be bolt-on in teaching but an integral part of any software development education. The complete redesign of software development courses can be difficult and time consuming to implement. In this paper we present ESprESSO-IT which is short for â€œEnforcing SafE and Secure SOftware â€“ In Teachingâ€ a funded research project by the municipal department MA 23 of Vienna and a solution to integrate secure coding into existing courses without relying on a retrospective leaning approach whereby students learn the topic of secure programming after they may have already internalized insecure code implementations.;
The 23rd International Conference on Information Integration and Web Intelligence;Mobile platforms represent an increasing valuable target for adversaries. This paper discusses attack surfaces â€“ points of attack â€“ that mobile devices present. Several important mobile device capabilities in communication computation and sensors enable attack surfaces not usually seen in desktop or server systems. These attack surfaces are not generally considered in recommendations from current secure software development lifecycles. Mitigation of the threats or reduction of the attack surfaces is needed when constructing secure mobile software.;
Proceedings of the 2nd International Workshop on Software Development Lifecycle for Mobile;Today it is widely accepted that software security best practices need to be integrated into all the stages of the software development life cycle (SDLC). This is because software applications are constantly being exposed to malicious attacks by hackers. One of the best practices for software security is threat modeling. It is essential for software security in the design stage of the SDLC and can help to reduce software design flaws significantly before the software application is implemented. The topics of threat modeling and the SDLC threat modeling tool were introduced to graduate students in a secure software engineering course. The effectiveness of Microsoft's Threat Modeling Tool was evaluated through a course assignment that included two parts: A) threat modeling using a manual process and B) threat modeling using Microsoft's 2014 threat modeling tool. This paper presents the results of the evaluation of the tool in assisting non-experts students in conducting an architectural risk analysis on a mock online shopping web application.;
Proceedings of the 2015 Information Security Curriculum Development Conference;Software is critical to life in the 21st century. It drives financial medical and government computer systems as well as systems that provide critical infrastructures in areas such as transportation energy networking and telecommunications. As the number and severity of attacks that exploit software vulnerabilities increase writing reliable robust and secure programs will substantially improve the ability of systems and infrastructure to resist such attacks. Education plays a critical role in addressing cybersecurity challenges of the future such as designing curricula that integrate principles and practices of secure programming into educational programs. To help guide this process the National Science Foundation Directorates of Computer and Information Science and Engineering (CISE) and Education and Human Resources (EHR) jointly sponsored the Summit on Education in Secure Software (SESS) held in Washington DC in October 2010. The goal of this session is to share some of the key findings and challenges identified by the summit and to actively engage the community in the discussions. Each of the speakers participated in the summit and brings a unique viewpoint to the session.;
Proceedings of the 43rd ACM Technical Symposium on Computer Science Education;"The growing adoption of small unmanned aircraft systems (sUAS) for tasks such as eCommerce aerial surveillance and environmental monitoring introduces the need for new safety mechanisms in an increasingly cluttered airspace. Safety assurance cases (SAC) provide a state-of-the-art solution for reasoning about system and software safety in numerous safety-critical domains. We propose a novel approach based on the idea of interlocking safety cases. The sUAS infrastructure safety case (iSAC) specifies assumptions and applies constraints upon the behavior of sUAS entering the airspace. Each sUAS then demonstrates compliance to the iSAC by presenting its own (partial) safety case (uSAC) which connects to the iSAC through a set of interlock points. To enforce a trust but verify"" policy sUAS conformance is monitored at runtime while it is in the airspace and its behavior is described using a reputation model based on the iSAC's expectations of its behavior.""";
Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings;Kubernetes is an open-source software system that helps practitioners in automatically deploying scaling and managing containerized applications. Information technology (IT) organizations such as IBM Spotify and Capital One use Kubernetes to manage their containers and reported benefits in the deployment process. However recent security breaches and survey results among practitioners suggest that Kubernetes deployment can be vulnerable to attacks due to misconfiguration and not following security best practices. This research explores how malicious users can perform potential security exploits from the violations of Kubernetes security best practices. We explore how attacks can be conducted such as denial of service attacks against one of the security best practices violations in Kubernetes manifests. In addition we are exploring potential exploits in the Kubernetes cluster to propose mitigation strategies to secure the Kubernetes cluster.;
Proceedings of the 1st ACM SIGSOFT International Workshop on Education through Advanced Software Engineering and Artificial Intelligence;High-level semantic vulnerabilities such as SQL injection and crosssite scripting have surpassed buffer overflows as the most prevalent security exploits. The breadth and diversity of software vulnerabilities demand new security solutions that combine the speed and practicality of hardware approaches with the flexibility and robustness of software systems.This paper proposes Raksha an architecture for software security based on dynamic information flow tracking (DIFT). Raksha provides three novel features that allow for a flexible hardware/software approach to security. First it supports flexible and programmable security policies that enable software to direct hardware analysis towards a wide range of high-level and low-level attacks. Second it supports multiple active security policies that can protect the system against concurrent attacks. Third it supports low-overhead security handlers that allow software to correct complement or extend the hardware-based analysis without the overhead associated with operating system traps.We present an FPGA prototype for Raksha that provides a full featured Linux workstation for security analysis. Using unmodified binaries for real-world applications we demonstrate that Raksha can detect high-level attacks such as directory traversal command injection SQL injection and cross-site scripting as well as low-level attacks such as buffer overflows. We also show that low overhead exception handling is critical for analyses such as memory corruption protection in order to address false positives that occur due to the diverse code patterns in frequently used software.;
Proceedings of the 34th Annual International Symposium on Computer Architecture;JavaScript is widely used for implementing client-side web applications and it is common to include JavaScript code from many different hosts. However in a web browser all the scripts loaded in the same frame share a single global namespace. As a result a script may read or even overwrite the global objects or functions in other scripts causing unexpected behaviors. For example a script can redefine a function in a different script as an object so that any call of that function would cause an exception at run time.  We systematically investigate the client-side JavaScript code integrity problem caused by JavaScript global identifier conflicts in this paper. We developed a browser-based analysis framework JSObserver to collect and analyze the write operations to global memory locations by JavaScript code. We identified three categories of conflicts using JSObserver on the Alexa top 100K websites and detected 145918 conflicts on 31615 websites.  We reveal that JavaScript global identifier conflicts are prevalent and could cause behavior deviation at run time. In particular we discovered that 1611 redefined functions were called after being overwritten and many scripts modified the value of cookies or redefined cookie-related functions. Our research demonstrated that JavaScript global identifier conflict is an emerging threat to both the web users and the integrity of web applications.;
Proceedings of the 3rd International Workshop on Software Development Lifecycle for Mobile;Small Unmanned Aircraft Systems (sUAS) are an emerging application area for many industries including surveillance agriculture monitoring and vector-borne disease control. With drastically lower costs and increasing performance and autonomy future application evolution will more than likely include the use of sUAS swarms. Several largely successful experiments in recent years using off the shelf sUAS have been conducted to address the long standing challenge of controlling and monitoring vector-borne diseases. In this paper we build on lessons learned from these prior efforts and discuss ways in which swarms of sUAS could be deployed to place and monitor Autocidal Gravid Ovitraps for reducing the mosquito population.;
Proceedings of the 40th International Conference on Software Engineering: Software Engineering in Practice;Reliability is one of the most important quality attributes of a software system addressing the systemâ€™s ability to perform the required functionalities under stated conditions for a stated period of time. Nowadays a system failure could threaten the safety of human life. Thus assessing reliability became one of the software engineeringâ€˜s holy grails. Our approach wants to establish based on what projectâ€™s characteristics we obtain the best bug-oriented reliability prediction model. The pillars on which we base our approach are the metric introduced to estimate one aspect of reliability using bugs and the Chidamber and Kemerer (CK) metrics to assess reliability in the early stages of development. The methodology used for prediction is a feed-forward neural network with back-propagation learning. Five different projects are used to validate the proposed approach for reliability prediction. The results indicate that CK metrics are promising in predicting reliability using a neural network model. The experiments also analyze if the type of project used in the development of the prediction model influences the quality of the prediction. As a result of the operated experiments using both within-project and cross-project validation the best prediction model was obtained using PDE (PlugIn characteristic) for MY project (Task characteristic).;
Proceedings of the 25th International Conference on Evaluation and Assessment in Software Engineering;As the underground industry of malware prospers malware developers consistently attempt to camouflage malicious code and undermine malware detection with various obfuscation schemes. Among them metamorphism is known to have the potential to defeat the popular signature-based malware detection. A metamorphic malware sample mutates its code during propagations so that each instance of the same family exhibits little resemblance to another variant. Especially with the development of compiler and binary rewriting techniques metamorphic malware will become much easier to develop and outbreak eventually. To fully understand the metamorphic engine the core part of the metamorphic malware we attempt to systematically study the evolution of metamorphic malware over time. Unlike the previous work we do not require any prior knowledge about the metamorphic engine in use. Instead we perform trace-based semantic binary diffing to compare mutation code iteratively and memoize semantically equivalent basic blocks. We have developed a prototype called MetaHunt and evaluated it with 1400 metamorphic malware variants. Our experimental results show that MetaHunt can accurately capture the semantics of unknown metamorphic engines and all of the comparisons converge in a reasonable time. Besides MetaHunt identifies several metamorphic engine bugs which lead to a semantics-breaking transformation. We summarize our experience learned from our empirical study hoping to stimulate designing mutation-aware solutions to defend this threat proactively.;
Proceedings of the 1st International Workshop on Software Engineering for AI in Autonomous Systems;In this paper we propose OBFUS a web-based tool that can easily apply obfuscation techniques to high-level and low-level programming languages. OBFUS's high-level obfuscator parses and obfuscates the source code overlaying the obfuscation to produce more complex results. OBFUS's low-level obfuscator decompiles binary programs into LLVM IR. This LLVM IR pro-gram is obfuscated and the LLVM IR program is recompiled to become an obfuscated binary program.;
Proceedings of the Eleventh ACM Conference on Data and Application Security and Privacy;Enabled by the continuous improvement of the hardware and software in mobile devices mobile applications have evolved into very complex pieces of software. Yet such increase in complexity hasn't been paired by an increased awareness among developers of the important role that some software engineering processes play in managing such complexity. In this paper we focus on the architectural design of mobile applications: we show how this aspect is still overlooked by mobile app developers we present a high level process and several concepts that aim to guide developers in the creation of suitable architectures for their apps and we describe the advantages of integrating architectural thinking within the mobile app development process.;
Proceedings of the 35th Annual Computer Security Applications Conference;The most significant factor for software development is software security. In today's era security being the most crucial quality aspect as well as imperative demand for any software projects. To address security a number of approaches techniques and design have been evolved to secure software applications. Security requirements are used during the software development life cycle in order to reduce vulnerabilities particularly during requirement elicitation by performing functions such as measuring adherence to secure requirement standards identifying likely vulnerabilities that may exist and tracing and inspecting security flaws that are sooner or later discovered. To achieve these objectives the assessment of security using model is more appropriate and its validation signifies the valid impact of functional requirement of secure software. The model to quantify confidentiality is developed using multiple linear regression technique on requirement constructs. The statistical analysis on this study concludes its statistical significance that the calculated data is highly acceptable.;
Proceedings of the 2015 International Conference on Advanced Research in Computer Science Engineering &amp Technology (ICARCSET 2015);Recent studies have shown a remarkable need for testing automation techniques in the context of mobile applications. The main contributions in literature in the field of testing automation regard techniques such as Capture/Replay Model Based Model Learning and Random techniques. Unfortunately only the last two typologies of techniques are applicable if no previous knowledge about the application under testing is available. Random techniques are able to generate effective test suites (in terms of source code coverage) but they need a remarkable effort in terms of machine time and the tests they generate are quite inefficient due to their redundancy. Model Learning techniques generate more efficient test suites but often they do not not reach good levels of coverage. In order to generate test suites that are both effective and efficient we propose in this paper AGRippin a novel Search Based Testing technique founded on the combination of genetic and hill climbing techniques. We carried out a case study involving five open source Android applications that has demonstrated how the proposed technique is able to generate test suites that are more effective and efficient than the ones generated by a Model Learning technique.;
Proceedings of the 7th Symposium on Hot Topics in the Science of Security;Energy has emerged as an important quality metric for apps that run on mobile platforms. This talk describes our approach for reducing display energy by automatically changing the color schemes used by a web app so that the pages consume less energy when displayed on an OLED based smartphone.;
Proceedings of the 11th International Workshop on Cooperative and Human Aspects of Software Engineering;Software systems are designed and implemented with assumptions about the environment. However once the system is deployed the actual environment may deviate from its expected behavior possibly undermining desired properties of the system. To enable systematic design of systems that are robust against potential environmental deviations we propose a rigorous notion of robustness for software systems. In particular the robustness of a system is defined as the largest set of deviating environmental behaviors under which the system is capable of guaranteeing a desired property. We describe a new set of design analysis problems based on our notion of robustness and a technique for automatically computing robustness of a system given its behavior description. We demonstrate potential applications of our robustness notion on two case studies involving network protocols and safety-critical interfaces.;
Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;Reentrancy bugs one of the most severe vulnerabilities in smart contracts have caused huge financial loss in recent years. Researchers have proposed many approaches to detecting them. However empirical studies have shown that these approaches suffer from undesirable false positives and false negatives when the code under detection involves the interaction between multiple smart contracts.In this paper we propose an accurate and efficient cross-contract reentrancy detection approach in practice. Rather than design rule-of-thumb heuristics we conduct a large empirical study of 11714 real-world contracts from Etherscan against three well-known general-purpose security tools for reentrancy detection. We manually summarized the reentrancy scenarios where the state-of-the-art approaches cannot address. Based on the empirical evidence we present Clairvoyance a cross-function and cross-contract static analysis to detect reentrancy vulnerabilities in real world with significantly higher accuracy. To reduce false negatives we enable for the first time a cross-contract call chain analysis by tracking possibly tainted paths. To reduce false positives we systematically summarized five major path protective techniques (PPTs) to support fast yet precise path feasibility checking. We implemented our approach and compared Clairvoyance with five state-of-the-art tools on 17770 real-worlds contracts. The results show that Clairvoyance yields the best detection accuracy among all the five tools and also finds 101 unknown reentrancy vulnerabilities.;
Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering;The frequent release of Android OS and its various versions bring many compatibility issues to Android Apps. This paper studies and addresses such evolution-induced compatibility problems. We conduct an extensive empirical study over 11 different Android versions and 4936 Android Apps. Our study shows that there are drastic API changes between adjacent Android versions with averagely 140.8 new types 1505.6 new methods and 979.2 new fields being introduced in each release. However the Android Support Library (provided by the Android OS) only supports less than 23% of the newly added methods with much less support for new types and fields. As a result 91.84% of Android Apps write additional code to support different OS versions. Furthermore 88.65% of the supporting codes share a common pattern which directly compares variable android.os.Build.VERSION.SDK_INT with a constant version number to use an API of particular versions. Based on our findings we develop a new tool called IctApiFinder to detect incompatible API usages in Android applications. IctApiFinder effectively computes the OS versions on which an API may be invoked using an inter-procedural data-flow analysis framework. It detects numerous incompatible API usages in 361 out of 1425 Apps. Compared to Android Lint IctApiFinder is sound and able to reduce the false positives by 82.1%. We have reported the issues to 13 Apps developers. At present 5 of them have already been confirmed by the original developers and 3 of them have already been fixed.;
Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering;Walking the Model (WtM) is a concept that aims to promote the practice of practitioners and crews by providing on-the-job interaction between the system model of the business and the physical world. Among various implementations of this idea WtM provides mobile field engineers with the ability to view update and simulate by asking what-if questions while in the field. In this keynote speech I present the notion and features of walking the model and show how WtM changes the way we perceive of different practices for both actual practice and learning processes.;
Proceedings of the 2013 International Workshop on Software Development Lifecycle for Mobile;Developing energy-efficient application is crucial for mobile platforms such as smartphone and tablets since such devices operate on a limited amount of battery power. However until recently most of the smartphone applications have been developed in an energy-oblivious fashion. This is increasingly becoming a concern due to the fact that smartphone applications are progressively becoming complex and energy-intensive whereas the battery technology is unable to keep up. Existing studies have proposed a number of testing and re-factoring techniques that can be used to increase the energy-efficiency of such applications after the development has been completed. However we feel that maximum level of energy-efficiency can be achieved only if energy-efficient design practices are used in the software development process. In this study we propose a set of energy-aware design patterns specifically targeted at smartphone applications. These design patterns can be applied to huge number of real-life scenarios for energy-efficient information gathering and processing within the smartphone application. We also present some examples of design patterns for application development for the Android platform.;
Proceedings of the 2017 ACM SIGCSE Technical Symposium on Computer Science Education;Generic taint analysis is a pivotal technique in software security. However it suffers from staggeringly high overhead. In this paper we explore the hypothesis whether just-in-time (JIT) generation of fast paths for tracking taint can enhance the performance. To this end we present the Taint Rabbit which supports highly customizable user-defined taint policies and combines a JIT with fast context switching. Our experimental results suggest that this combination outperforms notable existing implementations of generic taint analysis and bridges the performance gap to specialized trackers. For instance Dytan incurs an average overhead of 237x while the Taint Rabbit achieves 1.7x on the same set of benchmarks. This compares favorably to the 1.5x overhead delivered by the bitwise non-generic taint engine LibDFT.;
Proceedings of the 15th ACM Asia Conference on Computer and Communications Security;Today connectivity is demanded in almost every domain e.g. the smart home domain and its connected smart household devices like TVs and fridges or the industrial automation domain connecting plants controllers and sensors to the internet for purposes like condition monitoring. This trend amplifies the need for secure applications that can protect their sensitive data against manipulation and leaks. However many applications are still built without considering security in its design phase often it is perceived as too complicated and time consuming. This is a major oversight as fixing vulnerabilities after release is often not feasible when major architecture redesigns are necessary. Therefore the software developer has to make sure that the developed software architecture is secure. Today there are some tools available to help the software developer in identifying potential security weaknesses of their architecture. However easy and fast to use tools that support the software developer in improving their architecture's security are lacking. The goal of my thesis is to make security improvements easily applicable by non-security and non-architecture experts by proposing systematic easy to use and automated techniques that will help the software developer in designing secure software architectures.To achieve this goal I propose a method that enables the software developer to automatically find flaws and weaknesses as well as appropriate improvements in their given software architecture during the design phase. For this method I adopt Model-Based Development techniques by extending and creating Domain-Specific Languages (DSL) for specifying the architecture itself and possible architectural improvements. Using these DSLs my approach automatically suggests security enhancing improvements for the architecture promoting increased security of software architectures and as such for the developed applications as a whole.;
Proceedings of the 22nd International Conference on Model Driven Engineering Languages and Systems;Users can today download a wide variety of apps ranging from simple toy games to sophisticated business-critical apps. They rely on these apps daily to perform diverse tasks some of them related to sensitive information such as their finance or health. Ensuring high-quality reliable and secure apps is thus key. In the TruX research group of the interdisciplinary center for Security Reliability and Trust (SnT) of the University of Luxembourg we are working for about 10 years to deliver practical techniques tools and other artifacts (such as repositories) making the analysis of Android apps possible. In this paper we will briefly introduce our key contributions in both (1) Android app static analysis to detect security issues and (2) Android Malware Detection with machine learning. We will conclude by listing several open challenges that we are currently facing towards improving the analysis and security of Android apps.;
Proceedings of the 2021 International Symposium on Advanced Security on Software and Systems;Energy is important for mobile apps. Among all operations of mobile apps making HTTP requests is one of the most energy consuming. However there is not sufficient work in optimizing the energy consumption of HTTP requests in mobile apps. In our previous study we found that making small HTTP requests was not energy efficient. Yet we did not study how to optimize the energy of HTTP requests. In this paper we make a preliminary study to bundle sequential HTTP requests with a proxy server. With our technique we had a 50% energy saving for HTTP requests in two market Android apps. This result indicates that our technique is promising and we will build on the result in our future work.;
Proceedings of the 31st Annual International Conference on Computer Science and Software Engineering;Software-intensive systems are increasingly pervading our everyday lives. As they get more and more connected this opens them up to far-reaching cyber attacks. Moreover a recent study by the U.S. Department of Homeland Security shows that more than 90% of current cyber-attacks are enabled not by faulty crypto networks or hardware but by application-level implementation vulnerabilities. I argue that those problems can only be resolved by the widespread introduction of a secure software development lifecycle (SDLC). In this technical briefing I explain where secure engineering currently fails in practice and what software engineers can do if they want to make a positive impact in the field. I will do so by explaining major open challenges in the field but also by resorting to success stories from the introduction of SDLCs in industry.;
Proceedings of the 13th International Conference on Predictive Models and Data Analytics in Software Engineering;Safety cases and specifically software safety cases have had virtually no presence in engineering practice in the US. Recent interest in addition to an early attempt to introduce them into practice in the NASA Constellation Program motivated us to develop a partial safety case for a safety critical subsystem for the Ares I vehicle namely the abort detection notification and response (AFDNR) system. This paper relates our experience applying the safety case concept to AFDNR particularly from the perspective of generalizing the safety issues to similar fault management systems. We also provide lessons learned including a discussion of issues that led to our current refactoring of our initial safety case.;
Proceedings of the 1st International Workshop on Assurance Cases for Software-Intensive Systems;The strength of obfuscated software has increased over the recent years. Compiler based obfuscation has become the de facto standard in the industry and recent papers also show that injection of obfuscation techniques is done at the compiler level. In this paper we discuss a generic approach for deobfuscation and recompilation of obfuscated code based on the compiler framework LLVM. We show how binary code can be lifted back into the compiler intermediate language LLVM-IR and explain how we recover the control flow graph of an obfuscated binary function with an iterative control flow graph construction algorithm based on compiler optimizations and satisfiability modulo theories (SMT) solving. Our approach does not make any assumptions about the obfuscated code but instead uses strong compiler optimizations available in LLVM and Souper Optimizer to simplify away the obfuscation. Our experimental results show that this approach can be effective to weaken or even remove the applied obfuscation techniques like constant unfolding certain arithmetic-based opaque expressions dead code insertions bogus control flow or integer encoding found in public and commercial obfuscators. The recovered LLVM-IR can be further processed by custom deobfuscation passes that are now applied at the same level as the injected obfuscation techniques or recompiled with one of the available LLVM backends. The presented work is implemented in a deobfuscation tool called SATURN.;
Proceedings of the 20th ACM SIGPLAN International Workshop on Erlang;As mobile apps continue to grow in popularity it is important to study their evolution. Lehman's laws of software evolution have been proposed and used to study the evolution of traditional large software systems (also known as desktop apps). However do Lehman's laws of software evolution hold for mobile apps? especially since developing mobile apps presents different challenges compared to the development of desktop apps.  In this paper we examine the applicability of three of Lehman's laws on mobile apps. In particular we focused on three laws: the law of continuing change increasing complexity and declining quality. We extracted a number of metrics and performed a case study on two applications: VLC and ownCloud. Our findings show that the law of continuing change and declining quality seem to apply for mobile apps however we find different outcomes for the law of increasing complexity. Then we compare the mobile app version to the desktop version and find that the two versions follow the same trends for the law of continuing change. On the contrary the desktop and mobile version have different trends for the law of increasing complexity and the law of declining quality.;
Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security;"The increasing diffusion of smart devices along with the dynamism of the mobile applications ecosystem are boosting the production of malware for the Android platform. So far many different methods have been developed for detecting Android malware based on either static or dynamic analysis. The main limitations of existing methods include: low accuracy proneness to evasion techniques and weak validation often limited to emulators or modified kernels. We propose an Android malware detection method based on sequences of system calls that overcomes these limitations. The assumption is that malicious behaviors (e.g. sending high premium rate SMS cyphering data for ransom botnet capabilities and so on) are implemented by specific system calls sequences: yet no apriori knowledge is available about which sequences are associated with which malicious behaviors in particular in the mobile applications ecosystem where new malware and non-malware applications continuously arise. Hence we use Machine Learning to automatically learn these associations (a sort of fingerprint"" of the malware) then we exploit them to actually detect malware. Experimentation on 20000 execution traces of 2000 applications (1000 of them being malware belonging to different malware families) performed on a real device shows promising results: we obtain a detection accuracy of 97%. Moreover we show that the proposed method can cope with the dynamism of the mobile apps ecosystem since it can detect unknown malware.""";
Proceedings of the 37th Annual Computer Security Applications Conference;There can be little contention about Stroustrup's epigrammatic remark: our civilization runs on software. However a caveat is increasingly due much of the software that runs our civilization runs on mobile devices today. Mobile operating systems have come to play a preeminent role in the ubiquity and utility of such devices. The development ecosystem of Android - one of the most popular mobile operating systems - presents an interesting context for studying whether and how collaboration dynamics in mobile development differ from conventional software development. In this paper we examine factors that influence task ownership in Android development. Our results can inform project governance decisions at the individual and organizational levels.;
Proceedings of the 9th Workshop on Software Security Protection and Reverse Engineering;This poster will present a novel experimental case-study that focuses on the merits of teaching software-security to CS0 and CS1 learners by demonstration of how vulnerable programming of the Cozmo robot can lead to unexpected robot-behavior. It will introduce our unique Cozmo secure-coding lesson-plan as a new experiential-learning model which combines learning of software-security concepts with educational-robotics (ER) in the form of hands-on interactive coding. It will compare a conventional approach of teaching software-security via secure-coding lessons with our unconventional technique of teaching secure-coding using Cozmo. It will present student-survey based learning-assessment data collected from our experiment of offering secure-coding lessons to a diverse group of CS0 and CS1 learners through traditional secure-coding training-modules which involve no ER. It will then compare these data with the student-survey based learning-assessment data gathered from our Cozmo secure-coding sessions. It will analyze these comparative-results in an effort to show preliminary evidence of the effectiveness and potential of our approach for more enhanced and engaging learning of software-security via defensive programming of Cozmo. Prior research in ER indicates that a social-robot can be an effective platform for teaching coding and cyber concepts. However there is very limited work on the efficacy of teaching secure-coding using social-robots. Hence our fresh non-traditional approach of making CS0 and CS1 learners explore hands-on secure-coding through Cozmo is a first-of-its-kind research case-study in an attempt to fill this gap.;
Proceedings of the 51st ACM Technical Symposium on Computer Science Education;Android is the most popular platform for mobile devices. It facilitates sharing data and services between applications by providing a rich inter-application communication system. While such sharing can be controlled by the Android permission system enforcing permissions is not sufficient to prevent security violations since permissions may be mismanaged intentionally or unintentionally which can compromise user privacy. In this paper we provide an overview of a novel approach for compositional analysis of Android inter-application vulnerabilities entitled COVERT. Our analysis is modular to enable incremental analysis of applications as they are installed on an Android device. It extracts security specifications from application packages captures them in an analyzable formal specification language and checks whether it is safe for a combination of applications - holding certain permissions and potentially interacting with each other - to install simultaneously. To our knowledge our work is the first formally-precise analysis tool for automated compositional analysis of Android applications.;
Proceedings of the Second International Conference on Engineering Secure Software and Systems;Software security is undoubtedly a major concern in today's software engineering. Although the level of awareness of security issues is often high practical experiences show that neither preventive actions nor reactions to possible issues are always addressed properly in reality. By analyzing large quantities of commits in the open-source communities we can categorize the vulnerabilities mitigated by the developers and study their distribution resolution time etc. to learn and improve security management processes and practices.With the help of the Software Heritage Graph Dataset we investigated the commits of two of the most popular script languages - Python and JavaScript - projects collected from public repositories and identified those that mitigate a certain vulnerability in the code (i.e. vulnerability resolution commits). On the one hand we identified the types of vulnerabilities (in terms of CWE groups) referred to in commit messages and compared their numbers within the two communities. On the other hand we examined the average time elapsing between the publish date of a vulnerability and the first reference to it in a commit.We found that there is a large intersection in the vulnerability types mitigated by the two communities but most prevalent vulnerabilities are specific to language. Moreover neither the JavaScript nor the Python community reacts very fast to appearing security vulnerabilities in general with only a couple of exceptions for certain CWE groups.;
Proceedings of the 17th International Conference on Mining Software Repositories;Graph neural networks (GNNs) have proven to be an effective tool for vulnerability discovery that outperforms learning-based methods working directly on source code. Unfortunately these neural networks are uninterpretable models whose decision process is completely opaque to security experts which obstructs their practical adoption. Recently several methods have been proposed for explaining models of machine learning. However it is unclear whether these methods are suitable for GNNs and support the task of vulnerability discovery. In this paper we present a framework for evaluating explanation methods on GNNs. We develop a set of criteria for comparing graph explanations and linking them to properties of source code. Based on these criteria we conduct an experimental study of nine regular and three graph-specific explanation methods. Our study demonstrates that explaining GNNs is a non-trivial task and all evaluation criteria play a role in assessing their efficacy. We further show that graph-specific explanations relate better to code semantics and provide more information to a security expert than regular methods.;
Proceedings of the 14th ACM Workshop on Artificial Intelligence and Security;The popularity of computers and networks brings many conveniences to our daily life but also brings a variety of security threats. The proliferation of attacks and the rapid spread of viruses make security researchers gradually shift their perspective from passive defense to active defense. Among many active defenses the technique of software multi-variant execution (MVX) framework has been widely concerned. It can detect and defend most known or even 0-day attacks without depending on the feature of specific threats. However there is a big performance bottleneck in this technique. Control flow integrity (CFI) is another ideal security solution but it is not widely used in practice because of performance loss and compatibility problems. In this paper we propose a multi-variant execution framework called MVX-CFI. MVX-CFI improves execution efficiency without losing its original security. MVX-CFI is a dynamic and transparent CFI implementation based on the MVX framework. It can effectively capture the control flow of the target software and find illegal path transfer caused by malicious acts such as attacks. MVX-CFI extends the general MVX with a feedback assisted-detection module which reduces a lot of repetitive voting work of traditional MVX and improves the performance. It also provides a probability to detect preset back door in a software.;
Proceedings of the 2020 International Conference on Internet Computing for Science and Engineering;Oblivious hashing (OH) is an integrity protection technique that checks the (side) effects resulting from the executed code in contrast to checking the code itself as done by self-checking (SC). SC introduces atypical behavior in the program logic like reading the code section loaded in memory. Since such atypical behavior can be detected by attackers OH is more appealing to be employed in practice than SC. However OH is incapable of protecting a presumable majority of program instructions those that depend on nondeterministic (input) data or branches which have to be manually identified and subsequently skipped. In this paper we extend OH into a practical protection scheme by proposing i) a technique for automatic segregation of deterministic instructions and ii) a novel extension Short Range Oblivious Hashing (SROH) for OH to cover control-flow instructions dependent on nondeterministic data. Our SROH technique increases the range of instructions that OH can protect to nondeterministic branches. Moreover we intertwine OH with SC to cover (nondeterministic) data dependent instructions and enhance the resilience against tampering attacks. We evaluate the performance overhead as well as the security of our scheme using the MiBench dataset and 3 open source games. Our experiments show that the proposed technique yields a 20-fold increase in the median number of protected instructions and on non-CPU-intensive programs imposes an overhead of 52%.;
Proceedings of the 34th Annual Computer Security Applications Conference;Obfuscation is widely used to protect software against man-at-the-end attacks. Recent attacks based on semantic methods especially dynamic symbolic execution (DSE) have proven extremely powerful against standard obfuscation techniques leading several teams to investigate anti-DSE protections. Yet the domain is in its infancy and the current state of research on the topic is quite unclear. We propose a systematic review of anti-DSE techniques. In particular we propose a classification and identify strengths and weaknesses of the current lines of research as well as promising future directions.;
Proceedings of the 2010 ICSE Workshop on Software Engineering in Health Care;Popular software applications (e.g. web browsers) are targeted by malicious organizations which develop potentially unwanted programs (PUPs). If such a PUP executes on benign user devices it is able to manipulate the process memory of popular applications their locally stored resources or their environment in a profitable way for the attacker and in detriment to benign end-users. We describe the implementation of a tamper detection mechanism based on code self-checksumming able to detect static and dynamic patching of executables performed by PUPs or other attackers. As opposed to other works based on code self-checksumming our approach can also checksum instructions which contain absolute addresses affected by relocation without using calls to external libraries. We implemented this solution for the x86 ISA and evaluated the performance impact and effectiveness. The results indicate that the run-time overhead of self-checksumming grows proportionally with the level of protection which can be specified as input to our implementation. We have applied our implementation on the Chromium web-browser and observed that the overhead is practically unobservable for the end-user.;
Proceedings of the Seventh ACM on Conference on Data and Application Security and Privacy;Self-adaptive systems increasingly need to reason about and adapt both structural and behavioral system aspects such as in mobile service robots which must reason about missions that they need to achieve and the architecture of the software executing them. Deciding how to best adapt these systems to run time changes is challenging because it entails considering mutual dependencies between the software architecture that the system is running and the outcome of plans for completing tasks while also considering multiple trade-offs and uncertainties. Considering all these aspects in planning for adaptation often yields large solution spaces which cannot be adequately explored at run time. We address this challenge by proposing a planning approach able to consider the impact of mutual dependencies between software architecture and task planning on the satisfaction of mission goals. The approach is able to reason quantitatively about the outcome of adaptation decisions handling both the reconfiguration of the system's architecture and adaptation of task plans under uncertainty and in a rich trade-off space. Our results show: (i) feasibility of run-time decision-making for self-adaptation in an otherwise intractable solution space by dividing-and-conquering adaptation into architecture reconfiguration and task planning sub-problems and (ii) improved quality of adaptation decisions with respect to decision making that does not consider dependencies between architecture and task planning.;
Proceedings of the IEEE/ACM 15th International Symposium on Software Engineering for Adaptive and Self-Managing Systems;Having a precise vulnerability discovery model (VDM) would provide a useful quantitative insight to assess software security. Thus far several models have been proposed with some evidence supporting their goodness-of-fit. In this work we describe an independent validation of the applicability of these models to the vulnerabilities of the popular browsers Firefox Google Chrome and Internet Explorer. The result shows that some VMDs do not simply fit the data while for others there are both positive and negative evidences.;
Proceedings of the 4th International Conference on Engineering Secure Software and Systems;Introduction of IT in the health domain can potentially benefit the quality of the delivered healthcare also contributing to increase safety. However health IT systems themselves can have safety implications and can result in accidents. Creating a safety case has been in practice in numerous domains and is starting to be adopted in the health IT domain with the most notable example that of the UK National Health Service (NHS) Information Standards Board for Health and Social Care (ISB) standards (formerly DSCN 14/2009 &amp DSCN 18/2009). Safety cases can be thought of as a defensible comprehensible and clear argument supported by evidence that a system is acceptably safe in its operational context. This paper presents the main areas of safety case practice and its implication for the health IT development and stakeholders.;
Proceedings of the 4th International Workshop on Software Engineering in Health Care;Due to the abundance of security breaches we continue to see the software development community is recently paying attention to a more proactive approach towards security. This includes predicting vulnerability before exploitation employing static code analysis and machine learning techniques. Such mechanisms however are designed to detect post-implementation vulnerabilities. As the root of a vulnerability can often be traced back to the requirement specification and vulnerability discovered later in the development life cycle is more expensive to fix we need additional preventive mechanisms capable of predicting vulnerability at a much earlier stage. In this paper we propose a novel framework providing an automated support to predict vulnerabilities for a requirement as early as during requirement engineering. We further present a preliminary demonstration of our framework and the promising results we observe clearly indicate the value of this new research idea.;
Proceedings of the SIGCOMM '21 Poster and Demo Sessions;In this paper we discuss implementing DevOps practices in highly regulated environments (HREs). DevOps has become a standard option for entities seeking to streamline and increase participation by all stakeholders in their Software Development Lifecycle (SDLC). For a large portion of industry academia and government applying DevOps is a straight forward process. There is however a subset of entities in these three sectors where applying DevOps can be very challenging. These are entities mandated by policies to conduct all or a portion of their SDLC activities in HREs. Often the reason for an HRE is general security and protection of intellectual property. Even if an entity is functioning in a highly regulated environment its SDLC can still benefit from implementing DevOps as long as the implementation conforms to all imposed policies. In this paper we discuss the process of performing a DevOps assessment and implementation in an HRE which we refer to as HRE-DevOps.;
Proceedings of the 15th International Conference on Availability Reliability and Security;Energy assessment is important to reduce environmental impact of modern IT. This paper analyzes the total energy consumption associated with production delivery and use of application software for mobile devices and assesses its contribution to green-house gas emissions. The results reveal that as application size grows the energy consumed at the production stage becomes a dominant factor of the total lifecycle energy. However as the application becomes largely used most of the lifecycle energy is consumed at the use stage due to updates. The paper investigates dependency of lifecycle energy on the application size the number of application copies in use as well as the size of update and shows the trend. A lifecycle energy assessment of Mail K9 application is presented as a case study.;
Proceedings of the ACM Turing Celebration Conference - China;While the techniques to achieve secure privacy-preserving software are now well understood evidence shows that many software development teams do not use them: they lack the 'security maturity' to assess security needs and decide on appropriate tools and processes and they lack the ability to negotiate with product management for the required resources. This paper describes a measuring approach to assess twelve aspects of this security maturity its use to assess the impact of a lightweight package of workshops designed to increase security maturity and a novel approach within that package to support developers in resource negotiation. Based on trials in eight organizations involving over 80 developers this paper demonstrates that (1) development teams can notably improve their security maturity even in the absence of security specialists and (2) suitably guided developers can find effective ways to promote security to product management. Empowering developers to make their own decisions and promote security in this way offers a powerful grassroots approach to improving the security of software worldwide.;
Proceedings of the 43rd International Conference on Software Engineering: Software Engineering in Practice;Through a set of well-defined interfaces plug-and-play architectures enable additional functionalities to be added or removed from a system at its runtime. However plug-ins can also increase the applicationâ€™s attack surface or introduce untrusted behavior into the system. In this paper we (1) use a grounded theory-based approach to conduct an empirical study of common vulnerabilities in plug-and-play architectures (2) conduct a systematic literature survey and evaluate the extent that the results of the empirical study are novel or supported by the literature (3) evaluate the practicality of the findings by interviewing practitioners with several years of experience in plug-and-play systems. By analyzing Chromium Thunderbird Firefox Pidgin WordPress Apache OfBiz and OpenMRS we found a total of 303 vulnerabilities rooted in extensibility design decisions and observed that these plugin-related vulnerabilities were caused by 16 different types of vulnerabilities. Out of these 16 vulnerability types we identified 19 mitigation procedures for fixing them. The literature review supported 12 vulnerability types and 8 mitigation techniques discovered in our empirical study and indicated that 5 mitigation techniques were not covered in our empirical study. Furthermore it indicated that 4 vulnerability types and 11 mitigation techniques discovered in our empirical study were not covered in the literature. The interviews with practitioners confirmed the relevance of the findings and highlighted ways that the results of this empirical study can have an impact in practice.;
Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering;Context: Security work in software development is generally under-prioritized. Software developers are not aware of security engineering practices or find them external to the software development process. To the management security work presents itself in the form of reactive testing performed out of necessity incurring only costs in terms of time and resources. The long-term benefits of the security work are more difficult to demonstrate and the security investment harder to justify.Objectives: The concept of technical debt is widely used but its benefits for software security improvement and security risk management have not been fully realized. To make the direct and indirect benefits of security work in software development more visible and therefore more justifiable the security risk in software is expressed in the terms of technical debt. Correspondingly the security engineering techniques are utilized to recognize a technical debt containing a security risk: security debt.Method: The concept of managing security risk as technical debt in software development is constructed. It is then analysed using an evaluation framework drawn from literature.Result: Four central types of technical debt are considered for sources of security debt: requirements architecture code and testing. Each type of security technical debt is analyzed from the aspect of three activities: identification measurability and management and repayment. The technical and organizational effects of applying this concept are examined. The evaluation framework increases the ability to identify technical debt through security practices and to effectively mitigate security risk using technical debt management practices and tools. The framework deals with security issues in software architecture code and testing (ACT-S).Conclusion: Security engineering techniques provide an effective method to recognize internal quality issues in software requirements architecture coding and testing. When expressed as technical debt the management of security risk and addressing the underlying quality issues can gain increased visibility and can be more communicated between developers security experts and the management.;
Proceedings of the 2013 International Conference on Software Engineering;Diversity has been suggested as an effective alternative to the current trend in rules-based approaches to cybersecurity. However little work to date has focused on how various techniques generalize to new attacks. That is there is no accepted methodology that researchers use to evaluate diversity techniques. Starting with the hypothesis that an attacker's effort increases as the common set of executable code snippets (return-oriented programming (ROP) gadgets) decreases across application variants we explore how different diversification techniques affect the set of ROP gadgets that is available to an attacker. We show that a small population of diversified variants is sufficient to eliminate 90-99% of ROP gadgets across a collection of real-world applications. Finally we observe that the number of remaining gadgets may still be sufficient for an attacker to mount an effective attack regardless of the presence of software diversity.;
Proceedings of the 19th International Conference on Evaluation and Assessment in Software Engineering;The amount and impact of software-dependence in critical systems impinging on daily life is increasing rapidly. In many of these systems inadequate software and systems engineering can lead to economic disaster injuries or death. Society generally does not recognize the potential of losses from deficiencies of systems due to software until after some mishap occurs. Then there is an outcry reflecting societal expectations however few know what it takes to achieve the expected safety and in general loss-prevention.  On the one hand there are unprecedented exponential increases in size inter-dependencies intricacies numbers and variety in the systems and distribution of development processes across organizations and cultures. On the other hand industry's capability to verify and validate these systems has not kept up. Mere compliance with existing standards techniques and regulations cannot guarantee the safety properties of these systems. The gap between practice and capability is increasing rapidly.  This paper considers the future of software engineering as needed to support development and certification of safety-critical software-dependent systems. We identify a collection of challenges and document their current state the desired state gaps and barriers to reaching the desired state and potential directions in software engineering research and education that could address the gaps and barriers.;
Future of Software Engineering Proceedings;The awareness of writing secure code rises with the increasing number of attacks and their resultant damage. But often software developers are no security experts and vulnerabilities arise unconsciously during the development process. They use static analysis tools for bug detection which often come with a high false positive rate. The developers therefore need a lot of resources to mind about all alarms if they want to consistently take care of the security of their software project. We want to investigate if machine learning techniques could point the user to the position of a security weak point in the source code with a higher accuracy than ordinary methods with static analysis. For this purpose we focus on current machine learning on code approaches for our initial studies to evolve an efficient way for finding security-related software bugs. We will create a configuration interface to discover certain vulnerabilities categorized in CWEs. We want to create a benchmark tool to compare existing source code representations and machine learning architectures for vulnerability detection and develop a customizable feature model. At the end of this PhD project we want to have an easy-to-use vulnerability detection tool based on machine learning on code.;
Proceedings of the 10th International Workshop on Variability Modelling of Software-Intensive Systems;Programmersâ€™ lack of knowledge and interest in secure development threatens everyone who uses mobile apps. The rise of apps has engaged millions of independent app developers who rarely encounter any but low level security techniques. But what if software security were presented as a game or a story or a discussion? What if learning app security techniques could be fun as well as empowering? Only by introducing the powerful motivating techniques developed for other disciplines can we hope to upskill independent app developers and achieve the security that weâ€™ll need in 2025 to safeguard our identities and our data.;
Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering;Software deobfuscation is a key challenge in malware analysis to understand the internal logic of the code and establish adequate countermeasures. In order to defeat recent obfuscation techniques state-of-the-art generic deobfuscation methodologies are based on dynamic symbolic execution (DSE). However DSE suffers from limitations such as code coverage and scalability. In the race to counter and remove the most advanced obfuscation techniques there is a need to reduce the amount of code to cover. To that extend we propose a novel deobfuscation approach based on semantic equivalence called DoSE. With DoSE we aim to improve and complement DSE-based deobfuscation techniques by statically eliminating obfuscation transformations (built on code-reuse). This improves the code coverage. Our method's novelty comes from the transposition of existing binary diffing techniques namely semantic equivalence checking to the purpose of the deobfuscation of untreated techniques such as two-way opaque constructs that we encounter in surreptitious software. In order to challenge DoSE we used both known malwares such as Cryptowall WannaCry Flame and BitCoinMiner and obfuscated code samples. Our experimental results show that DoSE is an efficient strategy of detecting obfuscation transformations based on code-reuse with low rates of false positive and/or false negative results in practice and up to 63% of code reduction on certain types of malwares.;
Proceedings of the 8th Software Security Protection and Reverse Engineering Workshop;This paper realizes the network security assessment model based on hidden Markov. Firstly the principle and basic problem of Hidden Markov Model are analyzed. Select the Snort software alarm as the input convert the alarm into the quantification value of the network security risk model and quantify the network security in real time then design and implement the whole Hidden Markov Model.;
Proceedings of the 2017 International Conference on Wireless Communications Networking and Applications;A white-box implementation of the Advanced Encryption Standard (AES) is a software implementation which aims to prevent recovery of the block cipher's master secret key. This paper refines the design criteria for white-box AES constructions by describing new attacks on past proposals which are conceptually very simple and introduces a new family of white-box AES constructions. Our attacks have a decomposition phase followed by a disambiguation phase. The decomposition phase applies an SASAS-style cryptanalysis to convert the implementation into a simpler form while the disambiguation phase converts the simpler form into a unique canonical form. It's then trivial to recover the master secret key of the implementation from its canonical form. We move on to discuss the hardness of SPN disambiguation as a problem on its own and how to construct white-boxes from it. Implementations of all described attacks and constructions are provided on GitHub at https://github.com/OpenWhiteBox/;
Proceedings of the Nineth ACM Workshop on Digital Rights Management;"Ontology"" in association with ""software engineering"" is becoming commonplace. This paper argues for the need to place ontologies at the centre of the software development lifecycle for multi agent systems to enhance reuse of software workproducts as well as to unify agent-based software engineering knowledge. The paper bridges the state-of-the-art of ontologies research from Knowledge Engineering (KE) within Artificial Intelligence and Metamodelling within Software Engineering (SE). It presents a sketch of an ontology-based Multi Agent System (MAS) methodology discussing key roles on ontologies and their impact of workproducts illustrating these in a MAS software development project for an important application that utilizes dynamic web services composition.""";
Proceedings of the Fifth Australasian Ontology Workshop - Volume 112;As shown in previous work malware authors often reuse portions of code in the development of their samples. Especially in the mobile scenario there exists a phenomena called piggybacking that describes the act of embedding malicious code inside benign apps. In this paper we leverage such observations to analyze mobile malware by looking at its similarities. In practice we propose a novel approach that identifies and extracts code similarities in mobile apps. Our approach is based on static analysis and works by computing the Control Flow Graph of each method and encoding it in a feature vector used to measure similarities. We implemented our approach in a tool GroupDroid able to group mobile apps together according to their code similarities. Armed with Group-Droid we then analyzed modern mobile malware samples. Our experiments show that GroupDroid is able to correctly and accurately distinguish different malware variants and to provide useful and detailed information about the similar portions of malicious code.;
Proceedings of the 25th ACM International Systems and Software Product Line Conference - Volume A;"With the advancement of Internet in Things (IoT) more and more things"" are connected to each other through the Internet. Due to the fact that the collected information may contain personal information of the users it is very important to ensure the security of the devices in IoT.Diversification is a promising technique that protects the software and devices from harmful attacks and malware by making interfaces unique in each separate system. In this paper we apply diversification on the interfaces of IoT operating systems. To this aim we introduce the diversification in post-compilation and linking phase of the software life-cycle by shuffling the order of the linked objects while preserving the semantics of the code. This approach successfully prevents malicious exploits from producing adverse effects in the system. Besides shuffling we also apply library symbol diversification method and construct needed support for it e.g. into the dynamic loading phase.Besides studying and discussing memory layout shuffling and symbol diversification as a security measures for IoT operating systems we provide practical implementations for these schemes for Thingsee OS and Raspbian operating systems and test these solutions to show the feasibility of diversification in IoT environments.""";
Proceedings of the 9th International Conference on Utility and Cloud Computing;We present two techniques to obfuscate the interfaces between application binaries and Windows system DLLs (dynamic-link libraries). The first technique obfuscates the related symbol information in the binary to prevent static analyses from identifying the invoked library functions. The second technique combines static linking with code obfuscation to avoid the external interface altogether thus preventing dynamic attacks as well. This is done while still maintaining compatibility with multiple Windows versions through run-time adaptation of the application. As the first concrete result of this ongoing research we demonstrate and evaluate the techniques using a proof-of-concept tool applied to a simple test program.;
Proceedings of the International Conference on Advances in Computing Communications and Informatics;Open source software (OSS) is a core part of virtually all software applications today. Due to the rapidly growing impact of OSS on society and the economy the security aspect has attracted researchers' attention to investigate this distinctive phenomenon. Traditionally research on OSS security has often focused on technical aspects of software development. We argue that these aspects are important however technical security practice considering different social aspects of OSS development will assure the effectiveness and efficiency of the implementation of the tool. To mitigate this research gap in this empirical study we explore the current security culture in the OSS development phenomenon using a survey instrument with six evaluation dimensions: attitude behavior competency subjective norms governance and communication. By exploring the current security culture in OSS communities we can start to understand the influence of security on participants' security behaviors and decision-making so that we can make realistic and practical suggestions. In this paper we present the measurements of security culture adopted in the study and discuss corresponding security issues that need to be addressed in OSS communities.;
Proceedings of the 2019 IEEE/ACM International Conference on Advances in Social Networks Analysis and Mining;Device drivers rely on fine-grained locking to ensure safe access to shared data structures. For human testers concurrency makes such code notoriously hard to debug for automated reasoning dynamically allocated memory and low-level pointer manipulation poses significant challenges. We present a flexible approach to data race analysis implemented in the open source Goblint static analysis framework that combines different pointer and value analyses in order to handle a wide range of locking idioms including locks allocated dynamically as well as locks stored in arrays. To the best of our knowledge this is the most ambitious effort having lasted well over ten years to create a fully automated static race detection tool that can deal with most of the intricate locking schemes found in Linux device drivers. Our evaluation shows that these analyses are sufficiently precise but practical use of these techniques requires inferring environmental and domain-specific assumptions.;
Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering;Authorization is a key aspect in secure software development of multi-user applications. Authorization is often enforced in the program code with enforcement statements. Since authorization is present in numerous places defects in the enforcement are difficult to discover. One approach to this challenge is to improve the developer usability with regard to authorization. We analyze how software development is affected by authorization in a real-world case study and particularly focus on the loose-coupling properties of authorization frameworks that separate authorization policy from enforcement. We show that authorization is a significant aspect in software development and that the effort can be reduced through appropriate authorization frameworks. Lastly we formulate advice on the design of enforcement APIs.;
Proceedings of the 29th Annual International Conference on Computer Science and Software Engineering;Trusted Computing (TC) is a valuable technology to use when we need to process highly sensitive data and several variants of it are now available. We present here a pattern that describes the architecture of a standard for TC the Trusted Platform Module (TPM) which is an architecture for which there are several possible implementations. Standards are effectively patterns because of the freedom to implement them in a variety of ways. The TPM architecture contains cryptographic functions to attest the use of legitimate hardware and software platforms and defines operations to perform related trusted operations. Some of its variants are intended to only store private keys in a secure way. Although promising this technology often has not been properly used. This motivated us for defining a comprehensive methodology that facilitates the design and development of secure TC-equipped systems that can fully exploit the functionalities that this technology provides. This paper provides the first step of this methodology in the form of a security pattern. We have tried to provide a reasonable amount of information in our pattern description aimed at the needs of application designers. This pattern is described in an abstract form independent of implementation details but expressed with enough detail and precision for the use of designers.;
Proceedings of the European Conference on Pattern Languages of Programs 2020;This paper proposes a method for evaluating the artificiality of protected code by means of an N-gram model. The proposed artificiality metric helps us measure the stealth of the protected code that is the degree to which protected code can be distinguished from unprotected code. In a case study we use the proposed method to evaluate the artificiality of programs that are transformed by well-known obfuscation techniques. The results show that static obfuscating transformations (e.g. control flow flattening) have little effect on artificiality. However dynamic obfuscating transformations (e.g. code encryption) or a technique that inserts junk code fragments into the program tend to increase the artificiality which may have a significant impact on the stealth of the code.;
Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering;With growing dependence on software in embedded and cyber-physical systems where vulnerabilities and malware can lead to disasters efficient and accurate verification has become a crucial need for safety and cybersecurity. Formal verification of large software has remained an elusive target riddled with problems of low accuracy and high computational complexity [9 11 16 18]. The need for automating verification is undoubted however human is indispensable to accurate real-world software verification. The automation should actually enable and simplify human crosschecking which is especially important when the stakes are high. This technical briefing discusses the challenges of creating a powerful fusion of automation and human intelligence to solve software verification problems where complete automation has remained intractable. We will contrast with existing software verification approaches and reflect on their strengths and limitations as a human-machine collaboration framework and outline key software engineering research and practice challenges to be addressed in the future.;
Proceedings of the 31st Annual ACM Symposium on Applied Computing;A method to identify input-dependent jumps from the execution of obfuscated machine code is presented. Input-dependent jumps which are defined as jumps whose target addresses can be changed depending on the input correspond to decision points in program execution. By investigating how a target address is calculated it is possible to pinpoint the triggering conditions of a given behavior and new execution paths can be discovered by finding input values that change the target address. Obfuscators hinder such analysis by inserting numerous artificial jumps that use opaque predicates with constant values into the code. One important obfuscation approach is virtualization-obfuscation in which entire blocs of control flow information are replaced with bytecode interpreter code. Using the fact that the semantics of the original program must be preserved under obfuscation we propose an obfuscation mitigation approach that exploits the relationship between the original and obfuscated executions using dynamic data flow graphs that represent output computation using concrete and symbolic information. These graphs are generated from execution traces that are recorded using dynamic binary instrumentation and simplified using pattern-based rules based on algebraic identities and the general properties of well-behaved programs. To identify input-dependent jumps a dynamic data flow graph is generated and simplified for each write access to the program counter if the node for the target address is reachable from a node for an input value in the resulting graph the jump is input-dependent. Experimental application of the proposed approach to code treated with various obfuscators successfully revealed the relationship between input-dependent jumps in the original and obfuscated executions confirming that information obtained from dynamic data flow graphs is useful in understanding branch conditions.;
Proceedings of the The International Conference on Engineering &amp MIS 2015;Security is an increasing concern in software development. Developer Question and Answer (Q&ampA) websites provide a large amount of security discussion. Existing studies have used human-defined rules to mine security discussions but these works still miss many posts which may lead to an incomplete analysis of the security practices reported on Q&ampA websites. Traditional supervised Machine Learning methods can automate the mining process however the required negative (non-security) class is too expensive to obtain. We propose a novel learning framework PUMiner to automatically mine security posts from Q&ampA websites. PUMiner builds a context-aware embedding model to extract features of the posts and then develops a two-stage PU model to identify security content using the labelled Positive and Un-labelled posts. We evaluate PUMiner on more than 17.2 million posts on Stack Overflow and 52611 posts on Security StackExchange. We show that PUMiner is effective with the validation performance of at least 0.85 across all model configurations. Moreover Matthews Correlation Coefficient (MCC) of PUMiner is 0.906 0.534 and 0.084 points higher than one-class SVM positive-similarity filtering and one-stage PU models on unseen testing posts respectively. PUMiner also performs well with an MCC of 0.745 for scenarios where string matching totally fails. Even when the ratio of the labelled positive posts to the un-labelled ones is only 1:100 PUMiner still achieves a strong MCC of 0.65 which is 160% better than fully-supervised learning. Using PUMiner we provide the largest and up-to-date security content on Q&ampA websites for practitioners and researchers.;
Proceedings of the 2020 International Conference on Cyberspace Innovation of Advanced Technologies;Gaining reliable arbitrary code execution through the exploitation of memory corruption vulnerabilities is becoming increasingly more difficult in the face of modern exploit mitigations. Facing this challenge adversaries have started shifting their attention to data leakage attacks which can lead to equally damaging outcomes such as the disclosure of private keys or other sensitive data.In this work we present a compiler-level defense against data leakage attacks for user-space applications. Our approach strikes a balance between the manual effort required to protect sensitive application data and the performance overhead of achieving strong data confidentiality. To that end we require developers to simply annotate those variables holding sensitive data after which our framework automatically transforms only the fraction of the entire program code that is related to sensitive data operations. We implemented this approach by extending the LLVM compiler and used it to protect memory-resident private keys in the MbedTLS server ssh-agent and a Libsodium-based file signing program as well as user passwords for Lighttpd and Memcached. Our results demonstrate the feasibility and practicality of our technique: a modest runtime overhead (e.g. 13% throughput reduction for MbedTLS) that is on par with or better than existing state-of-the-art memory safety approaches for selective data protection.;
Proceedings of the 23rd Conference on Pattern Languages of Programs;The Java runtime is installed on billions of devices worldwide and over years it has been a primary attack vector for online criminals. In this work we address that many attack vectors exploit weaknesses in Java's information hiding making use of illegal access to private members of system classes. To study to what extent such attacks can be mitigated and at what cost this paper demonstrates a proof-of-concept solution to strengthen information hiding. Experiments show that this approach is backward compatible and that it blocks 84% of all information-hiding attacks in a large-scale sample set at an average performance overhead below 2%. Based on our experiments we suggest a solution to strengthen information hiding for productive use that has the potential to outperform our proof of concept in terms of robustness and performance and also would block the remaining information-hiding attacks. Finally we conclude with general advice on the design of secure software.;
Abstract Proceedings of the 2021 ACM SIGMETRICS / International Conference on Measurement and Modeling of Computer Systems;"Malware authors make use of several techniques to obfuscate code from reverse engineering tools such as IdaPro. Typically these techniques tend to be effective for about three to six instructions but eventually the tools can properly disassemble the remaining code once the tool is again synchronized with the operation codes. But this loss of synchronization can be used to hide information within the instructions -- steganography. Our research explores an approach to this by presenting Weaver"" a framework for executable steganography. ""Weaver"" differs from other techniques in how it hides malicious instructions: the hiding instructions are prepared by generating an assembly listing of the program and finding candidate hiding locations the steganography instructions are prepared by creating an assembly listing of the program to obtain the operation codes to be hidden and the ""weaving"" process merges the two. This ""weaving"" attempts to place all the steganography instructions into candidate locations found in the hiding instructions.""";
Proceedings of the 21th ACM/IEEE International Conference on Model Driven Engineering Languages and Systems;The goal of secure software engineering is to create software that keeps performing as intended even when exposed to an active attacker. Threat modelling is considered to be a key activity but can be challenging to perform for developers. Microsoft has tried to lower the bar through creating a threat modelling game called Elevation of Privilege (EoP) but anecdotal evidence suggests that it has seen little use in actual development projects. To learn more about challenges facing adoption of EoP we performed a case study in a university setting comprising several agile development projects. The results show that the game aided in discussing and learning about software security but the impact on development seems to have been limited. In addition challenges related to game dynamics relevance of hints on the cards and the time needed to play the game limits the acceptance of the game.;
Proceedings of the 2017 New Security Paradigms Workshop;Assembling an information security management system according to the ISO 27001 standard is difficult because the standard provides only sparse support for system development and documentation.We analyse the ISO 27001 standard to determine what techniques and documentation are necessary and instrumental to develop and document systems according to this standard. Based on these insights we inspect a number of current security requirements engineering approaches to evaluate whether and to what extent these approaches support ISO 27001 system development and documentation. We re-use a conceptual framework originally developed for comparing security requirements engineering methods to relate important terms techniques and documentation artifacts of the security requirements engineering methods to the ISO 27001.;
Proceedings of the International Conference for High Performance Computing Networking Storage and Analysis;We present RAPID an industrial-strength analysis developed at AWS that aims to help developers by providing automatic fast and actionable feedback about correct usage of cloud-service APIs. RAPIDâ€™s design is based on the insight that cloud service APIs are structured around short-lived request- and response-objects whose usage patterns can be specified as value-dependent type-state automata and be verified by combining local type-state with global value-flow analyses. We describe various challenges that arose to deploy RAPID at scale. Finally we present an evaluation that validates our design choices deployment heuristics and shows that RAPID is able to quickly and precisely report a wide variety of useful API misuse violations in large industrial-strength code bases.;
Proceedings of the 5th International Workshop on Software Engineering in Health Care;Complex software systems are often not designed with the principle of least privilege which requires each component be given the minimum amount of privileges to function. As a result software vulnerabilities in less privileged code can lead to privilege escalation defeating security and privacy. Privilege separation is the process of automatically partitioning a software system into least privileged components and we argue that it is effective at reducing the attack surface. However previous privilege-separation systems do not provide fine-grained separation of privileged code and non-privileged code co-existing in the same function for C/C++ applications. We propose a fine-grained partitioning technique for supporting fine-grained separation in automatic program partitioning. The technique has been applied to a set of security-sensitive networking and interactive programs. Results show that it can automatically generate executable partitions for C applications further partitioned programs incur acceptable runtime overheads.;
Proceedings of the 14th European Workshop on Systems Security;Businesses often interact with users via web-browsers and applications on mobile devices and host services on cloud servers they may not own. Such highly-exposed environments employ white-box cryptography (WBC) for security protection. WBC operates on a security model far different from the traditional black-box model. The modern business world includes large commercial segments in which end-users are directly exposed to business application software hosted on web browsers mobile phones web-connected tablets and an increasing number of other devices: the `internet of things' (IoT). Software applications and their communication activities now dominate much of the commercial world and there have been countless hacks on such software and on devices hosting it with targets as diverse as mobile phones web browser applications vehicles and even refrigerators! The business advantages of deploying computational power near the user encourage software migration to exposed network end-points but this increasing exposure provides an ever growing attack surface. Here we discuss goals and challenges of white-box cryptography and emerging approaches in a continual attempt to stay at least one step ahead of the attackers. We list some WBC techniques both traditional and recent indicating how they might be incorporated into a WBC AES implementation.;
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security;The feedback from architectural decisions to the elaboration of requirements is an established concept in the software engineering community. However pinpointing the nature of this feedback in a precise way is a largely open problem. Often the feedback is generically characterized as additional qualities that might be affected by an architect's choice. This paper provides a practical perspective on this problem by leveraging architectural security patterns. The contribution of this paper is the Security Twin Peaks model which serves as an operational framework to co-develop security in the requirements and the architectural artifacts.;
Proceedings of the 6th International Conference on Information and Education Technology;Trust has become essential in computer science as a way of assisting the process of decision-making such as access control. In any system several tasks may be performed and each of these tasks might pose different associated trust values between the entities of the system. For instance in a file system reading and overwriting a file are two tasks that pose different trust values between the users who can carry out them. In this paper we propose a model for automatically establishing trust relationships between entities considering an established order among tasks.;
Proceedings of the 2018 International Conference on Software and System Process;We propose a novel methodology that allows automatic construction of benchmarks for Static Analysis Security Testing (SAST) tools based on real-world software projects by differencing vulnerable and fixed versions in FOSS repositories. The methodology allows us to evaluate ``actual'' performance of SAST tools (without unrelated alarms). To test our approach we benchmarked 7 SAST tools (although we report only results for the two best tools) against 70 revisions of four major versions of Apache Tomcat with 62 distinct CVEs as the source of ground truth vulnerabilities.;
Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering;"Developers of autonomous systems face distinct challenges in conforming to established methods of validating safety. It is well known that testing alone is insufficient to assure safety because testing long enough to establish ultra-dependability is generally impractical. Thatfis why software safety standards emphasize high quality development processes. Testing then validates process execution rather than directly validating dependability.Two significant challenges arise in applying traditional safety processes to autonomous vehicles. First simply gathering a complete set of system requirements is difficult because of the sheer number of combinations of possible scenarios and faults. Second autonomy systems commonly use machine learning (ML) in a way that makes the requirements and design of the system opaque. After training usually we know what an ML component will do for an input it has seen but generally not what it will do for at least some other inputs until we try them. Both of these issues make it difficult to trace requirements and designs to testing as is required for executing a safety validation process. In other words we are building systems that can not be validated due to incomplete or even unknown requirements and designs.Adaptation makes the problem even worse by making the system that must be validated a moving target. In the general case it is impractical to validate all the possible adaptation states of an autonomy system using traditional safety design processes.An approach that can help with the requirements design and adaptation problems is basing a safety argument not on correctness of the autonomy functionality itself but rather on conformance to a set of safety envelopes. Each safety envelope describes a boundary within the operational state space of the autonomy system.A system operating within a safe"" envelope knows that it is safe and can operate with full autonomy. A system operating within an ""unsafe"" envelope knows that it is unsafe and must invoke a failsafe action. Multiple partial specifications can be used as an envelope set with the intersection of safe envelopes permitting full autonomy and the union of unsafe envelopes provoking validated and potentially complex failsafe responses.Envelope mechanisms can be implemented using traditional software engineering techniques reducing the problems with requirements design and adaptation that would otherwise impede safety validation. Rather than attempting to prove that autonomy will always work correctly (which is still a valuable goal to improve availability) the envelope approach measures the behavior of one or more autonomous components to determine if the result is safe. While this is not necessarily an easy thing to do there is reason to believe that checking autonomy behaviors for safety is easier than implementing perfect optimized autonomy actions. This envelope approach might be used to detect faults during development and to trigger failsafes in fleet vehicles.Inevitably there will be tension between simplicity of the envelope definitions and permissiveness with more permissive envelope definitions likely being more complex. Operating in the gap areas between ""safe"" and ""unsafe"" requires human supervision because the autonomy system can not be sure it is safe.One way to look at the progression from partial to full autonomy is that over time systems can increase permissiveness by defining and growing ""safe"" envelopes shrinking ""unsafe"" envelopes and eliminating any gap areas.""";
Proceedings of the 1st International Workshop on Safe Control of Connected and Autonomous Vehicles;Due to the popularization of Android and the full range of applications (apps) targeting this platform many security issues have emerged attracting researchers and practitioners' attention. As such many techniques for addressing security Android issues appeared including approaches for mining sandboxes. Previous research studies have compared Android test case generation tools for this specific goal. Our research aims to explore new techniques for mining sandboxes especially we are interested in understanding the limits of both static and dynamic analysis in this process. Although the use of tests for mining sandboxes has been explored before the potential to combine static analysis and dynamic analysis has not been sufficiently investigated yet. That is in this thesis we will investigate the hypothesis that combining static and dynamic analysis techniques increases the process of mining Android sandboxes.;
Proceedings of the 43rd International Conference on Software Engineering: Companion Proceedings;Trusted Execution Environment (TEE) is designed to deliver a safe execution environment for software systems. Intel Software Guard Extensions (SGX) provides isolated memory regions (i.e. SGX enclaves) to protect code and data from adversaries in the untrusted world. While existing research has proposed techniques to execute entire executable files inside enclave instances by providing rich sets of OS facilities one notable limitation of these techniques is the unavoidably large size of Trusted Computing Base (TCB) which can potentially break the principle of least privilege.In this work we describe techniques that provide practical and efficient protection of security sensitive code components in legacy binary code. Our technique dissects input binaries into multiple components which are further built into SGX enclave instances. We also leverage deliberately-designed binary editing techniques to retrofit the input binary code and preserve the original program semantics. Our tentative evaluations on hardening AES encryption and decryption procedures demonstrate the practicability and efficiency of the proposed technique.;
Proceedings of the 2017 Workshop on Forming an Ecosystem Around Software Transformation;The critical nature of safety in medical device software requires a repeatable and compliant software engineering process. This process should take into account the whole development life cycle risk management and software verification and validation activities that would commensurate with the device's complexity and risk. This paper discusses some of the key challenges medical device manufacturers are facing in the development and certification of medical device software. These challenges include: compliance with the EU and US regulatory requirements for medical device software making software development and maintenance processes more agile in the medical device regulatory environment integrating usability engineering process/human factors into software development regulation of networked medical devices and mobile medical applications (apps). The MED-EL case study highlights some of the challenges described in this paper and the approaches taken to overcome these challenges.;
Proceedings of the 4th International Conference on Information and Network Security;Static security analysis of software has made great progress over the last years. In particular this applies to the detection of low-level security bugs such as buffer overflows Cross-Site Scripting and SQL injection vulnerabilities. Complementarily to commercial static code review tools we present an approach to the static security analysis which is based upon the software architecture using a reverse engineering tool suite called Bauhaus. This allows one to analyze software on a more abstract level and a more focused analysis is possible concentrating on software modules regarded as security-critical. In addition certain security flaws can be detected at the architectural level such as the circumvention of APIs or incomplete enforcement of access control. We discuss our approach in the context of a business application and Android's Java-based middleware.;
Proceedings of the 2021 ACM Conference on Fairness Accountability and Transparency;Quantitative analysis and forecasting of software vulnerability discoveries is important for patching cost and time estimation and as input to security metrics and risk assessment methodologies. However as of now quantitative studies (a) require considerable manual effort (b) make use of noisy datasets and (c) are especially challenging to reproduce. In this poster abstract we describe our ongoing work towards quantitative analysis of vulnerabilities in Debian GNU/Linux packages. We focus on the challenges of making the process as automated and reproducible as possible while collecting good-quality data necessary for the analysis. We then state a number of interesting hypotheses that can be investigated and present preliminary results.;
Proceedings of the 21st Western Canadian Conference on Computing Education;Declarative policies are a common means to manage the security of complex IT environments and they belong to different heterogeneous classes (access control filtering data protection etc.). Their enforcement requires the selection and configuration of appropriate enforcement mechanisms whose dependencies in a given environment may result in conflicts typically not foreseeable at policy design time. Such conflicts may cause security vulnerabilities and non compliance their identification and correction is costly. Detecting transversal policy conflicts i.e. conflicts happening across different policy classes constitutes a challenging problem and this work makes a step forward towards its formalization.;
Proceedings of the 18th ACM Conference on Computer and Communications Security;In finance leverage is the ratio between assets borrowed from others and one's own assets. A matching situation is present in software: by using free open-source software (FOSS) libraries a developer leverages on other people's code to multiply the offered functionalities with a much smaller own codebase. In finance as in software leverage magnifies profits when returns from borrowing exceed costs of integration but it may also magnify losses in particular in the presence of security vulnerabilities. We aim to understand the level of technical leverage in the FOSS ecosystem and whether it can be a potential source of security vulnerabilities. Also we introduce two metrics change distance and change direction to capture the amount and the evolution of the dependency on third-party libraries.The application of the proposed metrics on 8494 distinct library versions from the FOSS Maven-based Java libraries shows that small and medium libraries (less than 100KLoC) have disproportionately more leverage on FOSS dependencies in comparison to large libraries. We show that leverage pays off as leveraged libraries only add a 4% delay in the time interval between library releases while providing four times more code than their own. However libraries with such leverage (i.e. 75% of libraries in our sample) also have 1.6 higher odds of being vulnerable in comparison to the libraries with lower leverage.We provide an online demo for computing the proposed metrics for real-world software libraries available under the following URL: https://techleverage.eu/.;
Companion Proceedings of the Web Conference 2020;Success of software development process is defined by its ability to transform the business objectives into requirements and further into features and functionality. In addition to business objectives software development also has security objectives requiring security engineering activities. In contrast to the iterative and incremental software development process software security engineering is defined by sequential life cycle models: security and business objectives are thus implemented using conflicting approaches. To identify the incompatibilities between the methodologies in this study the security engineering activities are mapped into common agile software development practises processes and artifacts. Security engineering activities from Microsoft SDL the ISO Common Criteria and OWASP SAMM security development lifecycle models are mapped into common agile processes practises and artifacts. The organizational and technical aspects of the mapping are considered primarily from the point of view of achieving the security objectives set for the software engineering process: setting security requirements for design their implementation and verification and releasing secure software through efficient software security development process.;
Proceedings of the 2016 ACM Workshop on Automated Decision Making for Active Cyber Defense;This paper presents a fully automated technique to find and trigger Use-After-Free vulnerabilities (UAF) on binary code. The approach combines a static analyzer and a dynamic symbolic execution engine. We also introduce several original heuristics for the dynamic symbolic execution part speeding up the exploration and making this combination effective in practice. The tool we developed is open-source and it has successfully been applied on real world vulnerabilities. As an example we detail a proof-of-concept exploit triggering a previously unknown vulnerability on JasPer leading to the CVE-2015-5221.;
Proceedings of the 2nd ACM International Workshop on Cyber-Physical System Security;"Java Card 3.0 specifications have brought many new features in the Java Card world amongst which a true garbage collection mechanism. In this paper we show how one could use this specific feature to predict the references that will be assigned to object instances to be created. We also exploit this reference prediction process in a combined attack. This attack stands as a kind of application replay"" attack taking advantage of an unspecified behavior of the Java Card Runtime Environment (JCRE) on application instance deletion. It reveals quite powerful since it potentially permits the attacker to circumvent the application firewall: a fundamental and historical Java Card security mechanism. Finally we point out that this breach comes from the latest specification update and more precisely from the introduction of the automatic garbage collection mechanism which leads to a straightforward countermeasure to the exposed attack.""";
Proceedings of the Fifth Cybersecurity Symposium;Applications in C/C++ are notoriously prone to memory corruptions. With significant research efforts devoted to this area of study the security threats posed by previously popular vulnerabilities such as stack and heap overflows are not as serious as before. Instead we have seen the meteoric rise of attacks exploiting use-after-free (UaF) vulnerabilities in recent years which root in pointers pointing to freed memory (i.e. dangling pointers). Although various approaches have been proposed to harden software against UaF none of them can achieve robustness and efficiency at the same time. In this paper we present a novel defense called pSweeper to robustly protect against UaF exploits with low overhead and pinpoint the root-causes of UaF vulnerabilities with one safe crash. The success of pSweeper lies in its two unique and innovative design ideas concurrent pointer sweeping (CPW) and object origin tracking (OOT). CPW exploits the increasingly available multi-cores on modern PCs and outsources the heavyweight security checks and enforcement to dedicated threads that can run on spare cores. Specifically CPW iteratively sweeps all live pointers in a concurrent thread to find dangling pointers. This design is quite different from previous work that requires to track every pointer propagation to maintain accurate point-to relationship between pointers and objects. OOT can help to pinpoint the root-causes of UaF by informing developers of how a dangling pointer is created i.e. how the problematic object is allocated and freed. We implement a prototype of pSweeper and validate its efficacy in real scenarios. Our experimental results show that pSweeper is effective in defeating real-world UaF exploits and efficient when deployed in production runs.;
Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security;"Security of software systems is of general concern yet breaches caused by common vulnerabilities still occur. Software developers are routinely called upon to do more"" to address this situation. However there has been little focus on the developers' point of view and understanding how security features in their day-to-day activities. This paper reports preliminary findings of semi-structured interviews taken during an ethnographic study of professional software developers in one organization who are not security experts. The overall study aims to understand how security features in day-to-day practice while analysis of the interview data asks whether developers are responsible for security. The study reveals that awareness around security matters is raised through several paths including processes standards practices and company training and that a focus on security is driven by contextual factors. Security is taken care of with policies and through safeguards and is handled differently depending on whether a team is developing new features and hence ""looking forward"" or working with existing code and hence ""looking back"". Developers take and share responsibility for security in the code but suggest that their responsibility has limits and relies on collective practice.""";
Proceedings of the 12th International Workshop on Cooperative and Human Aspects of Software Engineering;Process-level virtualization is increasingly being used to enhance the security of software applications from reverse engineering and unauthorized modification (called software protection). Process-level virtual machines (PVMs) can safeguard the application code at run time and hamper the adversary's ability to launch dynamic attacks on the application. This dynamic protection combined with its flexibility ease in handling legacy systems and low performance overhead has made process-level virtualization a popular approach for providing software protection. While there has been much research on using process-level virtualization to provide such protection there has been less research on attacks against PVM-protected software. In this paper we describe an attack on applications protected using process-level virtualization called a replacement attack. In a replacement attack the adversary replaces the protecting PVM with an attack VM thereby rendering the application vulnerable to analysis and modification. We present a general description of the replacement attack methodology and two attack implementations against a protected application using freely available tools. The generality and simplicity of replacement attacks demonstrates that there is a strong need to develop techniques that meld applications more tightly to the protecting PVM to prevent such attacks.;
Proceedings of the 8th ACM SIGPLAN/SIGOPS Conference on Virtual Execution Environments;This paper describes materials developed to engage professional developers in discussions about security. First the work is framed in the context of ethnographic studies of software development highlighting how the method is used to explore and investigate research aims for the Motivating Jenny research project. A description is given of a series of practitioner engagements that were used to develop a reflection and discussion tool using security stories taken from media and internet sources. An explanation is given for how the tool has been used to collect data within field sites offering a way to clarify and member check findings and to provide a different view on practice and process. The report concludes with observations and notes about future aims for supporting and encouraging professionals to engage with security in practice.;
Proceedings of the Joint 7th International Workshop on Conducting Empirical Studies in Industry and 6th International Workshop on Software Engineering Research and Industrial Practice;Mobile devices are having a profound impact on how services can be delivered and how information can be shared. Sensitive information collected in remote communities can be relayed to local health care centers and from there to the decision makers who are thus empowered to make timely decisions. However many of these systems do not systematically address very important security issues which are critical when dealing with such sensitive and private information.In this paper we analyze implementation challenges of a proposed security protocol based on the Java ME platform. The protocol presents a flexible secure solution that encapsulates data for storage and transmission without requiring significant changes in the existing mobile client application. The secure solution offers a cost-effective way for ensuring data confidentiality both when stored on the mobile device and when transmitted to the server. In addition it offers data integrity off-line and on-line authentication account and data recovery mechanisms multi-user management and flexible secure configuration. A prototype of our secure solution has been integrated with openXdata.;
Companion Proceedings of the 3rd International Conference on the Art Science and Engineering of Programming;We present a survey (77 responses) and 10 follow-up interviews investigating how technology professionals include accessibility in design and development and what challenges they face. We asked technology professionals what they learned about accessibility in school what resources they used if any and what tools they needed. We found that formal education inadequately prepared them to handle accessibility challenges across the software development lifecycle. Other reasons include inadequate accessibility tools and resources and not accounting retroactive changes in project timelines. This work attempts to provide updates to the current state of software accessibility by comparing results to previous research works.;
Extended Abstracts of the 2020 CHI Conference on Human Factors in Computing Systems;Being able to detect program runtime complexity can help identify security vulnerabilities such as DoS attacks and side-channel information leakage. In prior work we use dynamic invariant generation to infer nonlinear numerical relations to represent runtime complexity of imperative programs. In this work we propose a new dynamic analysis approach for learning recurrence relations to capture complexity bounds for recursive programs. This approach allows us to efficiently infer simple linear recurrence relations that represent nontrivial potentially nonlinear complexity bounds. Preliminary results on several popular recursive programs show that we can learn precise recurrence relations capturing worst-case complexity bounds such as O(n log n) and O(cn).;
Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering;As software-intensive digital systems become an integral part of modern life ensuring that these systems are developed to satisfy security and privacy requirements is an increasingly important societal concern. This paper examines how secure coding practice is supported on Stack Overflow. Although there are indications that on-line environments are not robust or accurate sources of security information they are used by large numbers of developers. Findings demonstrate that developers use conversation within the site to actively connect with and tend to security problems fostering knowledge exchanging information and providing assistance to one another.;
Proceedings of the 41st International Conference on Software Engineering: Software Engineering in Society;To support software developers in addressing security we encourage to take advantage of reusable threat models for knowledge sharing and to achieve a general increase in efficiency and quality. This paper presents a controlled experiment with a qualitative evaluation of two approaches supporting threat modelling - reuse of categorised misuse case stubs and reuse of full misuse case diagrams. In both approaches misuse case threats were coupled with attack trees to give more insight on the attack techniques and how to mitigate them through security use cases. Seven professional software developers from two European software companies took part in the experiment. Participants were able to identify threats and mitigations they would not have identified otherwise. They also reported that both approaches were easy to learn seemed to improve productivity and that using them were likely to improve their own skills and confidence in the results.;
Proceedings of the 13th European Workshop on Systems Security;Many of today's application security vulnerabilities are introduced by software developers writing insecure code. This may be due to either a lack of understanding of secure programming practices and/or developers' lapses of attention on security. Much work on software security has focused on detecting software vulnerabilities through automated analysis techniques. While they are effective we believe they are not sufficient. We propose to increase developer awareness and promote practice of secure programming by interactively reminding programmers of secure programming practices inside Integrated Development Environments (IDEs). We have implemented a proof-of-concept plugin for Eclipse and Java. Initial evaluation results show that this approach can detect and address common web application vulnerabilities and can serve as an effective aid for programmers. Our approach can also effectively complement existing software security best practices and significantly increase developer productivity.;
Proceedings of the 27th Annual Computer Security Applications Conference;The class of Cross-site Scripting (XSS) vulnerabilities is the most prevalent security problem in the field of Web applications. One of the main attack vectors used in connection with XSS is session hijacking via session identifier theft. While session hijacking is a client-side attack the actual vulnerability resides on the server-side and thus has to be handled by the website's operator. In consequence if the operator fails to address XSS the application's users are defenseless against session hijacking attacks.In this paper we present SessionShield a lightweight client-side protection mechanism against session hijacking that allows users to protect themselves even if a vulnerable website's operator neglects to mitigate existing XSS problems. SessionShield is based on the observation that session identifier values are not used by legitimate clientside scripts and thus need not to be available to the scripting languages running in the browser. Our system requires no training period and imposes negligible overhead to the browser therefore making it ideal for desktop and mobile systems.;
Proceedings of the 27th International Workshop on Software Measurement and 12th International Conference on Software Process and Product Measurement;We describe a highly automated and tool-supported method for the correct integration of security mechanisms into distributed applications. Security functions to establish and release secure connections are provided as self-contained collaborative building blocks specifying the behavior of several parties. For the security mechanisms to be effective the application-specific model needs to fulfill certain behavioral properties for instance a consistent start and termination. We identify these properties and show how they lead to correct secured applications.;
Proceedings of the 2020 12th International Conference on Machine Learning and Computing;Vulnerabilities persist despite existing software security initiatives and best practices. This paper focuses on the human factors of software security including human behaviour and motivation. We conducted an online survey to explore the interplay between developers and software security processes e.g. we looked into how developers influence and are influenced by these processes. Our data included responses from 123 software developers currently employed in North America who work on various types of software applications. Whereas developers are often held responsible for security vulnerabilities our analysis shows that the real issues frequently stem from a lack of organizational or process support to handle security throughout development tasks. Our participants are self-motivated towards software security and the majority did not dismiss it but identified obstacles to achieving secure code. Our work highlights the need to look beyond the individual and take a holistic approach to investigate organizational issues influencing software security.;
Proceedings of the 2019 CHI Conference on Human Factors in Computing Systems;Cooperating cyber-physical systems-of-systems (CO-CPS) such as vehicle platoons robot teams or drone swarms usually have strict safety requirements on both spatial and temporal behavior. Learning-based testing is a combination of machine learning and model checking that has been successfully used for black-box requirements testing of cyber-physical systems-of-systems. We present an overview of research in progress to apply learning-based testing to evaluate spatio-temporal requirements on autonomous systems-of-systems through modeling and simulation.;
Proceedings of the 1st International Workshop on Machine Learning and Software Engineering in Symbiosis;Embedded Systems (ES) are an integral part of Cyber-Physical Systems (CPS) the Internet of Things (IoT) and consumer devices like smartphones. ES often have limited resources and - if used in CPS and IoT - have to satisfy real time requirements. Therefore ES rarely employ the security measures established for computer systems and networks. Due to the growth of both CPS and IoT it is important to identify ongoing attacks on ES without interfering with realtime constraints. Furthermore security solutions that can be retrofit to legacy systems are desirable especially when ES are used in Industrial Control Systems (ICS) that often maintain the same hardware for decades.To tackle this problem several researchers have proposed using side-channels (i.e. physical emanations accompanying cyber processes) to detect such attacks. While prior work focuses on the anomaly detection approach this might not always be sufficient especially in complex ES whose behavior depends on the input data. In this paper we determine whether one of the most common attacks - a buffer overflow attack - generates distinct side-channel signatures if executed on a vulnerable ES. We only consider the power consumption side-channel. We collect and analyze power traces from normal program operation and four cases of buffer overflow attack categories: (i) crash program execution (ii) injection of executable code (iii) return to existing function and (iv) Return Oriented Programming (ROP) with gadgets. Our analysis shows that for some of these cases a power signature-based detection of a buffer overflow attack is possible.;
Proceedings of the 3rd Workshop on Software Engineering in Health Care;Programs often run under strict usage conditions (e.g. license restrictions) that could be broken in case of code tampering. Possible attacks include malicious reverse engineering tampering using static dynamic and hybrid techniques on standard devices as well as in labs with additional special purpose hardware equipment. ASPIRE (http://www.aspire-fp7.eu) is a European FP7 research project devoted to the elaboration of novel techniques to mitigate and prevent attacks to code integrity to code/data confidentiality and to code lifting. This paper presents the ongoing activity to define a set of metrics aimed at quantifying the effect on code of the ASPIRE protections. The metrics have been conceived based on a measurement framework which prescribes the identification of the relevant code features to consider and of their relationships with attacks and protections.;
Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security;Introducing security features in a system is not free and brings along its costs and impacts. Considering this fact is essential in the design of real-time embedded systems which have limited resources. To ensure correct design of these systems it is important to also take into account impacts of security features on other non-functional requirements such as performance and energy consumption. Therefore it is necessary to perform trade-off analysis among non-functional requirements to establish balance among them. In this paper we target the timing requirements of real-time embedded systems and introduce an approach for choosing appropriate encryption algorithms at runtime to achieve satisfaction of timing requirements in an adaptive way by monitoring and keeping a log of their behaviors. The approach enables the system to adopt a less or more time consuming (but presumably stronger) encryption algorithm based on the feedback on previous executions of encryption processes. This is particularly important for systems with high degree of complexity which are hard to analyze statistically.;
Proceedings of the 12th IEEE/ACM International Conference on Utility and Cloud Computing;Security of software applications is a very challenging and extensive topic. to keep up with the trend of personalized context aware applications the security design must adapt to it. this paper presents context awareness into the role based access control. it will describe already existing solutions point out their key ideas and propose our rbac lightweight extension. it is universal and allows instant enhancement of current rbac even in current applications. the proposed solution is based on security levels which are assigned to users based on context. security levels represent how the users can be trusted and they are determined during the login procedure. the levels are used as additional security constraints to access resources. in application the user needs to possesses not only the right permission granted through rbac roles but also have a corresponding level.;
Proceedings of the 2015 Conference on Research in Adaptive and Convergent Systems;Nowadays systems that download updates from the net or let the user download third-party code for extending the application functions (plug-ins) are widespread. In these dynamic environments the code that is going to be executed is not known at compile-time and often not even at application start-up neither by the application producer nor by the user. This turns reliable well designed software into a dangerous and potentially malicious software for the user and for the system it runs onto: i.e. a well-behaved modular application becomes the unwilling host for malicious components. In this scenario the application producer lines up with the user in requesting that dynamically loaded third-party components must satisfy given security requirements.In this paper we present a framework that allows the consumer side of untrusted code to state desired properties about it. We exploit the facilities of the so-called virtual execution environments to encode directly into the meta-data of object code a well structured specification. Once the dynamic component is loaded at run-time by the main application the framework will recover such specifications and check them against the requirements gathered from the main application the user and the host operating system injecting run-time checks as needed into the untrusted code to ensure that the actual behaviour of the component matches the specified one.;
Proceedings of the 21st Annual Conference on Information Technology Education;Development of Internet of Things (IoT) applications is considered as a complex task. It requires knowledge in the different software layers starting from the low level perception layer to the high level application layer. The domain expert should be involved from the start of the project to its end to ensure that the delivered system satisfies the user needs. Such involvement results from the continuous need for the domain knowledge throughout the software development lifecycle. Such long development time along with the high cost of IoT applications cause a slow progress in the IoT development. In this paper a Domain Specific Language (DSL) called OntIoT is proposed that contributes in reducing the complexity of IoT application development through providing the needed domain knowledge in an automated manner. OntIoT is an ontology-based DSL that utilizes the Semantic Sensor Network (SSN) ontology to catch the IoT domain concepts and constraints.;
Proceedings of the 9th International Conference on Software and Information Engineering;"Most methods for protocol analysis classify protocols as broken"" if they are vulnerable to attacks from a strong attacker e.g. assuming the Dolev-Yao attacker model. In many cases however exploitation of existing vulnerabilities may not be practical and moreover not all applications may suffer because of the identified vulnerabilities. Therefore we may need to analyze a protocol for weaker notions of security. In this paper we present a security model that supports such weaker notions. In this model the overall goals of an authentication protocol are broken into a finer granularity for each fine level authentication goal we determine the ""least strongest-attacker"" for which the authentication goal can be satisfied. We demonstrate that this model can be used to reason about the security of supposedly insecure protocols. Such adaptability is particularly useful in those applications where one may need to trade-off security relaxations against resource requirements.""";
Proceedings of the 2019 ACM Conference on Innovation and Technology in Computer Science Education;While Java and PHP are two of the most popular languages for open source web applications found at freshmeat.net Java has had a much better security reputation than PHP. In this paper we examine whether that reputation is deserved. We studied whether the variation in vulnerability density is greater between languages or between different applications written in a single language by comparing eleven open source web applications written in Java with fourteen such applications written in PHP. To compare the languages we created a Common Vulnerability Metric (CVM) which is the count of four vulnerability types common to both languages. Common Vulnerability Density (CVD) is CVM normalized by code size. We measured CVD for two revisions of each project one from 2006 and the other from 2008. CVD values were higher for the aggregate PHP code base than the Java code base but PHP had a better rate of improvement with a decline from 6.25 to 2.36 vulnerabilities/KLOC compared to 1.15 to 0.63 in Java. These changes arose from an increase in code size in both languages and a decrease in vulnerabilities in PHP. The variation between projects was greater than the variation between languages ranging from 0.52 to 14.39 for Java and 0.03 to 121.36 in PHP for 2006. We used security and software metrics to examine the sources of difference between projects.;
Proceedings of the 52nd ACM Technical Symposium on Computer Science Education;"Early developments in code obfuscation were chiefly motivated by the needs of Digital Rights Management (DRM). Other suggested applications included intellectual property protection of software and code diversification to combat the monoculture problem of operating systems.Code obfuscation is typically employed in security scenarios where an adversary is in complete control over a device and the software it contains and can tamper with it at will. We call such situations the Man-At-The-End (MATE) scenario. MATE scenarios are the best of all worlds for attackers and consequently the worst of all worlds for defenders: Not only do attackers have physical access to a device and can reverse engineer and tamper with it at their leisure they often have unbounded resources (time computational power etc.) to do so. Defenders on the other hand are often severely constrained in the types of protective techniques available to them and the amount of overhead they can tolerate. In other words there is an asymmetry between the constraints of attackers and defenders. Moreover DRM is becoming less prevalent (songs for sale on the Apple iTunes Store are no longer protected by DRM for example)there are new cryptographically-based obfuscation techniques that promise provably secure obfuscationsecure enclaves are making it into commodity hardware providing a safe haven for security sensitive code and recent advances in program analysis and generic de-obfuscation provide algorithms that render current code obfuscation techniques impotent. Thus one may reasonably ask the question: Is Code Obfuscation Still a Thing?""Somewhat surprisingly it appears that the answer is yes. In a recent report Gartner lists 19 companies active in this space (8 of which were founded since 2010) and there are still (in 2017) many papers published on code obfuscation code de-obfuscation anti-tamper protection reverse engineering and related technologies.One of the reasons for this resurgence of code obfuscation as a protective technology is that more and more we are faced with applications where security-sensitive code needs to run on unsecured endpoints. In this talk we will show MATE attacks that appear in many novel and unlikely scenarios including smart cars smart meters mobile applications such as Snapchat and smartphone games Internet of Things applications and ad blockers in web browsers. We will furthermore show novel code obfuscation techniques that increase the workload of attackers and which at least for a time purport to restore the symmetry between attackers and defenders.""";
Proceedings of the Eighth ACM Conference on Data and Application Security and Privacy;A variety of methodologies to build secure systems have been proposed. However most of them do not say much about how to evaluate the degree of security of their products. In fact we have no generally-accepted ways to measure if the product of some methodology has reached some degree of security. However if the system has been built with a methodology that uses patterns as artifacts we believe that a simple evaluation is possible. We propose a metric for the security of systems that have been built using security patterns: We perform threat enumeration we check if the patterns in the product have stopped the threats and calculate the coverage of these threats by the patterns. We indicate how to take advantage of the Twin Peaks approach to arrive to a refined measure of security. In early work we have proposed a secure systems development methodology that uses security patterns and we use it as example.;
Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems;The correct deployment and enforcement of expressive attribute-based access control (ABAC) policies in large distributed systems is a significant challenge. The enforcement of such policies requires policy-dependent collaborations between many distributed entities. In existing authorization systems such collaborations are static and must be configured and verified manually by administrators. This approach does not scale to large and more dynamic application infrastructures in which frequent changes to policies and applications occur. As such configuration mistakes or application changes might suddenly make policies unenforceable which typically leads to severe service disruptions.We present a middleware for distributed authorization. The middleware provides a single administration point that enables the configuration and reconfiguration of application- and policy-dependent interactions between policy enforcement points (PEPs) policy decision points (PDPs) and policy information points (PIPs). Using lifecycle and dependency management the architecture guarantees that configurations are consistent with respect to deployed policies and applications and that they remain consistent as reconfigurations occur. Extensive performance evaluation shows that the runtime and configuration overhead of the middleware scale with the size and complexity of the infrastructure and that reconfigurations cause minimal disruption to the involved applications.;
Proceedings of the 2nd Africa and Middle East Conference on Software Engineering;E-mail header injection vulnerability is a class of vulnerability that can occur in web applications that use user input to construct e-mail messages. E-mail header injection vulnerabilities exist in the built-in e-mail functionality of the popular languages PHP Java Python and Ruby. With the proper injection string this vulnerability can be exploited to allow an attacker to inject additional headers modify existing headers and alter the content of the e-mail.While E-mail header injection vulnerabilities are known to the community and some commercial vulnerability scanners claim to discover E-mail header injection vulnerabilities they have never been studied by the academic community. This paper presents a scalable mechanism to automatically detect E-mail header injection vulnerabilities and uses this mechanism to quantify the prevalence of E-mail header injection vulnerabilities on the web. From crawling 23553796 URLs we found 994 vulnerable URLs across 414 domains. 135 of these domains are in the Alexa top 1 million and five of them are in the top 20000. 137 of the vulnerable domains are using anti-spoofing mechanisms such as DKIM SPF or DMARC and E-mail header injection renders this protection useless. This work shows that E-mail header injection vulnerabilities are widespread and deserve future research attention.;
Proceedings of the 33rd Annual ACM Symposium on Applied Computing;Build systems are an essential component in modern software engineering. They are used to automate tasks of the software development lifecycle such as compiling code assembling artifacts generating documentation testing artifacts and deploying artifacts. Although they play an important role in software development research has ignored this field for a long time. Recent research such as [9] started to investigate build systems as a component of the software development lifecycle. Kumpfert et al. observed that using a build system decreases the workload of developers but its usage also adds additional overhead for maintaining the build configuration [7]. Seo et al. addressed this issue and found that neglected maintenance of the build configuration is one of the most frequent reasons for breaking a build [10]. Kerzazi et al. found that suffering from build breakage blocks development teams from continuing their work and consequently costs the companies money [6]. Moreover Seo et al. and Kerzazi et al. investigated the number of failing builds and obvserved a high ratio of build breakage (28.5% and 17.7% respectively).;
Proceedings of the 6th International Conference on Sustainable Information Engineering and Technology;Active Malware Analysis focuses on learning the behaviors and the intentions of a malicious piece of software by interacting with it in a safe environment. The process can be formalized as a stochastic game involving two agents a malware sample and an analyzer that interact with opposite objectives: the malware sample tries to hide its behavior while the analyzer aims at gaining as much information on the malware sample as possible.Our goal is to design a software agent that interacts with malware and extracts information on the behavior learning a policy. We can then analyze different malware policies by using standard clustering approaches. In more detail we propose a novel method to build malware models that can be used as an input to the stochastic game formulation. We empirically evaluate our method on real malware for the Android systems showing that our approach can group malware belonging to the same families and identify the presence of possible sub-groups within such families.;
Proceedings of the 9th International ACM Sigsoft Conference on Quality of Software Architectures;In the challenge of ensuring the correct behaviour of legacy implementations of security protocols a formally-based approach is presented to design and implement monitors that stop insecure protocol runs executed by such legacy implementations without the need of their source code. We validate the approach at a case study about monitoring several SSL legacy implementations. Recently a security bug has been found in the widely deployed OpenSSL client our case study shows that our monitor correctly stops the protocol runs otherwise allowed by the faulty OpenSSL client. Moreover our monitoring approach allowed us to detect a new flaw in another open source SSL client implementation.;
Proceedings of the FSE/SDP Workshop on Future of Software Engineering Research;IT industry loses tens of billions of dollars annually from security attacks such as malicious reverse engineering. To protect sensitive parts of software from such attacks we designed a code obfuscation scheme based on nontrivial code clones. While implementing this scheme we realized that currently there is no framework to assist implementation of such advanced obfuscation techniques. Therefore we have developed a framework to support code obfuscation using code clones. We could successfully implement our obfuscation technique using this framework in Java. In this paper we present our framework and illustrate it with an example.;
Proceedings of the 22nd International Conference on Program Comprehension;In many software applications users access application data using graphical user interfaces (GUIs). There is an important but little explored link between visualization and security: when the application data is protected by an access control policy the GUI should be aware of this and respect the policy. For example the GUI should not display options to users for actions that they are not authorized to execute on application data. Taking this idea one step further the application GUI should not just be security-aware it should also be smart. For example the GUI should not display options to users for opening other widgets when these widgets will only display options for actions that the users are not authorized to execute on application data. We establish this link between visualization and security using a model-driven development approach. Namely we define and implement a many-models-to-model transformation that given a security-design model and a GUI model makes the GUI model both security-aware and smart.;
Proceedings of the 25th Conference on Pattern Languages of Programs;"Building a commercial grade static analysis presents a lot of interesting problems. Everything not forbidden is compulsory: language specifications are wonderful documents but in reality anything the user's compiler and runtime accepts is fair game. Analysis abstractions that scale except in pathological cases"" don't scale: analyzing tens of thousands of code bases that routinely exceed millions of lines of code means that those pathological cases inevitably arise. Build a good analysis that runs overnight and users will ask you to run it in their IDE for near-immediate feedback. A bug finding tool needs a low false positive rate but a tool aimed at finding security vulnerabilities needs a low false negative rate. Only analyzing ""source"" code and only starting from main() is insufficient for understanding modern web and mobile applications: frameworks imply a different programming model with a lot of auto-magical program behavior often including idiosyncratic configuration regimes and various template languages. We'll talk about these problems and how we tackle them.""";
Proceedings of the 8th ACM SIGPLAN International Workshop on State Of the Art in Program Analysis;In this paper we give an operational specification of a meta-model of access control using term rewriting. To demonstrate the expressiveness of the meta-model we show how several traditional access control models and also some novel models can be defined as special cases. The operational specification that we give permits declarative representation of access control requirements is suitable for fast prototyping of access control checking and facilitates the process of proving properties of access control policies.;
Proceedings of the 2018 2nd International Conference on Cloud and Big Data Computing;Remotely determining which precise code is running on which machines is hard. This is especially true if the monitored machines lack modern security features and may be under malware attack since in such a scenario the malware may have already manipulated applications and operating systems. Existing approaches to this problem are heavy-weight and have a large attack surface which is frequently attacked by both applications and malware.To address this problem this paper introduces RAI a light-weight code monitoring tool that is especially well-suited for legacy systems. While potentially useful for many software maintenance tasks this paper applies RAI for detecting ongoing rootkit attacks. Specifically in our experiments on several user and kernel mode rootkits our approach achieved with moderate overhead and a relatively low false positive rate a 100% rootkit detection rate.;
Proceedings of the 10th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement;Completely handling SQL injection consists of two activities: properly protecting the system from malicious input and preventing any resultant error messages caused by SQL injection from revealing sensitive information. The goal of this research is to assess the relative effectiveness of unit and system level testing of web applications to reveal both error message information leak and SQL injection vulnerabilities. To produce 100% test coverage of 176 SQL statements in four open source web applications we augmented the original automated unit test cases with our own system level tests that use both normal input and 132 forms of malicious input. Although we discovered no SQL injection vulnerabilities we exposed 17 error message information leak vulnerabilities associated with SQL statements using system level testing. Our results suggest that security testers who use an iterative test-driven development process should compose system level rather than unit level tests.;
Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis;In this paper we propose a pinpoint-hide defense method which aims to improve the stealth of obfuscated code. In the pinpointing process we scan the obfuscated code in a few small code fragment level and identify all surprising fragments that is very unusual fragments which may draw the attention of an attacker to the obfuscated code. In the hiding process we transform the pinpointed surprising fragments into unsurprising ones while preserving semantics. The obfuscated code transformed by our method consists only by unsurprising code fragments therefore is more difficult for attackers to be distinguished from unobfuscated code than the original. In the case study we apply our pinpoint-hide method to some programs transformed by well-known obfuscation techniques. The result shows our method can pinpoint surprising fragments such as dummy code that does not fit in the context of the program and instructions used in a complicated arithmetic expression. We also confirm that instruction camouflage can make the pinpointed surprising fragments unsurprising ones and that it runs correctly.;
Proceedings of the 19th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences;Static code analysis is an emerging technique for secure software development that analyzes large software code bases without execution to reveal potential vulnerabilities present in the code. These vulnerabilities include but are not limited to SQL injections buffer overflows cross site scripting improper security settings and information leakage.Software developers can spend many man-hours to track and fix the flagged vulnerabilities. Surveys show that a high percentage of discovered vulnerabilities are actually false positives.This paper presents a case study that found that context information regarding libraries could account for many of the false positives. We suggest future research incorporate context information into static analysis tools for security.;
Proceedings of the 6th Annual Symposium on Hot Topics in the Science of Security;Cross-site scripting (XSS) is a scripting attack targeting web applications by injecting malicious scripts into web pages. Blind XSS is a subset of stored XSS where an attacker blindly deploys malicious payloads in web pages that are stored in a persistent manner on target servers. Most of the XSS detection techniques used to detect the XSS vulnerabilities are inadequate to detect blind XSS attacks. In this research we present machine learning based approach to detect blind XSS attacks. Testing results help to identify malicious payloads that are likely to get stored in databases through web applications.;
Proceedings of the 2018 International Conference on Signal Processing and Machine Learning;With millions of mobile applications available for download and the proliferation of these types of software in our daily lives it is becoming increasingly important to ensure the security of these applications. Previous research showed that developers have little knowledge of security and privacy regulations and existing vulnerability detection tools have usability issues that prevent developers from using them. In my research I look at the human factor e.g. how developers conduct security reviews of their code and what issues they face when using existing tools. In addition I aim to develop tools and methodologies that support vulnerability detection while seamlessly integrating with the Software Development Lifecycle.;
Proceedings of the 14th International Conference on Mobile and Ubiquitous Multimedia;The number and variety of cyber-attacks is rapidly increasing and the rate of new software vulnerabilities is also rising dramatically. The cybersecurity community typically reacts to attacks after they occur. Being reactive is costly and can be fatal where attacks threaten lives important data or mission success. Taking a proactive approach we are: (I) identifying potential attacks before they come to fruition and based on this identification (II) developing preventive counter-measures. We describe a Proactive Cybersecurity System (PCS) a layered modular service platform that applies big data collection and processing tools a wide variety of unstructured data sources to identify potential attacks and develop countermeasures. The PCS provides security analysts a holistic proactive and systematic approach to cybersecurity. Here we describe our research vision and progress towards that vision.;
Proceedings of the 2nd International Workshop on BIG Data Software Engineering;The number and variety of cyber-attacks is rapidly increasing and the rate of new software vulnerabilities is also rising dramatically. The cybersecurity community typically reacts to attacks after they occur. Being reactive is costly and can be fatal where attacks threaten lives important data or mission success. Taking a proactive approach we are: (I) identifying potential attacks before they come to fruition and based on this identification (II) developing preventive counter-measures. We describe a Proactive Cybersecurity System (PCS) a layered modular service platform that applies big data collection and processing tools a wide variety of unstructured data sources to identify potential attacks and develop countermeasures. The PCS provides security analysts a holistic proactive and systematic approach to cybersecurity. Here we describe our research vision and progress towards that vision.;
Proceedings of the 11th International Conference on Future Internet Technologies;Thinking Aloud is a method that allows the collection of expressive user feedback for software improvement. However its frequent application in a rapid development processes such as Continuous Software Engineering (CSE) is challenging since repetitively performing manual observations and evaluations demand high effort. We propose the Continuous Thinking Aloud (CTA) approach for conducting Thinking Aloud during CSE. CTA records speech feedback for a user who starts using a new feature increment. The recordings are automatically transcribed and classified into one of four feedback categories that differentiate between insecure neutral positive and negative sentiments. CTA visualizes these feedback classifications on a sentence level next to its related high-level change of the feature increment. This supports developers in problem discovery in particular regarding usability. CTA integrates with CSE processes and represents a scalable approach enabling repeated application during the software development lifecycle.;
Proceedings of the Joint 4th International Workshop on Rapid Continuous Software Engineering and 1st International Workshop on Data-Driven Decisions Experimentation and Evolution;C is a dominant language for implementing system software. Unfortunately its support for low-level control of memory often leads to memory errors. Dynamic analysis tools which have been widely used for detecting memory errors at runtime are not yet satisfactory as they cannot deterministically and completely detect some types of memory errors e.g. segment confusion errors sub-object overflows use-after-frees and memory leaks. We propose Smatus short for smart status a new dynamic analysis approach that supports comprehensive runtime detection of memory errors. The key innovation is to create and maintain a small status node for each memory object. Our approach tracks not only the bounds of each pointerâ€™s referent but also the status and reference count of the referent in its status node where the status represents the liveness and segment type of the referent. A status node is smart as it is automatically destroyed when it becomes useless. To the best of our knowledge Smatus represents the most comprehensive approach of its kind. In terms of effectiveness (for detecting more kinds of errors) Smatus outperforms state-of-the-art tools Googleâ€™s AddressSanitizer SoftBoundCETS and Valgrind. In terms of performance Smatus outperforms SoftBoundCETS and Valgrind in terms of both time and memory overheads incurred and is on par with AddressSanitizer in terms of the time and memory overheads tradeoff (with much lower memory overhead incurred).;
Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis;Node.js executes server-side JavaScript-based code. By design Node.js and JavaScript support global variables monkey-patching and shared cache of loaded modules. This paper discusses four attacks that exploit these weaknesses which are: leakage of global variables manipulation of global variables manipulation of local variables and manipulation of the dependency tree. In addition it describes the static code analysis that we implemented for T.J. Watson Libraries for Analysis (WALA) to detect the identified attacks and the evaluation of the analysis. The analysis is integrated into OpenWhisk an open source serverless cloud platform.;
Proceedings of the 36th International Conference on Software Engineering;Safety standards such as IEC 61508 are an important instrument for developing safety-critical systems. They provide requirements and recommendations to assist engineers in system and software development. Nevertheless applying this standard in practice is difficult due to unclear requirements and unclear or missing acceptance criteria. We systematically developed a quality model including proper measurement support that covers the code-related parts of IEC 61508 in [20]. In this paper we present the assessment approach for automatic compliance checks of the code-related parts of the standard. We find in a validation study that the assessment results obtained by applying this approach to real-world projects are in line with their externally granted certification. The results are valid for the vast majority of the modeled elements of the standard. Moreover by drilling down into the assessment results we are able to detect deficiencies in the certified real-world projects.;
Companion Proceedings of the 36th International Conference on Software Engineering;Android applications are vulnerable to reverse engineering which could result in tampering and repackaging of applications. Even though there are many off the shelf obfuscation tools that hardens Android applications they are limited to basic obfuscation techniques. Obfuscation techniques that transform the code segments drastically are difficult to implement on Android because of the Android runtime verifier which validates the loaded code. In this paper we introduce a novel obfuscation technique Android Encryption based Obfuscation (AEON) which can encrypt code segments and perform runtime decryption during execution. The encrypted code is running outside of the normal Android virtual machine in an embeddable Java source interpreter and thereby circumventing the scrutiny of Android runtime verifier. Our obfuscation technique works well with Android source code and Dalvik bytecode.;
Proceedings of the 21st Pan-Hellenic Conference on Informatics;In avionics the size and complexity of software-intensive systems increased considerably during recent years. Besides the size and the complexity certification constraints also had negative impact on the cost and schedule of avionics software projects. Model-Driven Development (MDD) and Software Product Lines Engineering (SPLE) offer an opportunity to improve the avionics software development process reduce the cost and improve the time to market.Complexity of avionics software and certification constraints pose several challenges to SPLE adoption. Software Product Lines (SPL) framework must provide bi-directional traceability between requirements and low level software assets (e.g. code and test) facilitate production of certification deliverables allow validation on the target platform and provide code coverage. Also SPL offer a scheme to manage the complexity of avionics software systems through variability management tools.;
Proceedings of the Third International Workshop on Product LinE Approaches in Software Engineering;Data scientists often develop machine learning models to solve a variety of problems in the industry and academy. To build these models these professionals usually perform activities that are also performed in the traditional software development lifecycle such as eliciting and implementing requirements. One might argue that data scientists could rely on the engineering of traditional software development to build machine learning models. However machine learning development presents certain characteristics which may raise challenges that lead to the need for adopting new practices. The literature lacks in characterizing this knowledge from the perspective of the data scientists. In this paper we characterize challenges and practices addressing the engineering of machine learning models that deserve attention from the research community. To this end we performed a qualitative study with eight data scientists across five different companies having different levels of experience in developing machine learning models. Our findings suggest that: (i) data processing and feature engineering are the most challenging stages in the development of machine learning models (ii) it is essential synergy between data scientists and domain experts in most of stages and (iii) the development of machine learning models lacks the support of a well-engineered process.;
Proceedings of the XIX Brazilian Symposium on Software Quality;"This panel looks into the impact of the current copyright framework in the European Union on text and data mining (TDM) and discusses the impact of introducing a TDM exception in EU copyright law. A design of this exception is proposed for the panel and is partially based on findings in the Horizon 2020 FutureTDM project. This project aims to improve uptake of text and data mining (TDM) in the EU and in that regard has studied the legal barriers to TDM and will be developing and recommending a policy framework in the future. Part of this policy framework will consist of possible actions to be undertaken by the - European and national - legislators.A TDM exception is considered to include in the recommendations and we therefore broach the topic to discuss the possible legal economic and practical impact of such an exception with experts from the field. The TDM exception as proposed for this panel is inspired by the black-box analysis"" exception from the Software Directive which allows lawful users of a program to perform any of the acts of loading displaying running transmitting or storing the program to ""determine the ideas and principles"" underlying it. The authors of the panel believe that this underlines the general principle of copyright law: namely that ideas and facts are not protected. Therefore proposition to be discussed is that a similar exception should be introduced for copyright law in general that would allow reproductions to be made of works for the sole purpose of extracting facts and ideas underlying them. This would allow TDM activities where machines 'read' lawfully accessed works just as the human reading of works does not require further authorization from the copyright holder.""";
Proceedings of the 79th ASIS&ampT Annual Meeting: Creating Knowledge Enhancing Lives through Information &amp Technology;In this presentation I describe how the SEI's Security Engineering Risk Analysis (SERA) method provides a structure that connects desired system functionality with the underlying software to evaluate the sufficiency of requirements for software security and the potential operational security risks based on mission impact.;
Proceedings of the 3rd International Workshop on Software Engineering Research and Industrial Practice;Software security is becoming a key quality concern as software applications are increasingly being used in untrustworthy computing environments such as the internet. Software is designed with the mindset of its functionalities and cost where the focus is on the operational behavior while security concerns are neglected or marginally considered. As a result software engineers build the software while lacking the knowledge about security and its effect on the system. This paper presents an approach for modeling the behavior of security threats using statecharts. The proposed approach introduces modular design for representing threats through the use of components and reusability. Through the focus on the behavior of an attack software engineers can clearly define and understand security concerns as the application is being designed and developed. In addition modeling security threats with statecharts makes it convenient to build a consistent semantic link between functional behaviors and security concerns.;
Proceedings of the Joint ACM SIGSOFT Conference -- QoSA and ACM SIGSOFT Symposium -- ISARCS on Quality of Software Architectures -- QoSA and Architecting Critical Systems -- ISARCS;Security Patterns and Architectural Tactics are two well-known techniques for designing secure software systems. There is little or no empirical evidence on their relative effectiveness for security threats mitigation. This study presents MUA (Misuse activities + Patterns) an extension of misuse activities that incorporates patterns and reports on a controlled comparison of this method that incorporate these techniques for threat mitigation with regard to MAST (Methodology for Applying Security Tactics) which already incorporates tactics. A simple Tsunami Alert System design was analyzed and modified by 40 undergraduate students and significant difference was found for security threats mitigation (averaging 3.0 for Patterns versus 1.9 for Tactics in a 1-to-5 scale). This result is contrary to previous results with professional subjects leading us to believe that novices benefit more of detailed advice than of high-level concepts.;
Proccedings of the 10th European Conference on Software Architecture Workshops;Security measurement helps identify deployment gaps and present extremely valuable research opportunities. However such research is often deemed as not novelty by academia. I will first share my research journey designing and producing a high-precision tool CryptoGuard for scanning cryptographic vulnerabilities in large Java projects. That work led us to publish two benchmarks used for systematically assessing state-of-the-art academic and commercial solutions as well as help Oracle Labs integrate our detection in their routine scanning.Other specific measurement and deployment cases to discuss include the Payment Card Industry Data Security Standard which was involved in high-profile data breach incidents and fine-grained Address Space Layout Randomization (ASLR). The talk will also point out the need for measurement in AI development in the context of code repair.Broadening research styles by accepting and encouraging deployment-related work will facilitate our field to progress towards maturity.;
Proceedings of the 4th ACM SIGSOFT International Workshop on NLP for Software Engineering;A large number of malicious software communicate with C &amp C (Command and Control) servers to download resources for malicious actions or to receive commands to perform desired attacks. Malware needs to know C &amp C servers' IP addresses to communicate with and these IP addresses are usually obtained through DNS (Domain Name System) communications by sending domain names to DNS servers instead of using hard-coded IP addresses in order to avoid analysis and detection. In this process malware usually uses DGA (Domain Generation Algorithm) to hide domain names of C &amp C servers and to make difficult to block C &amp C servers or domain names. Although DGA techniques have been studied extensively most of previous studies have been based on the analysis of the domain names generated by DGA focusing on the characteristics of the strings. However this kind of analysis methods has difficulties to detect some domain names generated by DGA with creative criteria. In this paper we have conducted research to detect malicious code generated by DGA based on the value of flags included in the DNS communication process deviating from the existing research focusing on domain name only.;
Proceedings of the Conference on Research in Adaptive and Convergent Systems;To minimize testing and technology upgrade costs for safety-critical systems a thorough understanding and analysis of architectural dependencies is essential. Unmanaged dependencies create cost overruns and degraded qualities in systems. Architecture dependency analysis in practice however is typically performed in retrospect using code structures the runtime image of a system or both. Retrospective analysis can miss important dependencies that surface earlier in the life cycle. Development artifacts such as the software architecture description and the software requirements specification can augment the analysis process however the quality consistency and content of these artifacts vary widely. In this paper we apply a commonly used dependency analysis metric stability and a visualization technique the dependency structure matrix to an architecture common to safety-critical systems that was re-engineered to reduce safety testing and upgrade cost. We describe the gaps observed when running the analysis and discuss the need for early life-cycle dependency analysis for managing rework costs in industrial software development environments.;
Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data;Background: Security tools play a vital role in enabling developers to build secure software. However it can be quite challenging to introduce and fully leverage security tools without affecting the speed or frequency of deployments in the DevOps paradigm. Aims: We aim to empirically investigate the key challenges practitioners face when integrating security tools into a DevOps workflow in order to provide recommendations for overcoming the challenges. Method: We conducted a study involving 31 systematically selected webinars on integrating security tools in DevOps. We used a qualitative data analysis method i.e. thematic analysis to identify the challenges and emerging solutions related to integrating security tools in rapid deployment environments. Results: We find that whilst traditional security tools are unable to cater for the needs of DevOps the industry is moving towards new generations of security tools that have started focusing on the needs of DevOps. We have developed a DevOps workflow that integrates security tools and a set of guidelines by synthesizing practitioners' recommendations in the analyzed webinars. Conclusion: Whilst the latest security tools are addressing some of the requirements of DevOps there are many tool-related drawbacks yet to be adequately addressed.;
Proceedings of the 15th ACM / IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM);Software protection in practice addresses the yearly loss of tens of billion USD for software manufacturers a result of malicious end-users tampering with the software (â€software crackingâ€). Software protection is prevalent in the gaming and license checking industries and also relevant in the embedded and other industries. State of the art research in the area of software tamper protection against man-at-the-end (MATE) attackers focuses on the localization of integrity checks. The goal of this paper is a general assessment of the resilience of software self-checking protected themselves by obfuscations against (1) (automated) detection and (2) (automated) bypass without deobfuscating the code. Using dynamic taint analysis on a benchmark set of programs we study how easy it is to detect and bypass combinations of self-checking and various obfuscation transformations. We aim at generalizing these findings across different programs rather than focusing on one particular program instance. To this end we perform a set of controlled experiments using a data set of real-world programs the MiBench suite and open-source games and show that all of these can be broken by dynamic taint analysis attacks. To counter such attacks we propose and implement improvements to an existing obfuscation implementation. We evaluate the implemented improvement and discuss the security-performance trade-offs.;
Proceedings of the Hardware and Architectural Support for Security and Privacy 2016;The crucial aim of software security is malware detection. A malware is a program with malicious intents. The predominate anti-malware solutions are signature-based. These detectors compute the signature starting from the syntactic characteristics of the malicious code. Unfortunately the signature-based techniques are ineffective against the code obfuscations i.e. trivial transformations that alter the syntax of the code preserving the normal behaviour of the program. To address this limitation formal methods are used in software security. Formal methods are rigorous techniques used to verify the behaviour of a system. This paper aims to make an overview on behavioural based techniques developed to detect malware programs. The illustrated approaches are based on different formal techniques.;
Proceedings of the 25th IEEE/ACM International Conference on Automated Software Engineering;Applications written in C/C++ are prone to memory corruption which allows attackers to extract secrets or gain control of the system. With the rise of strong control-flow hijacking defenses non-control data attacks have become the dominant threat. As vulnerabilities like HeartBleed have shown such attacks are equally devastating. Data Confidentiality and Integrity (DCI) is a low-overhead non-control-data protection mechanism for systems software. DCI augments the C/C++ programming languages with an- notations allowing the programmer to protect selected data types. The DCI compiler and runtime system prevent illegal reads (confidentiality) and writes (integrity) to instances of these types. The programmer selects types that contain security critical information such as passwords cryptographic keys or identification tokens. Protecting only this critical data greatly reduces performance overhead relative to complete memory safety.Our prototype implementation of DCI DataShield shows the applicability and efficiency of our approach. For SPEC CPU2006 the performance overhead is at most 16.34%. For our case studies we instrumented mbedTLS astar and libquantum to show that our annotation approach is practical. The overhead of our SSL/TLS server is 35.7% with critical data structures protected at all times. Our security evaluation shows DataShield mitigates a recently discovered vulnerability in mbedTLS.;
Proceedings of the 2017 ACM on Asia Conference on Computer and Communications Security;In software protection we typically have to deal with the white-box attack model. In this model an attacker is assumed to have full access to the software and full control over its execution. The goal of white-box cryptography is to implement cryptographic algorithms in software such that it is hard for an attacker to extract the key by a white-box attack. Chow et al. present white-box implementations for AES and DES. Based on their ideas white-box implementations can be derived for other block ciphers as well. In the white-box implementations the key of the underlying block cipher is expanded from several bytes to a collection of lookup tables with a total size in the order of hundreds of kilobytes. In this paper we present a technique that uses a white-box implementation to make software tamper resistant. The technique interprets the binary of software code as lookup tables which are next incorporated into the collection of lookup tables of a white-box implementation. This makes the code tamper resistant as the dual interpretation implies that a change in the code results in an unintentional change in the white-box implementation. We also indicate in the paper that it is difficult for an attacker to make modifications to the white-box implementation such that its original operation is restored.;
Proceedings of the 2007 ACM Workshop on Digital Rights Management;Software development is often accompanied by security audits such as penetration tests usually performed on behalf of the software vendor. In penetration tests security experts identify entry points for attacks in a software product. Many development teams undergo such audits for the first time if their product is attacked or faces new security concerns. The audits often serve as an eye-opener for development teams: they realize that security requires much more attention. However there is a lack of clarity with regard to what lasting benefits developers can reap from penetration tests. We report from a one-year study of a penetration test run at a major software vendor and describe how a software development team managed to incorporate the test findings. Results suggest that penetration tests improve developers' security awareness but that long-lasting enhancements of development practices are hampered by a lack of dedicated security stakeholders and if security is not properly reflected in the communicative and collaborative structures of the organization.;
Proceedings of the 2016 CHI Conference Extended Abstracts on Human Factors in Computing Systems;Requirement Change is one of the most challenging tasks in software development lifecycle particularly in the complex context of Global Software Development (GSD). During the last decade many studies are carried out to address these problems however careful examination of these works suggests that there's a potential research gap. This paper has performed a Systematic Literature Review (SLR) to identify the most significant/commonly studied challenges of requirement change management process and furthermore this process under GSD context. We identified ten challenges such as impact analysis cost estimation artifacts documents management requirement traceability requirements dependency conflicts with existing requirements time estimation change prioritization user involvement and system destabilizing. Furthermore three challenges such as communication and coordination knowledge sharing management and Change Control Board (CCB) management are identified for globally distributed projects. We also mapped these identified challenges to Requirement Change Management Process (RCMP) outcomes proposed in our previous study. We believe that mapping between RCM challenges and RCMP outcomes will enhance the practical significance of this study results. Considering the systematic literature review results we suggest that there is a need to develop a framework for requirement change management for quality software systems development.;
Proceedings of the Third Workshop on Hot Topics in Software Defined Networking;We present a verification method that allows to prove security for security-critical systems based on cryptographic protocols. Designing cryptographic protocols is very difficult and error-prone and most tool-based verification approaches only consider standard security properties such as secrecy or authenticity. In our opinion application-specific security properties give better guarantees. In this paper we illustrate how to verify properties that are relevant for e-commerce applications e.g. 'The provider of a copying service does not lose money'. This yields a more complex security property that is proven using interactive verification. The verification of this kind of application-specific property is part of the SecureMDD approach which provides a method to model a security-critical application with UML and automatically generates executable code as well as a formal specification for interactive verification from the UML models.;
Proceedings of the 8th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement;Mobile medical apps play an important role within the healthcare industry. Developers of mobile medical apps need to understand what is required when a mobile application fulfils the definition of a medical device. Such applications have to be developed in compliance with medical device regulations. This can be a challenge for mobile medical application developers as medical device software is normally developed with a focus upon producing the regulatory documentation that is essential to market such devices. Regulatory compliance is usually achieved by adopting a plan-driven software development approach which is not typically the method used to develop mobile applications. MDevSPICEÂ® is a medical device software process framework that integrates processes from various medical device software and generic software development best practice standards. In this paper the authors describe how the MDevSPICEÂ® framework can be tailored to support mobile medical applications development by introducing agile practices into the framework.;
Proceedings of the International Conference on Software and Systems Process;We call changeware software that surreptitiously modifies resources of software applications e.g. configuration files. Changeware is developed by malicious entities which gain profit if their changeware is executed by large numbers of end-users of the targeted software. Browser hijacking malware is one popular example that aims at changing web-browser settings such as the default search engine or the home page. Changeware tends to provoke end-user dissatisfaction with the target application e.g. due to repeated failure of persisting the desired configuration. We describe a solution to counter changeware to be employed by vendors of software targeted by changeware. It combines several protection mechanisms: white-box cryptography to hide a cryptographic key software diversity to counter automated key retrieval attacks and run-time process memory integrity checking to avoid illegitimate calls of the developed API.;
Proceedings of the 5th ACM Conference on Data and Application Security and Privacy;The1 Graphical User Interface (GUI) design is a major process within the software development lifecycle because the GUI is the portion of the interface that will be in direct contact with the end-user. There are resources to help make the interface meet recommended usability criteria but tools focused specifically on the GUI design are lacking. In order to bridge this gap this study presents the development of a visual design checklist for Graphical User Interface evaluation. The checklist was tested in a two-phase assessment process: the first with HCI professionals and experts and the second in a make-believe development context. Results show good acceptance among professionals and suggest the checklist can positively assist development teams meet usability criteria. In conclusion it is possible to assume the checklist can be a valuable resource to evaluate the Graphical User Interface thus preventing errors and improving the overall system acceptability by the end-user.;
Proceedings of the 1st International Conference on Information Science and Systems;Model checking is a powerful formal analytical approach to verifying software and hardware systems. However general industrial adoption is far from widespread. Some difficulties include the inaccessibility of techniques and tools and the need for further empirical evaluation in industrial contexts. This study considers the use of Simulink Design Verifier a model checker that forms part of a modelling system already widely used in the safety-critical industry. Model checking is applied to a number of real-world problem reports associated with aero-engine monitoring functions to determine whether it can provide a practical route into effective verification particularly for non-specialists. The study also considers the extent to which model checking can satisfy the requirements of the extensive DO-178C guidance on formal methods. The study shows that the benefits of model checking can be realised in an industrial setting without specialist skills particularly when it is targeted at parts of the software that are error-prone difficult to verify conventionally or critical. Importantly it shows that model checking can find errors earlier in the design cycle than testing which potentially saves money due to reduced scrap and rework.;
Proceedings of the International Conference on Advances in Image Processing;Background: Static analysis security testing (SAST) tools may be evaluated using synthetic micro benchmarks and benchmarks based on real-world software.Aims: The aim of this study is to address the limitations of the existing SAST tool benchmarks: lack of vulnerability realism uncertain ground truth and large amount of findings not related to analyzed vulnerability.Method: We propose Delta-Bench - a novel approach for the automatic construction of benchmarks for SAST tools based on differencing vulnerable and fixed versions in Free and Open Source (FOSS) repositories. To test our approach we used 7 state of the art SAST tools against 70 revisions of four major versions of Apache Tomcat spanning 62 distinct Common Vulnerabilities and Exposures (CVE) fixes and vulnerable files totalling over 100K lines of code as the source of ground truth vulnerabilities.Results: Our experiment allows us to draw interesting conclusions (e.g. tools perform differently due to the selected benchmark).Conclusions: Delta-Bench allows SAST tools to be automatically evaluated on the real-world historical vulnerabilities using only the findings that a tool produced for the analyzed vulnerability.;
Proceedings of the 11th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement;In the future safety-critical industrial products will have to be maintained and variants will have to be produced. In order to do this economically the safety artifacts of the components should also be reused. At present however it is still unclear how this reuse could take place. Moreover this reuse is complicated by the different situations in the various industries involved and by the corresponding standards applied.Current industrial practice for certification processes relies on a component-based view of reuse. We investigate the possibilities of product lines with managed processes for reuse also across multiple domains.In order to identify the challenges and possible solutions we conducted interviews with industry partners from the domains of ICT Rail Automotive and Industrial Automation and from small- and medium-sized enterprises to large organizations. The semi-structured interviews identified the characteristics of current safety engineering processes the handling of general variety and reuse the approach followed for safety artifacts and the need for improvement.In addition a detailed literature survey summarizes existing approaches. We investigate which modularity concepts exist for dealing with safety how variability concepts integrate safety by which means process models can consider safety and how safety cases are evolved while maintenance takes place. An overview of similar research projects complements the analysis.The identified challenges and potential solution proposals show how safety is related to Software Product Lines.;
Proceedings of the 23rd International Systems and Software Product Line Conference - Volume A;Testing processes are commonly used with the aim of systematizing testing activities within a software development project or in a Test Factory (TF). However even using a process the team may fail to perform testing activities intentionally or not in order to for example make a faster delivery. In this situation the team may incur a Technical Debt (TD): technical commitment generated during the software development lifecycle that may be beneficial in the short term but in the long term may be detrimental to the quality of the project. These TDs should be identified and managed because if they remain invisible and non-refunded they may accumulate incrementally and hinder or even make impossible maintenance tasks and software evolution. In this context this work aims to report the experience of identifying technical test debts in a Test Factory. As object of the study Test Debts were analyzed in five projects with the industry in 2017 2018 and 2019. As a result four Test Debts causes were identified over the three years of our experience in the industry. Also we present 11 lessons learned that help to identify and prevent Test Debts.;
Proceedings of the XVIII Brazilian Symposium on Software Quality;Systems security is becoming more challenging in the face of untrusted programs and system users. Safeguards against attacks currently in use such as buffer overflows control-flow integrity side channels and malware are limited. Software protection schemes while flexible are often too expensive and hardware schemes while fast are too constrained or out-of-date to be practical.We demonstrate the best of both worlds with the Guardian Council a novel parallel architecture to enforce a wide range of highly customisable and diverse security policies. We leverage heterogeneity and parallelism in the design of our system to perform security enforcement for a large high-performance core on a set of small microcontroller-sized cores. These Guardian Processing Elements (GPEs) are many orders of magnitude more efficient than conventional out-of-order superscalar processors bringing high-performance security at very low power and area overheads. Alongside these highly parallel cores we provide fixed-function logging and communication units and a powerful programming model as part of an architecture designed for security.Evaluation on a range of existing hardware and software protection mechanisms reimplemented on the Guardian Council demonstrates the flexibility of our approach with negligible overheads out-performing prior work in the literature. For instance 4 GPEs can provide forward control-flow integrity with 0% overhead while 6 GPEs can provide a full shadow stack at only 2%.;
Proceedings of the Twenty-Fifth International Conference on Architectural Support for Programming Languages and Operating Systems;The Fifth Workshop on Forming an Ecosystem Around Software Transformation (FEAST) provides a forum for presentation and discussion of new tools methodologies and techniques facilitating the automated or semi-automated transformation and analysis of software executables for improving their security and efficiency without the benefit of any original source code whence they were developed. Late-stage software customization of this form is of particular benefit to security-conscious software consumers who must use closed-source or source-free binary software components in mission-critical settings or who must harden software against newly emerging attacks not anticipated during the software's original design and development. However code analysis and transformation becomes much more difficult without the aid of source-level information to provide a context for its intended operation. This outstanding challenge motivates the FEAST Workshop's goal of forming a robust ecosystem of strategies and tools for accomplishing source-free binary code transformation reliably and on-demand.;
Proceedings of the Third International Symposium on Women in Computing and Informatics;Moving-target defenses (MTDs) have been widely studied for common general-purpose and enterprise-computing applications. Indeed such work has produced highly effective low-overhead defenses that are now commonly deployed in many systems today. One application space that has seen comparatively little focus is that of safety- and mission-critical systems which are often real-time systems (RTS) with temporal requirements. Furthermore such systems are increasingly being targeted by attackers such as in industrial control systems (ICS) including power grids. The strict timing requirements of these systems presents a different design objective than is common in general-purpose applications -- systems should be designed around the worst-case performance rather than the average case. Perhaps in part due to these alternative design considerations many real-time systems have not benefited from much of the work on software security that common general-purpose and enterprise applications have despite the ubiquity of real-time systems that actively control so many applications we as a society have come to rely on from power generation and distribution to automotive and avionic applications and many others.This paper explores the application of moving-target defenses in the context of real-time systems. In particular the worst-case performance of several address-space randomization defenses are evaluated to study the implications of such designs in real-time applications. These results suggest that current moving-target defenses while performant in the average case can exhibit significant tail latencies which can be problematic in real-time applications especially if such overheads are not considered in the design and analysis of the system. These results inform future research directions for moving-target defenses in real-time applications.;
Proceedings of the 7th ACM Workshop on Moving Target Defense;Refactoring has become a valuable activity during the software development lifecycle because it can be induced by different causes like new requirements or quality improvement. In code-based development contexts this activity has been widely studied whereas in model-driven ones where models are first-class development entities there are many issues yet to be tackled. In this paper we present a metamodel that supports the specification of pre- and post- conditions of model refactoring actions and the automated derivation and verification of such conditions in specific modeling languages. Our work is aimed at helping users to implement refactoring actions in the adopted modelling language by providing an environment for guaranteeing the feasibility of refactoring actions. Our primary focus is on the definition of applicable sequences of refactoring actions rather than on the user-driven step-by-step application of refactoring actions. As an example we illustrate the applicability of our metamodel for UML models refactoring.;
Proceedings of the 2nd International Workshop on Refactoring;This paper proposes a general model for hiding control flow graph flattening in C programs. We explain what control flow graph flattening is and illustrate why it is successful as protection against static control flow analysis. Furthermore we propose a scheme complementary to control flow graph flattening which does not leak any control flow graph information statically. Instead of relying on ad hoc security by using variable aliasing and global pointers to complicate data flow analysis of the switch variable we try to base our security claims more on information theory data flow and cryptography. Our formal model is structured and extendable. Moreover it can specify which minimum of information to hide from the program (e.g. a secret value or function) such that no control flow information is leaked. To express the robustness of our scheme we present some attacks and their feasibility. Finally we sketch a few scenarios in which our solution could be deployed.;
Proceedings of the Tenth Annual ACM Workshop on Digital Rights Management;Secure coding is a mission that cannot be neglected as computing devices continue increasing. Every year thousands of new software vulnerabilities are identified. Education is a crucial factor and a significant challenge to counter cyber threats. But gaining insight into how people learn has always been challenging. There is a considerable need for improved methodologies with active hands-on educational techniques for programmers to learn practical strategies to mitigate software vulnerabilities to protect private data and ultimately to write secure code in the first place. To the best of our knowledge this is the first usage of eye tracking technologies to understand secure coding practices and to improve education. We focused on exploring the ways that students comprehended and learned to develop secure software. We recorded their eye gaze movements while they studied our hands-on learning module and mitigated the weaknesses within the source code. Our study involved 29 students mitigating software vulnerabilities via manual analysis of the source code. The eye tracking data allows us to objectively study and gain insight in order to understand and improve students learning behavior. Our analysis indicates that there is a distinction in the learning phase for students that answered correctly compared to students that did not provide the correct mitigation strategy. Specifically our research indicates the most effective and efficient way to learn secure coding is to fully understand coding errors before working on the source code. Our findings also suggest that we can use reading patterns to understand student behaviors in order to be capable of developing improved hands-on learning material.;
Proceedings of the 2020 ACM Southeast Conference;Asynchronous memory operations provide a means for coping with the memory wall problem in multicore processors and are available in many platforms and languages e.g. the Cell Broadband Engine CUDA and OpenCL. Reasoning about the correct usage of such operations involves complex analysis of memory accesses to check for races. We present a method and tool for proving memory-safety and race-freedom of multicore programs that use asynchronous memory operations. Our approach uses separation logic with permissions and our tool automates this method targeting a C-like core language. We describe our solutions to several challenges that arose in the course of this research. These include: syntactic reasoning about permissions and arrays integration of numerical abstract domains and utilization of an SMT solver. We demonstrate the feasibility of our approach experimentally by checking absence of DMA races on a set of programs drawn from the IBM Cell SDK.;
Proceedings of the 26th IEEE/ACM International Conference on Automated Software Engineering;One of the latest ways to improve software security is based on the use of security patterns. Security patterns provide encapsulated solutions to specific security problems and can be used to build secure systems by designers with little knowledge of security. We present here a way to use security patterns to add security to applications. This is accomplished by adding instances of security patterns to the conceptual model of the application. This approach is part of a secure systems development methodology but it can be used on its own.;
Proceedings of the 45th Annual ACM Southeast Conference;Software cost and effort estimation is a necessary step in the software development lifecycle to track progress manage resources and negotiate. Though many accepted cost models exist local calibration results in more accurate estimates. Locally calibrating Unified Code Count (UCC)'s dataset based on COCOMO (Constructive Cost Model)Â® II helped UCC's development team learn which factors affected the effort the amount of fixed costs associated with training new personnel and required deliverables and resulted in a well-fitting effort estimation model. These insights give the development team a better understanding of the environment and where improvements are most necessary and possible.;
Proceedings of the 10th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments;Security metrics for software products provide quantitative measurement for the degree of trustworthiness for software systems. This paper proposes a new approach to define software security metrics based on vulnerabilities included in the software systems and their impacts on software quality. We use the Common Vulnerabilities and Exposures (CVE) an industry standard for vulnerability and exposure names and the Common Vulnerability Scoring System (CVSS) a vulnerability scoring system designed to provide an open and standardized method for rating software vulnerabilities in our metric definition and calculation. Examples are provided in the paper which show that our definition of security metrics is consistent with the common practice and real-world experience about software quality in trustworthiness.;
Proceedings of the 47th Annual ACM Southeast Conference;"Coverage-based Greybox Fuzzing (CGF) is a random testing approach that requires no program analysis. A new test is generated by slightly mutating a seed input. If the test exercises a new and interesting path it is added to the set of seeds otherwise it is discarded. We observe that most tests exercise the same few high-frequency"" paths and develop strategies to explore significantly more paths with the same number of tests by gravitating towards low-frequency paths. We explain the challenges and opportunities of CGF using a Markov chain model which specifies the probability that fuzzing the seed that exercises path i generates an input that exercises path j. Each state (i.e. seed) has an energy that specifies the number of inputs to be generated from that seed. We show that CGF is considerably more efficient if energy is inversely proportional to the density of the stationary distribution and increases monotonically every time that seed is chosen. Energy is controlled with a power schedule.We implemented the exponential schedule by extending AFL. In 24 hours AFLFAST exposes 3 previously unreported CVEs that are not exposed by AFL and exposes 6 previously unreported CVEs 7x faster than AFL. AFLFAST produces at least an order of magnitude more unique crashes than AFL.""";
Proceedings of the 2018 International Conference on Computing and Artificial Intelligence;Implementing secure code is an important and oft-overlooked non-functional requirement. Secure programming errors are a subset of program errors that result in many common privacy and security breaches in commercial software. We are seeking to provide interactive support for secure programming in the development environment. In this paper we have evaluated our prototype tool ASIDE which provides real-time warnings and code generation to reduce secure programming errors introduced by programmers. We evaluate the potential use and effectiveness of ASIDE on both novice and professional developers in two comparison user studies. Our results demonstrate that the interactive support can help address this important non-functional requirement and suggest guidelines for such tools to support programmers.;
Proceedings of the SIGCHI Conference on Human Factors in Computing Systems;Software vulnerabilities can severely affect an organization's infrastructure and cause significant financial damage to it. A number of tools and techniques are available for performing vulnerability detection in software written in various programming platforms in a pursuit to mitigate such defects. However since the requirements for running such tools and the formats in which they store and present their results vary wildly it is difficult to utilize many of them in the scope of a project. By simplifying the process of running a variety of vulnerability detectors and collecting their results in an efficient automated manner during development the task of tracking security defects throughout the evolution history of software projects is bolstered. In this paper we present tracer a software framework and platform to support the development of more secure applications by constantly monitoring software projects for vulnerabilities. The platform allows the easy integration of existing tools that statically detect software vulnerabilities and promotes their use during software development and maintenance. To demonstrate the efficiency and usability of the platform we integrated two popular static analysis tools FindBugs and Frama-c as sample implementations and report on preliminary results from their use.;
Proceedings of the 18th Panhellenic Conference on Informatics;In this keynote I describe the emerging need of cloud data analytics for security and call for the security community to devote to closing the gap between research innovation and practical deployment. Cloud data analytics refer to cloud platforms that provide pattern recognition and data discovery services to clients. This talk will discuss how cloud data analytics can be designed to achieve system security that is securing clients' systems against advanced exploits and attacks by providing transparent and seamless automatic data gathering system behavior monitoring and feedback. Such a cloud framework has the potential to provide practical security services and has multiple advantages e.g. update-to-date security protection scalability individualized anomaly detection and ease of deployment. It would allow clients to outsource complex system security monitoring and computation tasks to the cloud/security service providers without having to tend to tedious low-level details (e.g. model training and tuning update).This new direction of security analytics in the cloud presents a wide range of exciting research and business opportunities as well as unique technical and privacy challenges. I survey the existing data-driven system and network monitoring techniques and discuss what it will take to outsource them to the cloud. The talk will draw from my research experiences on a number of data-driven security projects including program anomaly detection data-leak detection as a service and network traffic causal analysis.;
Proceedings of the Fifth ACM International Workshop on Security in Cloud Computing;Developers use cryptographic APIs in Android with the intent of securing data such as passwords and personal information on mobile devices. In this paper we ask whether developers use the cryptographic APIs in a fashion that provides typical cryptographic notions of security e.g. IND-CPA security. We develop program analysis techniques to automatically check programs on the Google Play marketplace and find that 10.327 out of 11748 applications that use cryptographic APIs -- 88% overall -- make at least one mistake. These numbers show that applications do not use cryptographic APIs in a fashion that maximizes overall security. We then suggest specific remediations based on our analysis towards improving overall cryptographic security in Android applications.;
Proceedings of the 2013 ACM SIGSAC Conference on Computer &amp Communications Security;Software project workspaces are areas of constant project activities across different phases of the software development lifecycle. Besides being physical spaces to house the team members these are also areas of teamwork creativity and collaboration. It is well established that there are several information and insight needs of software teams (both individual and collective) during the course of any project. Interestingly the use of the project workspaces themselves for assisting in getting those insights has been almost non-existent and there is little technological support for doing so. Here we present our approach that utilizes advances in extended reality to augment the software project bay with important insights which are anchored on and around real objects in the workspace. The approach is based upon mining the data exhaust (disparate sources of data and logs) of the software project and development environment for data important to construct insights relevant to an XR headset wearer and the team. The wearer's location and parts of the workspace (floors furniture ceilings) are detected in the wearer's field of view and thereon spatial mapping is utilized to overlay important representations of the relevant insights onto/around them. The immersive insights are contextual can be continuously updated and leverage affordances of human perception for better comprehension enhanced creativity as well as recall. Along with our approach we also present an early Microsoft Hololens based implementation which allows for different categories of live augmentations for creating a smart immersive workspace.;
Proceedings of the 2013 Companion Publication for Conference on Systems Programming &amp Applications: Software for Humanity;Users and administrators are often faced with the choice between different software solutions sometimes even have to assess the security of complete software systems. With sufficient time and resources such decisions can be based on extensive testing and review. However in practice this is often too expensive and time consuming.In this paper we present a pragmatic but scalable approach for the trustworthiness assessment of software programs based on their security history. The approach can be used to e.g. automatically sort programs in an App store by their security record or to assess the trustworthiness of complex software systems in remote attestation schemes. Our prototype implementation for the popular Debian GNU/Linux system achieves good prediction accuracy for individual programs as well as entire systems.;
Proceedings of the Sixth ACM Workshop on Scalable Trusted Computing;Cost of a skilled and competent software developer is high and it is desirable to minimize dependency on such costly human resources. One of the ways to minimize such costs is via automation of various software development tasks.Recent advances in Artificial Intelligence (AI) and the availability of a large volume of knowledge bearing data at various software development related venues present a ripe opportunity for building tools that can automate software development tasks. For instance there is significant latent knowledge present in raw or unstructured data associated with items such as source files code commit logs defect reports comments and so on available in the Open Source Software (OSS) repositories.We aim to leverage such knowledge-bearing data the latest advances in AI and hardware to create knowledge warehouses and expert systems for the software development domain. Such tools can help in building applications for performing various software development tasks such as defect prediction effort estimation code review etc.;
Proceedings of the International Conference on Software and System Processes;Modern mobile devices store and process an abundance of data. Although many users consider some of this data as private they do not yet obtain satisfactory support for controlling what applications might do with their data.In this article we propose Cassandra a tool that enables users of mobile devices to check whether Android apps comply with their personal privacy requirements before installing these apps. Beyond this Cassandra implements the core functionality of a conventional app store including the browsing of available apps and the delivery of apps for installation. Cassandra performs the security analysis of apps on a server. However a user does not need to trust this server because Cassandra employs the proof-carrying code paradigm such that the server's analysis result can be validated on the client. We have proven that Cassandra's security analysis soundly detects all potential information leaks i.e. all flows of information that violate a user's privacy policy.;
Proceedings of the 4th ACM Workshop on Security and Privacy in Smartphones &amp Mobile Devices;We present the STEX+ system a user-driven advancement of STEX --- a semantic extension of LATEX that allows for producing high-quality PDF documents for (proof)reading and printing as well as semantic XML/OMDoc documents for the Web or further processing. Originally STEX had been created as an invasive semantic frontend for authoring XML documents. Here we used STEX in a Software Engineering case study as a formalization tool. In order to deal with modular pre-semantic vocabularies and relations we upgraded it to STEX+ in a participatory design process. We present a tool chain that starts with an STEX+ editor and ultimately serves the generated documents as XHTML+RDFa Linked Data via an OMDoc-enabled versioned XML database. In the final output all structural annotations are preserved in order to enable semantic information retrieval services.;
Proceedings of the 6th International Conference on Semantic Systems;In this paper we propose PETRA an energy-efficient and secure software update protocol for severely-constrained network devices. PETRA ensures the authenticity and end-to-end integrity of software update components delivered from trusted content distribution networks. The protocol operates by employing a set of energy-efficient data structures and cryptographic constructs to efficiently detect any form of man-in-the-middle modification attacks on the update packets. This methodology contributes to a sizeable decrease in network traffic and as a result huge energy savings. This makes PETRA a very suitable security protocol for limited-resource battery-operated devices such as low-end mobile phones wireless sensors and even Radio Frequency Identification Devices (RFIDs) tags. Moreover PETRA realizes an incremental security verification mechanism that allows the dynamic eager loading of received software components. This mechanism prevents any form of service disruption or operation downtime during the code upgrade process. A prototype PETRA implementation is tested on a grid of simulated micaz sensor nodes running the TinyOS operating system. A platform-independent performance analysis and an experimental simulation show that PETRA can achieve up to 30% average reduction in network-wide energy consumption.;
Proceedings of the 5th ACM Symposium on QoS and Security for Wireless and Mobile Networks;Due to the rise of the Internet of Things there are many new chips and platforms available for hobbyists and industry alike to build smart devices. The SDKs for these new platforms usually include closed-source binaries containing wireless protocol implementations cryptographic implementations or other library functions which are shared among all user code across the platform. Leveraging such a library vulnerability has a high impact on a given platform. However as these platforms are often shipped ready-to-use classic debug infrastructure like JTAG is often times not available.In this paper we present a method called Harzer Roller to enhance embedded firmware security testing on resource-constrained devices. With the Harzer Roller we hook instrumentation code into function call and return. The hooking not only applies to the user application code but to the SDK used to build firmware as well. While we keep the design of the Harzer Roller generally architecture independent we provide an implementation for the ESP8266 Wi-Fi IoT chip based on the xtensa architecture.We show that the Harzer Roller can be leveraged to trace execution flow through libraries without available source code and to detect stack-based buffer-overflows. Additionally we showcase how the overflow detection can be used to dump debugging information for later analysis. This enables better usage of a variety of software security testing methods like fuzzing of wireless protocol implementations or proof-of-concept attack development.;
Proceedings of the 3rd Reversing and Offensive-Oriented Trends Symposium;We present a new general technique for protecting clients in distributed systems against Remote Man-at-the-end (R-MATE) attacks. Such attacks occur in settings where an adversary has physical access to an untrusted client device and can obtain an advantage from tampering with the hardware itself or the software it contains.In our system the trusted server overwhelms the analytical abilities of the untrusted client by continuously and automatically generating and pushing to him diverse client code variants. The diversity subsystem employs a set of primitive code transformations that provide an ever-changing attack target for the adversary making tampering difficult without this being detected by the server.;
Proceedings of the 28th Annual Computer Security Applications Conference;Improper Input Validation (IIV) is a software vulnerability that occurs when a system does not safely handle input data. Even though IIV is easy to detect and fix it still commonly happens in practice.In this paper we study to what extent developers can detect IIV and investigate underlying reasons. This knowledge is essential to better understand how to support developers in creating secure software systems. We conduct an online experiment with 146 participants of which 105 report at least three years of professional software development experience. Our results show that the existence of a visible attack scenario facilitates the detection of IIV vulnerabilities and that a significant portion of developers who did not find the vulnerability initially could identify it when warned about its existence. Yet a total of 60 participants could not detect the vulnerability even after the warning. Other factors such as the frequency with which the participants perform code reviews influence the detection of IIV. Preprint: https://arxiv.org/abs/2102.06251. Data and materials: https://doi.org/10.5281/zenodo.3996696.;
Proceedings of the 12th Annual SIGCSE Conference on Innovation and Technology in Computer Science Education;After more than a decade of research web application security continues to be a challenge and the backend database the most appetizing target. The paper proposes preventing injection attacks against the database management system (DBMS) behind web applications by embedding protections in the DBMS itself. The motivation is twofold. First the approach of embedding protections in operating systems and applications running on top of them has been effective to protect this software. Second there is a semantic mismatch between how SQL queries are believed to be executed by the DBMS and how they are actually executed leading to subtle vulnerabilities in prevention mechanisms. The approach -- SEPTIC -- was implemented in MySQL and evaluated experimentally with web applications written in PHP and Java/Spring. In the evaluation SEPTIC has shown neither false negatives nor false positives on the contrary of alternative approaches causing also a low performance overhead in the order of 2.2%.;
Proceedings of the Sixth ACM Conference on Data and Application Security and Privacy;Software engineering (SE) students not only need sufficient technical knowledge and problem solving ability but also social and interpersonal skills in order to be industry ready. To prepare the students for the 'real world' the SE educators frequently use 'Authentic Assessment' and 'Project Based Learning (PBL)' approaches in their curricula. However the level of 'authenticity' should vary within PBL courses offered in different years of a degree program. In this paper we present and discuss the results of the data collected and analyzed from the first SE course offered to the students. The aim of our research is to explore how much authenticity can be achieved in the first SE course. Our study was conducted at the University of Calgary with 64 software development project teams totaling 229 undergraduate students. The data is collected from three semesters (2016--2018) in order to assess and monitor students performance. The course design used seven authentic assessments that focused on students skills while covering a complete software development lifecycle. The results from data analysis show that students made progress in some areas of problem solving skills however they struggled in their social skills (e.g. people handling skills negotiations skills and organizational skills) understanding software quality and adaptability.;
Proceedings of the 41st International Conference on Software Engineering: Software Engineering Education and Training;With agile methodologies increasingly being applied in regulated environments security and compliance emerge as critical issues. Combining both concerns is challenging because security engineering techniques are often based on linear development. We propose a method for achieving continuous and secure development by mapping the requirements of security standards into an agile process model. Additionally this allows verification of compliance even in the face of dynamic process changes. Applicability of the method is demonstrated by using Business Process Model and Notation (BPMN) to model and extend activities and artifacts of Scaled Agile Framework (SAFe) according to requirements of IEC 62443-4-1 a standard for secure product development in industrial systems.;
Proceedings of the 4th International Workshop on Rapid Continuous Software Engineering;This paper is devoted to static analysis of the software code security. We suggest using heuristic static code analysis to detect a full spectrum of vulnerabilities including backdoors. Production rules are suggested for use to formalize heuristics for detection of vulnerabilities. We developed a conceptual system of production models for detection of a full spectrum of vulnerabilities in the software code. This paper provides examples of heuristic formalization for detection of certain vulnerabilities classified subject to CWE register. It also provides a brief statistics of application of the suggested heuristic analysis in the study of the software code security.;
Proceedings of the 18th International Conference on Evaluation and Assessment in Software Engineering;This paper proposes an efficient hardware/software system that significantly enhances software security through diversified replication on multi-cores. Recent studies show that a large class of software attacks can be detected by running multiple versions of a program simultaneously and checking the consistency of their behaviors. However execution of multiple replicas incurs significant overheads on today's computing platforms especially with fine-grained comparisons necessary for high security. Orthrus exploits similarities in automatically generated replicas to enable simultaneous execution of those replicas with minimal overheads the architecture reduces memory and bandwidth overheads by compressing multiple memory spaces together and additional power consumption and silicon area by eliminating redundant computations. Utilizing the hardware architecture Orthrus implements a fine-grained memory layout diversification with the LLVM compiler and can detect corruptions in both pointers and critical data. Experiments indicate that the Orthrus architecture incurs minimal overheads and provides a protection against a broad range of attacks.;
Proceedings of the Fifteenth International Conference on Architectural Support for Programming Languages and Operating Systems;Insufficiently tested software releases provoque a competition between 'exploiters' versus 'patchers'. Developing secure software from scratch greatly reduces maintenance effort. The integration of regular security checks combined with patch proposals at development time enhances the system's usability and software quality. This paper presents a software development system including version control security analysis and patching support. As a practical aspect avoiding flaws becomes easier even for non security experts.;
Proceedings of the Fourth International Workshop on Software Engineering for Secure Systems;Insider attacks are particularly insidious threats to electoral integrity. Traitors that misuse the trust that is placed in them often have system access that facilitates malicious acts themselves and their subsequent cover-up efforts.In this paper we define what it means to be an insider and we identify several classes of elections insiders. We also categorize the threats that each insider class has relative to the electoral functions.Beyond specifying well-known elections insiders such as poll workers and local elections officials we address several insider categories that are rarely or never mentioned in considering election insider threats. For example we have not previously seen members of the judiciary identified as prospective elections insiders and we give a concrete example of how judges can accomplish insider attacks on elections. Similarly we identify the impact that policy makers can have on the electoral process and show how malicious legislators may be able to influence a broad spectrum of elections through the laws that they propose and promote.Insider attacks are real and imminent threats to electoral integrity. By identifying insiders and categorizing the threats that they pose allows us to create policies and procedures that better ensure sound elections and to ensure the integrity of our way of government at local state and federal levels.;
Proceedings of the 2010 Workshop on Governance of Technology Information and Policies;Dynamic taint analysis is a program analysis technique in which data is marked and its propagation is tracked while the program is executing. It is applied to solve problems in many fields especially in software security. Current taint analysis platforms are limited to a single programming language and therefore cannot support programs which as is common today are implemented in multiple programming languages. Current implementations of dynamic taint analysis also incur a significant performance overhead.  In this paper we address both these limitations (1) by presenting our vision of a multi-language dynamic taint analysis platform which is built around a language-agnostic core framework that is extended by language-specific front-ends and (2) by discussing the use of speculative optimization and dynamic compilation to reduce the execution overhead of dynamic taint analysis applications. An implementation of such a platform would enable dynamic taint analyses that can target multiple languages in one analysis implementation and can track tainted data across language boundaries. We describe this approach in the context of the GraalVM runtime and its included JIT compiler Graal which allows us to target both dynamic and static languages.;
Proceedings of the 16th ACM SIGPLAN International Conference on Managed Programming Languages and Runtimes;The state of web security remains troubling as web applications continue to be favorite targets of hackers. Static analysis tools are important mechanisms for programmers to deal with this problem as they search for vulnerabilities automatically in the application source code allowing programmers to remove them. However developing these tools requires explicitly coding knowledge about how to discover each kind of vulnerability. This paper presents a new approach in which static analysis tools learn to detect vulnerabilities automatically using machine learning. The approach uses a sequence model to learn to characterize vulnerabilities based on a set of annotated source code slices. This model takes into consideration the order in which the code elements appear and are executed in the slices. The model created can then be used as a static analysis tool to discover and identify vulnerabilities in source code. The approach was implemented in the DEKANT tool and evaluated experimentally with a set of open source PHP applications and WordPress plugins finding 16 zero-day vulnerabilities.;
Proceedings of the 25th International Symposium on Software Testing and Analysis;This poster reports on an exploratory study of E2EE communication software adoption factors among academics at five Slovenian universities (N = 367). The results of the study suggest that information sensitivity plays an important role in adoption of E2EE communication software. Privacy concerns and fear of government intrusions affect adoption only when information sensitivity is high. Protection motivation may not be applicable to this context as only perceived vulnerability affected adoption for high information sensitivity.;
Proceedings of the First Australasian Web Conference - Volume 144;Preventing unauthorized access to sensitive data is an exceedingly complex access control problem. In this keynote I will break down the data breach problem and give insights into how organizations could and should do to reduce their risks. The talk will start with discussing the technical reasons behind some of the recent high-profile data breach incidents (e.g. in Equifax Target) as well as pointing out the threats of inadvertent or accidental data leaks. Then I will show that there are usually multiple points to stop data breach and give an overview of the relevant state-of-the-art solutions. I will focus on some of the recent algorithmic advances in preventing inadvertent data loss including set-based and alignment-based screening techniques outsourced screening and GPU-based performance acceleration. I will also briefly discuss the role of non-technical factors (e.g. organizational culture on security) in data protection. Because of the cat-and-mouse-game nature of cybersecurity achieving absolute data security is impossible. However proactively securing critical data paths through strategic planning and placement of security tools will help reduce the risks. I will also point out a few exciting future research directions e.g. on data leak detection as a cloud security service and deep learning for reducing false alarms in continuous authentication and the prickly insider-threat detection.;
Proceedings of the 23nd ACM on Symposium on Access Control Models and Technologies;The rapid growth of Internet-of-things (IoT) software applications has driven both practitioners and researchers' attention to methodological approaches for secure IoT development. Security issues for IoT is special in the way that they include not only software but also hardware and network concerns. With the aim at proposing a methodological approach for secure IoT application development we investigated what are security challenges in the context of IoT development. We reviewed literature and investigated two industry cases. The preliminary finding results in a list of 17 security challenges with regards to technical organizational and methodological perspectives. Cross-case comparison provides initial explanation about the less emphasis on methodological and organizational security concerns in our cases.;
Proceedings of the XP2017 Scientific Workshops;Program slicing techniques like static dynamic and hybrid slicing are considered to be an effective aid in the areas of program analysis and debugging. The performance parameters of these techniques such as precision and execution overhead determine their efficiency and applicability. In the context of debugging a few bugs the existing dynamic and hybrid approaches tend to be expensive in terms of high runtime overhead while static slicing approaches fail to be precise.In this paper we present a tool called JDAS to simplify the tedious task of debugging. The tool provides an intuitive way for the user to specify a bug and helps in efficient debugging by providing only the relevant information related to the bug being analyzed. We propose a lightweight approach for program analysis and debugging which is effective when the bugs to be analyzed are few. We make use of static slicing which reduces the runtime cost and also helps in computing all the essential information including those which are not present in a dynamic slice as illustrated by the concept of relevant slicing. We harness the power of dynamic aspect oriented programming for effective tracing and thereby overcome the problem of imprecision in the slice result generated by static slicing. We introduce line number based pointcuts for efficient tracing.;
Proceedings of the 3rd India Software Engineering Conference;In recent years we have been exploring ways to foster a closer collaboration between software engineering research and industry both to align our research with practical needs and to increase awareness about the importance of research for innovation. This paper outlines our experience with three research projects conducted in collaboration with the industry. We examine the way we collaborated with our industry partners and describe the decisions that contributed to the effectiveness of the collaborations. We report on the lessons learned from our experience and illustrate the lessons using examples from the three projects. The lessons focus on the applications of Model-Driven Engineering (MDE) as all the three projects we draw on here were MDE projects. Our goal from structuring and sharing our experience is to contribute to a better understanding of how researchers and practitioners can collaborate more effectively and to gain more value from their collaborations.;
Proceedings of the 15th International Conference on Model Driven Engineering Languages and Systems;NVD is one of the most popular databases used by researchers to conduct empirical research on data sets of vulnerabilities. Our recent analysis on Chrome vulnerability data reported by NVD has revealed an abnormally phenomenon in the data where almost vulnerabilities were originated from the first versions. This inspires our experiment to validate the reliability of the NVD vulnerable version data. In this experiment we verify for each version of Chrome that NVD claims vulnerable is actually vulnerable. The experiment revealed several errors in the vulnerability data of Chrome. Furthermore we have also analyzed how these errors might impact the conclusions of an empirical study on foundational vulnerability. Our results show that different conclusions could be obtained due to the data errors.;
Proceedings of the 8th ACM SIGSAC Symposium on Information Computer and Communications Security;Improper Input Validation (IIV) is a dangerous software vulnerability that occurs when a system does not safely handle input data. Although IIV is easy to detect and fix it still commonly happens in practice so why do developers not recognize IIV? Answering this question is key to understand how to support developers in creating secure software systems.In our work we studied to what extent developers can detect IIV and investigate underlying reasons. To do so we conducted an online experiment with 146 software developers. In this document we explain how to obtain the artifact package of our study the artifact material and how to use the artifacts.;
Proceedings of the 6th International Conference on Security of Information and Networks;"Memory corruptions are still the most prominent venue to attack otherwise secure programs. In order to make exploitation of software bugs more difficult defenders introduced a vast number of post corruption security mitigations such as wâŠ•x memory Stack Canaries and Address Space Layout Randomization (ASLR) to only name a few. In the following we describe the Wiederg\{a""";
Proceedings of the 1st Reversing and Offensive-Oriented Trends Symposium;Prior studies found peer code review useful in identifying security defects. That is why most of the commercial and open-source software (OSS) projects embraced peer code review and mandated the use of it in the software development life cycle. However despite conducting mandatory peer code review practices many security-critical OSS projects such as Chromium Mozilla and Qt are reporting a high number of post-release vulnerabilities to the Common Vulnerabilities and Exposures (CVE) database. Practitioners may wonder if there is any missing piece in the puzzle that leads code reviews to miss those security defects. Therefore the primary objective of this dissertation study is to improve the effectiveness of peer code review in identifying security defects.  To meet this goal I plan to empirically investigate: (i) why security defects escape code reviews (ii) what are the challenges developers face to conduct effective security code reviews (iii) how to build effective security code review strategy and (iv) how to make effective utilization of security experts during code reviews.;
Proceedings of the 2016 International Symposium on Code Generation and Optimization;Context: There has been an increasing use of agile techniques for safety-critical systems. Agile techniques embrace fast changing requirements continuously delivered products and frequent communication with lightweight documentation. Motivation: However for safety-critical system projects a lack of safety-related documentation influences the safety-related communication and may reduce the safety assurance's capability. Objective: In this article we aim to improve the safety-related documentation in a Scrum development process and to support a more efficient safety-related communication. Method: We investigated three types of safety-related documentation patterns in agile development: safety epic safety story and agile safety plan. We further adapted and implemented them in a student project at the University of Stuttgart Germany. We used participant observation Scrum artifacts documentation review and questionnaires combined with interviews to validate this adapted documentation concerning their effect on communication safety culture and general impact on organization. Result: The results showed that safety story and safety epic have a positive effect on both internal and external communication. However the agile safety plan showed little effect on communication. Rather it has general impact on the safety process overview priority management providing a safety backup knowledge as well as having a delivered safety assessment report. Conclusion: To improve safety-related communication in a Scrum development process for safety-critical systems the safety story and the safety epic are strongly suggested while an agile safety plan should be further investigated depending on its general impact in various projects.;
Proceedings of the 4th International Workshop on Cooperative and Human Aspects of Software Engineering;Performance regression testing is an important step in the software development lifecycle especially for enterprise applications. Commonly the analysis of performance regression testing to find anomalies is carried out manually and therefore can be error-prone time consuming and sensitive to the input load. In our research we propose a new technique that overcomes the above problems which helps the performance testing teams to improve their process and speeds up the entire software production process.;
Proceedings of the 2013 International Symposium on Software Testing and Analysis;Software configurability opens the door to misconfiguration vulnerabilities invalid settings that expose software weaknesses. Misconfiguration is one the top ten most critical security risks and the most common. This paper envisions a world without misconfiguration vulnerabilities through the use of automated reasoning techniques to infer and secure software configurations. Real-world software however often lacks an explicit specification of secure configurations relying on hand-validation by users. Real-world systems comprise many individual highly-configurable software components making the space of possible configurations for the whole system enormous. To realize our vision and overcome these challenges we aim to create a rigorous definition of configuration specifications use formal methods to mechanize the inference and generation of valid configurations and develop algorithms to automatically secure against misconfiguration.;
Proceedings of the 14th International Conference on Information Processing in Sensor Networks;Proliferating supply chain attacks indicate that today's practices are insufficient for ensuring security and increasingly represent the weakest link in cybersecurity of software-based operational technologies. By tracking every action of integrating procured software components into an existing system from analyzing vendorsâ€™ security to auditing purchaser's supply chain a more secure software supply chain can be provided. Hyperledger Fabric as a permissioned blockchain network provides immutable i.e. tamper-proof solution for tracking the information stored on the ledger while allowing only preauthorized actors to participate in the network. An approach that is taken in this paper is to track the software components that are introduced in the system whether they are commercial-off-the-shelf components or tailor-made components and track their security analysis by utilizing blockchain technology. By defining Organization in blockchain network which can participate in the supply chain management process this paper demonstrates the benefits of utilizing Hyperledger Fabric for managing acquired software components that are introduced in critical infrastructure. Given the analyzed use cases and proposed architecture it can be concluded that Hyperledger Fabric blockchain provides necessary trust in a multi-party environment which is the basis for more efficient auditing of the whole process. The trustworthy logs and easier auditing are the key enablers for a supply chain management process that can address the described needs.;
7th Conference on the Engineering of Computer Based Systems;Agent systems are used for a wide range of applications and techniques to detect and avoid defects in such systems are valuable. In particular it is desirable to detect issues as early as possible in the software development lifecycle. We describe a technique for checking the plan structures of a BDI agent design against the requirements models specified in terms of scenarios and goals. This approach is applicable at design time not requiring source code. A lightweight evaluation demonstrates that a range of defects can be found using this technique.;
Proceedings of the 2015 International Conference on Autonomous Agents and Multiagent Systems;Nowadays the dimension and complexity of software development projects increase the possibility of cyber-attacks information exfiltration and data breaches. In this context developers play a primary role in addressing privacy requirements and consequently security in software applications. Currently only general guidelines exist that are difficult to put in operation due to the lack of the required security skills and knowledge and to the use of legacy software development processes that do not deal with privacy and security aspects. This paper presents a knowledge base the Privacy Knowledge Base (PKB) and the VIS-PRISE prototype (Visually Inspection to Support Privacy and Security) a visual tool that support developers' decisions to integrate privacy and security requirements in all software development phases. An initial experimental study with junior developers is also presented.;
Proceedings of the 2020 International Conference on Advanced Visual Interfaces;Embedded system security has become a critical challenge given the increasing prevalence of network-connected systems. While anomaly-based detection methods provide the advantage of detecting zero-day exploits existing approaches incur significant performance overheads and are susceptible to mimicry attacks. In this paper we present a formal runtime security model that defines the normal system behavior. The runtime security model is applied to a timing-based runtime anomaly detection method that utilizes on-chip hardware to non-intrusively monitor both the system execution sequence and execution timing to detect malicious activity. Monitoring all possible execution paths of an embedded application is infeasible due to its complexity. Thus we analyze the properties of the timing distribution for control flow events within a network-connected pacemaker to evaluate the resulting detection rate for various levels of mimicry attacks considering constraints on the number of monitored events supported in the on-chip hardware.;
Proceedings of the WESS'15: Workshop on Embedded Systems Security;We present RESCURE a security solution built on software which retrofits Internet of Things (IoT) devices to secure ones. RESCURE exploits the entropy originating from the random variations of silicon (transistors) during manufacturing and generates a unique unforgeable root key and an identity per device. In this way root key and identity are inseparable from the IoT hardware. To achieve lifetime reliability (reproducibility) and security (randomness) for root key and identity we apply error correcting and randomness amplification algorithms to the signals derived from silicon. RESCURE supports certificates which are able to prove the device identity and authenticity. RESCURE supports multiple keys derivation (private keys or private/public key pairs) and End-to-End security. In this way an IoT device is able to communicate securely and independently with multiple actors (e.g. Service Providers). It supports secure storage so it is able to encrypt sensitive data such as application keys sensitive data or software Intellectual Properties (IP). Finally the entire device software is protected by secure boot and secure software update mechanisms allowing for malware-free software execution and renewable security and features. RESCURE has been prototyped on an ST32L4 device and its performance is presented across real use case scenarios covering the entire life cycle of the device. It is a low-cost solution for all the devices manufacturers that want to achieve high standard security without redesigning the hardware of their IoT product.;
Proceedings of the 48th Annual ACM Southeast Conference;Following the success of software engineering design patterns security patterns are a promising approach to aid in the design and development of more secure software systems. At the same time recent studies on aspect-oriented programming (AOP) suggest that software security concerns are good candidates for AOP techniques. Building upon the authors' previous work on aspectization of security patterns this study contributes the development of aspect-oriented strategy sections for a set of web-tier security patterns. It also adds to the small but growing body of quantitative evidence on the effects of aspectization on the modularity of security pattern code.;
Proceedings of the XV Brazilian Symposium on Information Systems;Proactive security review and test efforts are a necessary component of the software development lifecycle. Since resource limitations often preclude reviewing testing and fortifying the entire code base prioritizing what code to review/test can improve a team's ability to find and remove more vulnerabilities that are reachable by an attacker. One way that professionals perform this prioritization is the identification of the attack surface of software systems. However identifying the attack surface of a software system is non-trivial. The goal of this poster is to present the concept of a risk-based attack surface approximation based on crash dump stack traces for the prioritization of security code rework efforts. For this poster we will present results from previous efforts in the attack surface approximation space including studies on its effectiveness in approximating security relevant code for Windows and Firefox. We will also discuss future research directions for attack surface approximation including discovery of additional metrics from stack traces and determining how many stack traces are required for a good approximation.;
Proceedings of the Symposium and Bootcamp on the Science of Security;An implementation of a 1-Wire network (MicroLan) for temperature monitoring is presented. The observations of the author regarding important parameters of the network such as maximum length and maximum number of devices are stated. The architecture and algorithm of the data acquisition system are presented. Specific attention is given to techniques for protecting the software implementation against reverse engineering and unauthorized use.;
Proceedings of the International Conference on Computer Systems and Technologies and Workshop for PhD Students in Computing;While software protection mechanisms such as DRM and online services hinder the unrestrained duplication of games and applications these mechanisms fail at protecting individual software components from reuse by intellectual property thieves. While conceptually watermarking can discourage software misuse and allows proof of ownership embedding watermarks requires expert knowledge. This is why software watermarks are barely used.This paper presents LLWM an LLVM-based watermarking framework that automates the embedding of watermarks and thus enables the widespread use of watermarking. LLWM incorporates several (adapted) implementations of existing watermarking techniques and provides the foundation for IR-Mark a new watermarking technique based on a modified register allocation. With LLWM built upon LLVM and its compiler Clang developers can use a watermark simply by compiling their codes without the obstacle of having to understand and run existing methods and standalone tools.With the methods included in LLWM we offer a variety of choices for embedding techniques and evaluate and discuss their characteristics and resilience against common attacks.;
Proceedings of the 2021 Research on Offensive and Defensive Techniques in the Context of Man At The End (MATE) Attacks;Not all vulnerabilities are equal. Some recent studies have shown that only a small fraction of vulnerabilities that have been reported has actually been exploited. Since finding and addressing potential vulnerabilities in a program can take considerable time and effort recently effort has been made to identify code that is more likely to be vulnerable. This paper tries to identify the attributes of the code containing a vulnerability that makes the code more likely to be exploited. We examine 183 vulnerabilities from the National Vulnerability Database for Linux Kernel and Apache HTTP server. These include eighty-two vulnerabilities that have been found to have an exploit according to the Exploit Database. We characterize the vulnerable functions that have no exploit and the ones that have an exploit using eight metrics. The results show that the difference between a vulnerability that has no exploit and the one that has an exploit can potentially be characterized using the chosen software metrics. However predicting exploitation of vulnerabilities is more complex than predicting just the presence of vulnerabilities and further research is needed using metrics that consider security domain knowledge for enhancing the predictability of vulnerability exploits.;
Proceedings of the 2nd International Conference on Interaction Sciences: Information Technology Culture and Human;A software birthmark is a set of characteristics extracted from an executable program. Software birthmark techniques are used to detect program theft by determining the similarity between two different programs. In this paper we propose a software birthmark based on a graph-based structure comparison scheme. By enhancing the function level comparison and the basic block level comparison algorithms we show that software birthmarks can have improved resilience compared to those of the original graph-based structure comparison scheme.;
Proceedings of the 2012 ACM Research in Applied Computation Symposium;Examining the characteristics of software vulnerabilities and the code that contains them can lead to the development of more secure software. We present a dataset (âˆ¼1.4 GB) containing vulnerable source code files together with the corresponding patched versions. Contrary to other existing vulnerability datasets ours includes vulnerable files written in more than 40 programming languages. Each file is associated to (1) a Common Vulnerability Exposures identifier (CVE ID) and (2) the repository it came from. Further our dataset can be the basis for machine learning applications that identify defects as we show in specific examples. We also present a supporting dataset that contains commit messages derived from Git commits that serve as security patches. This dataset can be used to train ML models that in turn can be used to detect security patch commits as we highlight in a specific use case.;
Proceedings of the 16th International Conference on Emerging Networking EXperiments and Technologies;Privacy patterns describe core aspects of privacy-enhancing solutions to recurring problems and can therefore be instrumental to the privacy-by-design paradigm. However the privacy patterns domain is still evolving. While the main focus is currently put on compiling and structuring high-quality privacy patterns in catalogs the support for developers to select suitable privacy patterns is still limited. Privacy patterns selection-support means in essence the quick and easy scoping of a collection of patterns to the most applicable ones based on a set of predefined criteria. To evaluate patterns against these criteria a thorough understanding of the privacy patterns landscape is required. In this paper (i) we show that there is currently a lack of extensive support for privacy patterns selection due to the insufficient understanding of pattern properties (ii) we propose additional properties that need to be analyzed and can serve as a first step towards a robust selection criteria (iii) we analyze and present the properties for 70 privacy patterns and (iv) we discuss a potential approach of how such a selection-support method can be realized.;
Proceedings of the 36th Annual ACM Symposium on Applied Computing;Concurrent systems based on (distributed) multi/many-core processing units are the nowadays reference computing architecture. The (continuously-growing) level of hardware parallelism they offer has led these platforms to play a central role at any scale ranging from data centers to personal (mobile) devices. Optimizing performance and/or ensuring energy efficiency when running complex software stacks on top of these systems is extremely challenging due to several aspects like data dependencies or resource sharing (and interference) among application threads as well as VMs. Furthermore hardware accelerators like GPGPUs or FPGAs introduce a level of heterogeneity that can potentially offer further opportunities for combined gain in performance and energy efficiency if correctly exploited.The goal of this workshop is to establish a venue for both academia and industry experts and practitioners where they can discuss challenges perspectives and opportunities given by researching on scalable energy-efficient and secure software deployed on top of modern (heterogeneous) concurrent platforms.;
Proceedings of the ACM/SPEC International Conference on Performance Engineering;Tagging offers a traceability mechanism for software development by connecting artifacts in a meaningful way. Our integrated courseware SEREBRO provides a framework of tools that capture conversation and artifact creation and modification throughout the software development lifecycle by student team members developing non-trivial software products in a Software Engineering course. Using a data driven approach we investigate the use of lightweight tagging mechanisms applied by student software project teams and present some preliminary results of this investigation.;
Proceedings of the 6th International Workshop on Traceability in Emerging Forms of Software Engineering;Unlike library code whose instruction addresses can be randomized by address space layout randomization (ASLR) application binary code often has static instruction addresses. Attackers can exploit this limitation to craft robust shell codes for such applications as demonstrated by a recent attack that reuses instruction gadgets from the static binary code of victim applications.This paper introduces binary stirring a new technique that imbues x86 native code with the ability to self-randomize its instruction addresses each time it is launched. The input to STIR is only the application binary code without any source code debug symbols or relocation information. The output is a new binary whose basic block addresses are dynamically determined at load-time. Therefore even if an attacker can find code gadgets in one instance of the binary the instruction addresses in other instances are unpredictable. An array of binary transformation techniques enable STIR to transparently protect large realistic applications that cannot be perfectly disassembled due to computed jumps code-data interleaving OS callbacks dynamic linking and a variety of other difficult binary features. Evaluation of STIR for both Windows and Linux platforms shows that stirring introduces about 1.6% overhead on average to application runtimes.;
Proceedings of the 2012 ACM Conference on Computer and Communications Security;Background: Testing is an essential activity in safety-critical software development following high standards in terms of code coverage. Mutation testing allows assessing the effectiveness of testing and helps to further improve test cases. However mutation testing is not widely practiced due to scalability problems when applied to real-world systems. Objective: The objective of the study is to investigate the applicability and usefulness of mutation testing for improving the quality of unit testing in context of safety-critical software systems. Method: A case study has been conducted together with an engineering company developing safety-critical systems. Mutation analysis has been applied to the studied system under test (60000 LOC of C code) producing 75043 mutants of which 27158 survived test execution. A sample of 200 live mutants has been reviewed by the engineers who also improved the existing unit test suite based on their findings. Findings: The reviewed sample contained 24+ equivalent mutants and 12+ duplicated mutants. It revealed a weak spot in the testing approach and provided valuable guidance to improve the existing unit test suite. Two new faults were found in the code when improving the tests. Test execution against the mutants required over 4000 hours computing time. The overall effort was about half a person year.;
Proceedings of the Symposium on Applied Computing;In contemporary software development anybody can become a developer sharing building and interacting with software components and services in a virtual free for all. In this environment it is not feasible to expect these developers to be expert in every security detail of the software they use and we discuss how difficult it can be to build secure software. In this respect the practical challenges of the emerging paradigm of developer-centered security are explored where developers would be required to consider security from the perspective of those other developers who use their software. We question whether current user-centered security techniques are adequate for this task and suggest that new thinking will be required. Two directions---symmetry of ignorance and security archaeology-are offered as a new way to consider this challenge.;
Proceedings of the 1st ACM Workshop on Virtual Machine Security;The rising popularity of the Internet-of-Things (IoT) devices has driven their increasing adoption in various settings such as modern homes. IoT systems integrate such physical devices with third-party apps which can coordinate in arbitrary ways. However malicious or undesired coordination can lead to serious vulnerabilities. This paper explores two different ways i.e. a commonly-used state-based approach and a holistic rule-based approach to formally model app coordination and the safety and security thereof in the context of IoT platforms. The less common rule-base approach allows for a smaller more scalable model. We realize both modeling approaches using bounded model checking with Alloy to automatically identify potential cases where apps exhibit coordination relationships. We evaluate the effectiveness of the modeling approaches by checking a corpus of real-world IoT apps of Samsung SmartThings and IFTTT. The experimental results demonstrate that our rule-based modeling leads to a more scalable analysis.;
Proceedings of the 2018 IEEE/ACM International Conference on Connected Health: Applications Systems and Engineering Technologies;New software security threats are constantly arising including new classes of attacks such as the recent spate of micro-architectural vulnerabilities from side-channels and speculative execution to attacks like Rowhammer that alter the physical state of memory. At the same time new defensive technologies are proposed and adopted including advancements in programming languages and novel hardware architectures with a focus on security.Moving target defenses were developed to provide performant incremental security to programs written in unsafe languages running on processors designed solely for performance. Here we examine the challenges and opportunities for moving target defenses in the evolving security landscape and in new applications domains such as cloud computing and real-time systems.;
Proceedings of the 8th ACM Workshop on Moving Target Defense;Security is often a critical problem in software systems. The consequences of the failure lead to substantial economic loss or extensive environmental damage. Developing secure software is challenging and retrofitting existing systems to introduce security is even harder. In this paper we propose an automated approach for &ltu&gtFi&lt/u&gtnding and &ltu&gtRe&lt/u&gtpairing &ltu&gtBugs&lt/u&gt based on security patterns (FireBugs) to repair defects causing security vulnerabilities. To locate and fix security bugs we apply security patterns that are reusable solutions comprising large amounts of software design experience in many different situations. In the evaluation we investigated 2800 Android app repositories to apply our approach to 200 subject projects that use javax.crypto APIs. The vision of our automated approach is to reduce software maintenance burdens where the number of outstanding software defects exceeds available resources. Our ultimate vision is to design more security patterns that have a positive impact on software quality by disseminating correlated sets of best security design practices and knowledge.;
Proceedings of the 6th International Conference on Mobile Software Engineering and Systems;Micro-service application pattern has revolutionize the overall software delivery lifecycle. Modularization has allowed breaking monolithic application into independent components that can be developed faster and automation in CICD has enabled high velocity deployment of applications to the cloud. Such a modernization has mandated a need to put security at the center of the workflow from code to container giving rise to the DevSecOps paradigms. Although effectiveness of the existing DevSecOps solutions is limited by lack of good development practices and narrow scope where it is applied for security analytic only around code hygiene like vulnerability scanning license auditing etc. We discuss our survey on these challenges and highlight their security implications. In tapiser\'{\i;
Proceedings of the Seventh International Workshop on Container Technologies and Container Clouds;Software's security depends greatly on how a system was designed so it's very important to capture security requirements at the requirements engineering phase. Existing approaches look at the same problem from different perspectives such as the user the threat or the goal perspective. This creates huge gaps between them in terms of the used terminology and the steps followed to obtain security requirements. This research aims to define an approach as comprehensive as possible by incorporating the strengths and best practices found in existing approaches after a thorough analysis.;
Proceedings of the 2nd ACM Symposium on Information Computer and Communications Security;The complexity and size of Autonomous Driving (AD) software are comparably higher than that of software implementing other (standard) functionalities in the car. To make things worse a big fraction of AD software is not specifically designed for the automotive (or any other critical) domain but the mainstream market. This brings uncertainty on to which extent AD software adheres to guidelines in safety standards. In this paper we present our experience in applying ISO 26262 -- the applicable functional safety standard for road vehicles -- software safety guidelines to industrial AD software in particular Apollo a heterogeneous Autonomous Driving framework used extensively in industry. We provide quantitative and qualitative metrics of compliance for many ISO 26262 recommendations on software design implementation and testing.;
Proceedings of the 56th Annual Design Automation Conference 2019;Timing property plays a vital role in the Cyber-Physical System(CPS) due to its interaction with the physical world. The smooth operation of these robotic systems often relies on an accurate and timely perception and actuation of the physical world. In this poster we demonstrated a unique new class of attack Chronos that exploits timing interference to cause system destabilization in cyber-physical systems. Using a compromised non-privileged non-critical task on the system we launch timing interference attacks on both drone and autonomous vehicle platforms. Through both open-loop and close-loop testing on the end-to-end stack we showed that the timing attack could lead to complete loss of control of the autonomous system crashing them onto the surroundings when there is no software vulnerability. To further understand this novel attack vector we perform preliminary investigations on the localization component of these two platforms because they both make use of well-known simultaneous localization and mapping (SLAM) algorithms that depend on timing-sensitive multimodal data from different sensors. Building on the insights from the case study we present our formulation of the timing attack surface and highlight future directions.;
The 49th Annual IEEE/ACM International Symposium on Microarchitecture;Dynamic information flow tracking (DIFT) has shown to be an effective security measure for detecting both memory corruption attacks and semantic attacks at run-time on a wild range of systems from embedded systems and mobile devices to cloud computing. When applying DIFT to multi-thread applications running on multi-core architectures the data processing and metadata processing are normally decoupled i.e. being performed in different places at different times. Therefore if the metadata access is not in the same order as data access inconsistency issues may arise which would reduce the security effectiveness of DIFT. Avoiding such inconsistency between data access and metadata access i.e. maintaining metadata coherence has become a challenging issue. In this paper we propose METACE (METAdata Coherence Enforcement). METACE includes architectural enhancement in the memory management unit and leverages the existing cache coherence hardware and protocol to enforce metadata coherence. It introduces minimum changes to cores coprocessors and the memory hierarchy. It covers the complete set of data dependencies without deadlocks and is compatible with different memory consistency models. Our approach does not require modification of the source code. METACE supports out-of-order metadata access resulting in less performance degradation than previous approaches.;
Proceedings of the 2nd International Workshop on Hardware and Architectural Support for Security and Privacy;This paper proposes a new form of Security as a Service (SECaaS) that allows untrusted mostly serial computations in untrusted computing environments to be independently and efficiently validated by trusted commodity clouds. This addresses the longstanding problem of safely executing high assurance computations on untrusted hosts.Untrusted computations are instrumented with a checkpointing mechanism that yields a proof of computation integrity as the computation progresses. This proof can be validated by a trusted cloud to ensure that the computation was carried out faithfully. Cloud parallelism and replication is leveraged to validate the proof efficiently even when the original computation is not parallelized. This affords a means of high-assurance serial computation on cloud-aware mobile devices that mix resource-rich but untrusted hardware with trusted but comparatively resource-impoverished hardware components. An implementation for Java and Hadoop MapReduce demonstrates that the approach is effective for commodity VMs clouds and software.;
Proceedings of the 13th IEEE/ACM International Symposium on Cluster Cloud and Grid Computing;Requirements engineering is an extremely crucial phase in the software development lifecycle because mishaps in this stage are usually expensive to fix in later development phases. In the domain of computer games requirements engineering is a heavily studied research field (39.3% of published papers are dealing with requirements [1]) since it is considered substantially different from traditional software requirements engineering (see [1] and [14]). The main point of differentiation is that almost all computer games share a common key-driver as requirement i.e. user satisfaction. In this paper we investigate the most important user satisfaction factors from computer games though a survey on regular gamers. The results of the study suggest that user satisfaction factors are not uniform across different types of games (game genres) but are heavily dependent on them. Therefore this study underlines the most important non-functional requirements that developers and researchers should focus on while dealing with game engineering.;
Proceedings of the 18th International Academic MindTrek Conference: Media Business Management Content &amp Services;IBM SmartCloud is a branded collection of Cloud products and solutions from IBM. It includes Infrastructure as a Service (IaaS) Software as a Service (SaaS) and Platform as a Service (PaaS) offered through public private and hybrid cloud delivery models. This paper focuses on the software testing process employed for the SmartCloud iNotes SaaS application providing details of the methodologies and tools developed to streamline testing. The new tools have enabled the testing team to meet the pace of the highly agile development team enabling a more efficient software development lifecycle. Results indicate that the methodologies and tools used have increased the performance of the testing team: there was a decrease in the number of bugs present in the code (prior to release) and an overall increase in customer satisfaction.;
Proceedings of the 2013 International Workshop on Testing the Cloud;Software safety certification needs to address non-functional constraints with safety implications e.g. deadlines throughput and CPU and memory usage. In this paper we focus on CPU usage constraints and provide a framework to support the derivation of test cases that maximize the chances of violating CPU usage requirements. We develop a conceptual model specifying the generic abstractions required for analyzing CPU usage and provide a mapping between these abstractions and UML/MARTE. Using this model we formulate CPU usage analysis as a constraint optimization problem and provide an implementation of our approach in a state-of-the-art optimization tool. We report an application of our approach to a case study from the maritime and energy domain. Through this case study we argue that our approach (1) can be applied with a practically reasonable overhead in an industrial setting and (2) is effective for identifying test cases that maximize CPU usage.;
Proceedings of the 17th Panhellenic Conference on Informatics;Software development companies moving into the medical device domain often find themselves overwhelmed by the number of regulatory requirements they need to satisfy before they can market their device. Several international standards and guidance documents have been developed to help companies on their road to regulatory compliance but working their way through the various standards is a challenge in itself. In order to help software companies in the medical device domain we have developed an integrated framework of medical device software development best practices called MDevSPICEÂ®. This framework integrates generic software development best practices with medical device standardsâ€™ requirements enabling consistent and thorough assessment of medical device processes. MDevSPICEÂ® can be used by software companies evaluating their readiness for regulatory audits as well as by large medical device manufacturers for selecting suitable software suppliers. The MDevSPICEÂ® framework consists of a process reference model a process assessment model an assessment method and training and certification schemes. The framework has been validated using expert reviews and through MDevSPICEÂ® assessments in industry. In this paper we describe the MDevSPICEÂ® process assessment framework focusing on its benefits and significance for the medical device manufacturing community as learned from MDevSPICEÂ® assessments conducted to date.;
Proceedings of the 2015 International Conference on Software and System Process;Vulnerability discovery and exploiting are critical to software security. Emerging intelligent vulnerability discovery solutions usually require a large number of training data. Studying exploits also requires a set of existing exploit samples. As a result building a dataset for vulnerability and exploit research is necessary. In this paper we present CBTracer able to catch real-time I/O traffic of target applications and monitor their runtime executions to build an evolving dataset for kinds of security analysis including vulnerability discovery and exploit generation. CBTracer is a lightweight framework designed to be deployed easily in various CTF competitions by different organizers to build a bigger dataset. We used CBTracer to collect data from CGC challenges and deployed it in several real-world CTF challenges showing that it could efficiently collects security-related data.;
Proceedings of the First Workshop on Radical and Experiential Security;Software is continually increasing in size and complexity and therefore vulnerability discovery would benefit from techniques that identify potentially vulnerable regions within large code bases as this allows for easing vulnerability detection by reducing the search space. Previous work has explored the use of conventional code-quality and complexity metrics in highlighting suspicious sections of (source) code. Recently researchers also proposed to reduce the vulnerability search space by studying code properties with neural networks. However previous work generally failed in leveraging the rich metadata that is available for long-running large code repositories.In this paper we present an approach named Bran to reduce the vulnerability search space by combining conventional code metrics with fine-grained repository metadata. Bran locates code sections that are more likely to contain vulnerabilities in large code bases potentially improving the efficiency of both manual and automatic code audits. In our experiments on four large code bases Bran successfully highlights potentially vulnerable functions outperforming several baselines including state-of-art vulnerability prediction tools. We also assess Bran's effectiveness in assisting automated testing tools. We use Bran to guide syzkaller a known kernel fuzzer in fuzzing a recent version of the Linux kernel. The guided fuzzer identifies 26 bugs (10 are zero-day flaws) including arbitrary writes and reads.;
Proceedings of the 2021 ACM Asia Conference on Computer and Communications Security;"The software used by enterprise businesses for creating variable-data customer documents must be highly reliable and vendors are increasingly distributing such software via the cloud as an online service. This means that vendors now assume responsibility for the IT resources hosting and supporting the software as well as the customer documents and data. Vendors also assume responsibility for pushing updates to all customers simultaneously. To support the test and release of new versions software vendors must deploy and configure the software at an unprecedented rate.To reduce the time spent deploying and configuring software in the cloud and to minimize the chance for human error we present StackLauncher. By making it possible to automatically configure and launch software stacks"" with push-button simplicity StackLauncher is a valuable addition to the software development lifecycle for cloud deployment of enterprise document software.""";
Proceedings of the 2013 ACM Symposium on Document Engineering;Majority of the existing software watermarking tools are suffering from the limitations of existing robustness notions and lack of resilience from a variety of attacks. In this paper we propose a novel software watermarking tool called Shellmark that is resilient to most of the well known watermarking attacks. We describe the basic building blocks of the Shellmark and a complete guideline how to run the tool using a motivating example.;
Proceedings of the ACM India Joint International Conference on Data Science and Management of Data;Software systems are becoming increasingly complex. Within safety critical domains such as medical device software this increasing complexity is placing growing demands on manufacturers who must ensure their software not only meets functional requirements but is also safe and reliable. However the Food and Drugs Administration who regulate medical device software in the United States report a significant increase in recalls between years 2003 and 2012 and have cited software difficulties as one of the frequent causes of recalls. Furthermore a recent analysis of traceability documentation submitted to the Administration has revealed that the traceability data was incomplete incorrect and conflicting in many cases. This is problematic as traceability plays an important role in the development of safe and reliable software. In this paper we present the validation through industry trial of a traceability assessment and implementation framework which we have developed to assist medical device organizations implement traceability in an efficient and regulatory compliant manner. Our findings show that implementation of the framework within two organizations improved their traceability process and that both organizations found the framework to be both useful and usable.;
Proceedings of the 39th International Conference on Software Engineering: Software Engineering in Practice Track;Program Obfuscation that renders any given program essentially equivalent to a black box while desirable is impossible [4] in the general polynomial time adversary models. It is natural to search for positive results under restricted programs (e.g. point functions [20 2] POBDDs [10] cryptographic primitives [17 12 13]. Here we study straight line arithmetic programs.Our model of obfuscation requires an attacker to produce the entire code only by looking at the obfuscated program. We show that obfuscation is possible assuming factoring is hard and we have access to a tamper-resistant hardware (or secure token). We also assume that the programs can be sampled from some distribution. Our results are based on extending a result due to Shamir cite{Sha93;
Proceedings of the 14th ACM Conference on Computer and Communications Security;There has been a lot of research devoted to finding real-world software bugs but these studies have lacked some standard test sets as test subjects especially in the area of synthetic bugs. Although studies such as LAVA and Apocalypse have now suggested ways to inject bugs into real software these injected bugs are either a single type or the injection points are easily accessed by bug exploiters. In this paper we propose a bug injection system Deepbug that combines path extraction and taint analysis through which more hidden bugs can be injected into real software. In our experiments using Deepbug to inject bugs into four existing open-source software through fuzz testing of defective software we found that only a small number of these injected bugs were found by fuzzing tools.;
Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering;Security tools can help developers build more secure software systems by helping developers detect or fix security vulnerabilities in source code. However developers do not always use these tools. In this paper we investigate a number of social factors that impact developers' adoption decisions based on a multidisciplinary field of research called diffusion of innovations. We conducted 42 one-on-one interviews with professional software developers and our results suggest a number of ways in which security tool adoption depends on developers' social environments and on the channels through which information about tools is communicated. For example some participants trusted developers with strong reputations on the Internet as much as they trust their colleagues for information about security tools.;
Proceedings of the 17th ACM Conference on Computer Supported Cooperative Work &amp Social Computing;Despite extensive research over the last two decades runtime attacks on software are still prevalent. Recently smartphones of which millions are in use today have become an attractive target for adversaries. However existing solutions are either ad-hoc or limited in their effectiveness. In this poster we present a general countermeasure against runtime attacks on smartphone platforms. Our approach makes use of control-flow integrity (CFI) and tackles unique challenges of the ARM architecture and smartphone platforms. Our framework and implementation is efficient since it requires no access to source code performs CFI enforcement on-the-fly during runtime and is compatible to memory randomization and code signing/encryption. We chose Apple iPhone for our reference implementation because it has become an attractive target for runtime attacks. Our performance evaluation on a real iOS device demonstrates that our implementation does not induce any notable overhead when applied to popular iOS applications.;
Proceedings of the WICSA 2014 Companion Volume;Threat modeling is widely adopted and increasingly recognized as an essential step in the secure software development life cycle (SDLC). Focused on privacy-specific threat categories LINDDUN is a threat modeling framework that allows the identification of privacy-related design flaws at the stage of the initial architecture concept. LINDDUN advocates making explicit any assumptions during the identification and prioritization of privacy threats. These assumptions are in practice documented informally in a free-form textual format and the impact nature and purpose of these assumptions within the context of LINDDUN is not well understood.We present a descriptive study of assumptions made during the application of LINDDUN. This empirical study involves in total 122 threat models created for an IoT-based home automation system and a total of 845 studied assumptions. This study focuses on (i) clarifying the role of assumption-making in the threat modeling process and (ii) categorizing the types of information provided in these assumptions and (iii) their relation to the LINDDUN threat categories or more broadly any privacy-specific concepts.Our results indicate that in practice (i) assumptions are used to motivate exclusion of potential threats yet the rationale behind such decisions is often not documented (ii) many assumption are about the system under analysis and (iii) a majority is also relevant outside of the specific LINDDUN or privacy scope.;
Proceedings of the 2020 ACM Workshop on Forming an Ecosystem Around Software Transformation;Engineering methods are essential in software development and form a crucial element in the design and implementation of software security. Security engineering processes and activities have a long and well-standardized history of integration with software development methods. The inception of iterative and incremental software development methods raised suspicions of an inherent incompatibility between the traditional non-agile security processes and the new agile methods. This suspicion still affects the attitude towards agile security. To examine and explore this myth this study presents a literature review of a selected set of agile secure software development methods. A systematic literature method was used to find the definitive set of secure agile software development methods of which a core set of 11 papers was selected for analysis and the security activities documented in the methods were extracted. The results show a wide and well-documented adaptation of security activities in agile software development with the observed activities covering the whole security development life cycle. Based on the analysis the inherent insecurity of the agile software development methods can be declared to be a mere myth.;
Proceedings of the 7th International Workshop on Software Engineering for Secure Systems;Even though role-based access control (RBAC) can tremendously help us minimize the complexity in administering users it is still needed to realize the notion of roles at the resource level. In this paper we propose a practical cryptographic RBAC model called role-key hierarchy model to support various security features including signature and encryption based on role-key hierarchy. With the help of rich algebraic structure of elliptic curve we introduce a role-based cryptosystem construction to verify the rationality and validity of our proposed model. Also a proof-of-concept prototype implementation and performance evaluation are discussed to demonstrate the feasibility and efficiency of our mechanisms.;
Proceedings of the 5th ACM Symposium on Information Computer and Communications Security;Code randomization is an effective defense against code reuse attacks. It scrambles program code to prevent attackers from locating useful functions or gadgets. The key to secure code randomization is achieving high entropy. A practical approach to boost entropy is on-demand live randomization that works on running processes. However enabling live randomization is challenging in that it often requires manual efforts to solve ambiguity in identifying function pointers.In this paper we propose Remix an efficient and practical live randomization system for both user processes and kernel modules. Remix randomly shuffles basic blocks within their respective functions. By doing so it avoids the complexity of migrating stale function pointers and allows mixing randomized and non-randomized code to strike a balance between performance and security. Remix randomizes a running process in two steps: it first randomly reorders its basic blocks and then comprehensively migrates live pointers to basic blocks. Our experiments show that Remix can significantly increase randomness with low performance overhead on both CPU and I/O intensive benchmarks and kernel modules even at very short randomization intervals.;
Proceedings of the 2008 New Security Paradigms Workshop;Fault injection is a well-known method to physically attack embedded systems microcontrollers in particular. It aims to find and exploit vulnerabilities in the hardware to induce malfunction in the software and eventually bypass software security or retrieve sensitive information. We propose a low-cost platform called TRAITOR inducing faults with clock glitches with the capacity to inject numerous and precise bursts of faults. From an evaluation point of view this platform allows easier and cheaper investigations over complex attacks than costly EMI benches or laser probes.;
Proceedings of the 5th Brazilian Symposium on Systematic and Automated Software Testing;In software-intensive industries companies face the constant challenge of not having enough security experts on staff in order to validate the design of the high-complexity projects they run. Many of these companies are now realizing that increasing automation in their secure development process is the only way forward in order to cope with the ultra-large scale of modern systems. This paper embraces that viewpoint. We chart the roadmap to the development of a generative design tool that iteratively produces several design alternatives each attempting to solve the security goals by incorporating security mechanisms. The tool explores the possible solutions by starting from well-known security techniques and by creating variations via mutations and crossovers. By incorporating user feedback the tool generates increasingly better design alternatives.;
Proceedings of the 2019 ACM Asia Conference on Computer and Communications Security;Accessibility is an important quality attribute for Web applications. The W3C has defined a set of guidelines that must be followed to deploy accessible web applications however there is no process that support WCAG requirements during the software development lifecycle. This work proposes the inclusion of the WCAG 2.0 accessibility concerns in a Model-Driven Development more specifically in the WebML process.;
Proceedings of the 28th ACM International Conference on Design of Communication;Bad requirements quality can have expensive consequences during the software development lifecycle. Especially if iterations are long and feedback comes late - the faster a problem is found the cheaper it is to fix.  We propose to detect issues in requirements based on requirements (bad) smells by applying a light-weight static requirements analysis. This light-weight technique allows for instant checks as soon as a requirement is written down. In this paper we derive a set of smells including automatic smell detection from the natural language criteria of the ISO/IEC/IEEE 29148 standard.  We evaluated the approach with 336 requirements and 53 use cases from 9 specifications that were written by the car manufacturer Daimler AG and the chemical business company Wacker Chemie AG and discussed the results with their requirements and domain experts.  While not all problems can be detected the case study shows that lightweight smell analysis can uncover many practically relevant requirements defects. Based on these results and the discussion with our industry partners we conclude that requirements smells can serve as an efficient supplement to traditional reviews or team discussions in order to create fast feedback on requirements quality.;
Proceedings of the 1st International Workshop on Rapid Continuous Software Engineering;Human society is rapidly transforming to the digital society the new technologies drive digital and intelligent transformation in all industries. These technologies promise cost savings efficiency gains and new value. At the same time we see growing challenges relating to cyber security and privacy protection and functional safety etc. As a leading ICT product and service provider Huawei has been committed to providing customers with high-quality and user-friendly products and services. Two years ago Huawei initiated the Transformation Program for Software Engineering Capability Enhancement to improve company-wide software engineering capabilities improve the trustworthiness of both processes and results and to provide trustworthy and quality products. This talk will share the practices progress and challenges of the transformation.;
Proceedings of the 13th European Conference on Software Architecture - Volume 2;Background: Automated unit and integration tests allow software development teams to continuously evaluate their application's behavior and ensure requirements are satisfied. Interest in explicitly testing security at the unit and integration levels has risen as more teams begin to shift security left in their workflows but there is little insight into any potential pain points developers may experience as they learn to adapt their existing skills to write these tests. Aims: Identify security unit and integration testing pain points that could negatively impact efforts to shift security (testing) left to this level. Method: An mixed-method empirical study was conducted on 525 Stack Overflow and Security Stack Exchange posts related to security unit and integration testing. Latent Dirichlet Allocation (LDA) was applied to identify commonly discussed topics pain points were learned through qualitative analysis and links were analyzed to study commonly-shared resources. Results: Nine topics representing security controls components and scenarios were identified Authentication was the most commonly tested control. Developers experienced seven pain points unique to security unit and integration testing which were all influenced by the complexity of security control designs and implementations. Most linked resources were other Q&ampA posts but repositories and documentation for security tools and libraries were also common. Conclusions: Developers may experience several unique pain points when writing tests at this level involving security controls. Additional resources are needed to guide developers through these challenges which should also influence the creation of strategies and tools to help shift security testing to this level. To accelerate this actionable recommendations for practitioners and future research directions based on these findings are highlighted.;
Proceedings of the 12th International Conference on Security of Information and Networks;The design and implementation of artificial intelligence driven software that keeps user data private is a complex yet necessary requirement in the current times. Developers must consider several ethical and legal challenges while developing services which relay massive amount of private information over a network grid which is susceptible to attack from malicious agents. In most cases organizations adopt a traditional model training approach where publicly available data or data specifically collated for the task is used to train the model. Specifically in the healthcare section the operation of deep learning algorithms on limited local data may introduce a significant bias to the system and the accuracy of the model may not be representative due to lack of richly covariate training data. In this paper we propose CrossPriv a user privacy preservation model for cross-silo Federated Learning systems to dictate some preliminary norms of SaaS based collaborative software. We discuss the client and server side characteristics of the software deployed on each side. Further We demonstrate the efficacy of the proposed model by training a convolution neural network on distributed data of two different silos to detect pneumonia using X-Rays whilst not sharing any raw data between the silos.;
Proceedings of the 19th International Conference on Architectural Support for Programming Languages and Operating Systems;Security1 design of mobile apps is very important and it is also important that researchers consider and disseminate the continually changing requirements. For mobile application i.e. a software program that runs on a mobile phone its design development and management need to consider security impact. In particular because of mobile app is running on online devices cyber security defense is required. In this chapter mobile app security is discussed from the initial planning and design stage to its maintenance after its launch.;
Proceedings of the 2nd International Conference on Computer Science and Application Engineering;Uncontrolled memory consumption is a kind of critical software security weaknesses. It can also become a security-critical vulnerability when attackers can take control of the input to consume a large amount of memory and launch a Denial-of-Service attack. However detecting such vulnerability is challenging as the state-of-the-art fuzzing techniques focus on the code coverage but not memory consumption. To this end we propose a memory usage guided fuzzing technique named MemLock to generate the excessive memory consumption inputs and trigger uncontrolled memory consumption bugs. The fuzzing process is guided with memory consumption information so that our approach is general and does not require any domain knowledge. We perform a thorough evaluation for MemLock on 14 widely-used real-world programs. Our experiment results show that MemLock substantially outperforms the state-of-the-art fuzzing techniques including AFL AFLfast PerfFuzz FairFuzz Angora and QSYM in discovering memory consumption bugs. During the experiments we discovered many previously unknown memory consumption bugs and received 15 new CVEs.;
Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering;It is easier than ever before to build complex web applications that handle sensitive user data. At same time regulatory shifts have made data breaches more costly than ever before.While starting Akita I discovered just how difficult it is for software teams to maintain an up-to-date picture of how sensitive data flows across complex applications. A major challenge is that modern web applications run across many heterogenous components often communicating via remote procedure calls. Unfortunately network calls subvert all known software analysis methods for the application layer---and using network tools alone do not yield the full picture. The result is that developers end up piecing the whole story together through reading code logs and documentation.At Akita we observed that network-based application programming interfaces (APIs) are both a root cause of what we call the Software Heterogeneity Problem---and also the key to the solution. The proliferation of APIs for both internal and external use with the rise of service-oriented architectures and the growth of the API economy have made it easy to quickly build applications that are amalgams of cross-service network calls. At the same time there is consolidation around a handful of interface definition languages for web APIs. This makes it possible for us to address the Software Heterogeneity problem by applying programming languages techniques at the API layer.In this talk I will introduce the Software Heterogeneity Problem and its consequences demonstrate one way to tackle it at the API layer and outline API-level security problems I believe we can solve as a community.;
Proceedings of the 15th Workshop on Programming Languages and Analysis for Security;The positive effect of security information communicated to developers through API warnings has been established. However current prototypical designs are based on security warnings for end-users. To improve security feedback for developers we conducted a participatory design study with 25 professional software developers in focus groups. We identify which security information is considered helpful in avoiding insecure cryptographic API use during development. Concerning console messages participants suggested five core elements namely message classification title message code location link to detailed external resources and color. Design guidelines for end-user warnings are only partially suitable in this context. Participants emphasized the importance of tailoring the detail and content of security information to the context. Console warnings call for concise communication further information needs to be linked externally. Therefore security feedback should transcend tools and should be adjustable by software developers across development tools considering the work context and developer needs.;
Proceedings of the 1st ACM SIGPLAN International Workshop on Programming Language and Systems Technologies for Internet Clients;The reality of today's computing landscape already suffers from a shortage of cybersecurity professionals and this gap only expected to grow. We need to generate interest in this STEM topic early in our student's careers and provide teachers the resources they need to succeed in addressing this gap. To address this shortfall we present Practical LAbs in Security for Mobile Applications (PLASMA) a public set of educational security labs to enable instruction in creation of secure Android apps. These labs include example vulnerable applications information about each vulnerability steps for how to repair the vulnerabilities and information about how to confirm that the vulnerability has been properly repaired. Our goal is for instructors to use these activities in their mobile security and general computing courses ranging from secondary school to university settings. Another goal of this project is to foster interest in security and computing through demonstrating its importance. Initial feedback demonstrates the labs' positive effects in enhancing student interest in cybersecurity and acclaim from instructors. All project activities may be found on the project website: http://www.TeachingMobileSecurity.com;
Proceedings of the 17th International Conference on Mobile and Ubiquitous Multimedia;Context: Insecure coding patterns (ICPs) such as hard-coded passwords can be inadvertently introduced in infrastructure as code (IaC) scripts providing malicious users the opportunity to attack provisioned computing infrastructure. As performing code reviews is resource-intensive a characterization of co-located ICPs i.e. ICPs that occur together in a script can help practitioners to prioritize their review efforts and mitigate ICPs in IaC scripts. Objective: The goal of this paper is to help practitioners in prioritizing code review efforts for infrastructure as code (IaC) scripts by conducting an empirical study of co-located insecure coding patterns in IaC scripts. Methodology: We conduct an empirical study with 1613 2764 and 2845 Puppet scripts respectively collected from three organizations namely Mozilla Openstack and Wikimedia. We apply association rule mining to identify co-located ICPs in IaC scripts. Results: We observe 17.9% 32.9% and 26.7% of the scripts to include co-located ICPs respectively for Mozilla Openstack and Wikimedia. The most frequent co-located ICP category is hard-coded secret and suspicious comment. Conclusion: Practitioners can prioritize code review efforts for IaC scripts by reviewing scripts that include co-located ICPs.;
Proceedings of the 2nd ACM Workshop on Information Hiding and Multimedia Security;With the wide application and deployment of cloud computing in enterprises virtualization developers and security researchers are paying more attention to cloud computing security. The core component of cloud computing products is the hypervisor which is also known as the virtual machine monitor (VMM) that can isolate multiple virtual machines in one host machine. However compromising the hypervisor can lead to virtual machine escape and the elevation of privilege allowing attackers to gain the permission of code execution in the host. Therefore the security analysis and vulnerability detection of the hypervisor are critical for cloud computing enterprises. Importantly virtual devices expose many interfaces to a guest user for communication making virtual devices the most vulnerable part of a hypervisor. However applying fuzzing to the virtual devices of a hypervisor is challenging because the data structures transferred by DMA are constructed in a nested form according to protocol specifications. Failure to understand the protocol of the virtual devices will make the fuzzing process stuck in the initial fuzzing stage resulting in inefficient fuzzing.In this paper we propose a new framework called V-Shuttle to conduct hypervisor fuzzing which performs scalable and semantics-aware hypervisor fuzzing. To address the above challenges we first design a DMA redirection mechanism to significantly reduce the manual efforts to reconstruct virtual devices' protocol structures and make the fuzzing environment setup automated and scalable. Furthermore we put forward a new fuzzing mutation scheduling mechanism called seedpool to make the virtual device fuzzing process semantics-aware and speed up the fuzzing process to achieve high coverage. Extensive evaluation on QEMU and VirtualBox two of the most popular hypervisor platforms among the world shows that V-Shuttle can efficiently reproduce existing vulnerabilities and find new vulnerabilities. We further carried out a long-term fuzzing campaign in QEMU/KVM and VirtualBox with V-Shuttle. In total we discovered 35 new bugs with 17 CVEs assigned.;
Companion of the 30th International Conference on Software Engineering;Google Play App Store Huawei App Market Xiaomi App Store etc. are the main sources for users to download applications. The application category classification is usually based on the category specified by the developer when uploading or by analyzing the description provided by the developer. However the process is easily manipulated by malicious developers to evade detection. With the popularity of Android phones the number of Android applications has exploded. How to quickly and accurately classify applications automatically and improve management efficiency is crucial. This paper proposed a multi-classification framework for Android applications based on convolutional neural networks. By extracting multiple static features we combined natural language processing and deep learning to achieve a classification accuracy of 99.9064% and the training time was only 158s.;
Proceedings of the 4th International Conference on Computer Science and Application Engineering;Product requirements prioritization approaches identify the most valuable requirements according to customer value requirements risk volatility cost or other market parameters. However it is still a challenge in Value-Based Engineering to manage the requirement values for incrementing the product value. The analysis of the product value requires a better understanding of interdependencies among various artifacts of the software development lifecycle particularly requires to get a better understanding of how the value chain is preserved from the problem space to the solution space. In this position paper our aim is to study the feasibility of using traceability as the backbone to preserve the value chain between the prioritized product requirements and the product architecture. We propose traceability semantics to address this aim. Some initial findings from our research are presented.;
Proceedings of the 11th International Conference on Product Focused Software;To help increase the confidence that software is secure researchers and vendors have developed different kinds of automated software security analysis tools. These tools analyze software for weaknesses and vulnerabilities but the individual tools catch different vulnerabilities and produce voluminous data with many false positives. This paper describes a system that brings together the results of disparate software analysis tools into a visual environment to support the triage and exploration of code vulnerabilities. Our system allows software developers to explore vulnerability results to uncover hidden trends triage the most important code weaknesses and show who is responsible for introducing software vulnerabilities. By correlating and normalizing multiple software analysis tools' data the overall vulnerability detection coverage of software is increased. A visual overview and powerful interaction allows the user to focus attention on the most pressing vulnerabilities within huge volumes of data and streamlines the secure software development workflow through integration with development tools.;
Proceedings of the Seventh International Symposium on Visualization for Cyber Security;Web application security is an important problem in today's internet. A major cause of this status is that many programmers do not have adequate knowledge about secure coding so they leave applications with vulnerabilities. An approach to solve this problem is to use source code static analysis to find these bugs but these tools are known to report many false positives that make hard the task of correcting the application. This paper explores the use of a hybrid of methods to detect vulnerabilities with less false positives. After an initial step that uses taint analysis to flag candidate vulnerabilities our approach uses data mining to predict the existence of false positives. This approach reaches a trade-off between two apparently opposite approaches: humans coding the knowledge about vulnerabilities (for taint analysis) versus automatically obtaining that knowledge (with machine learning for data mining). Given this more precise form of detection we do automatic code correction by inserting fixes in the source code. The approach was implemented in the WAP tool and an experimental evaluation was performed with a large set of open source PHP applications.;
Proceedings of the 23rd International Conference on World Wide Web;The unsafe language features of C such as low-level control of memory often lead to memory errors which can result in silent data corruption security vulnerabilities and program crashes. Dynamic analysis tools which have been widely used for detecting memory errors at runtime usually perform instrumentation at the IR-level or binary-level. However their underlying non-source-level instrumentation techniques have three inherent limitations: optimization sensitivity platform dependence and DO-178C non-compliance. Due to optimization sensitivity these tools are used to trade either performance for effectiveness by compiling the program at -O0 or effectiveness for performance by compiling the program at a higher optimization level say -O3.  In this paper we overcome these three limitations by proposing a new source-level instrumentation technique and implementing it in a new dynamic analysis tool called MOVEC in a pointer-based instrumentation framework. Validation against a set of 86 microbenchmarks (with ground truth) and a set of 10 MiBench benchmarks shows that MOVEC outperforms state-of-the-art tools SoftBoundCETS Google's AddressSanitizer and Valgrind in terms of both effectiveness and performance considered together.;
Proceedings of the 24th European Conference on Pattern Languages of Programs;In the scene of intelligent warehousing and automatic production line the automatic guidance vehicle (AGV) needs to work continuously among multi-objective points but the existing path planning algorithm has the problems of driving collision and path tortuosity. Therefore this paper proposes a quadratic planning method for eliminating driving collision and path tortuosity which includes two parts: collision elimination and path winding elimination. Firstly according to the characteristics of collision points on the path a description model is established and an algorithm for eliminating collision is given. Then an algorithm for eliminating redundant tortuosity is developed based on collision elimination. Finally the procedure of quadratic planning method for eliminating driving collision and path tortuosity is given. The simulation results show that the contact times between the path and the obstacles after the quadratic programming are 0 and the AGV can save 24.4% of driving time.;
Proceedings of the 2010 ACM Symposium on Applied Computing;Online or Offline purchasing using credit or debit card has been popularized rapidly for its ease and flexibility of use. With the growing rate of online purchasing fraudulent transactions have also increased with an alarming rate. Researchers have investigated the reason and remedies of these kind of acts. However credit card fraud detection can be categorized into two sections in application fraud and behavioral fraud aspects. While an application is being compromised by the cyber-crimes then the user behavior analytic system has come to the limelight in recent days. In this research a fraud detection system has been built which can distinguish three types of user from pre-processed transaction logs. To prepare a balanced dataset undersampling of majority class and synthetic minority over-sampling technique on minority class applied on feature vectors. K-nearest neighbor is used to distinguish the legal fraudulent and enigmatic users. This system outperforms current state-of-art techniques to get behavioral analytics.;
Proceedings of the 2021 on Cloud Computing Security Workshop;In this article we address safety cases as special cases of the more general class of assurance cases which were developed as an extension to the concept of safety case. Related to the development and use of safety cases there remain challenges such as their size readability and identifying fallacious reasoning used in arguments. Some of these challenges are reviewed in the current article and followed by a review of challenges for the assessment of safety cases by regulators.;
Proceedings of the 2020 4th International Conference on Cryptography Security and Privacy;Designing a secure software system requires the ability to represent and reason about a wide variety of security concerns. Existing modelling representations lack a comprehensive set of security building blocks or lack support for composition or refinement of the design under consideration. We propose a new modular meta-model for representing these security designs. This model supports both composition for more complex solutions and representing different levels of abstraction to model the underlying details. This meta-model can subsequently be used for the construction of security solutions supporting a wide range of mechanisms on a wide variety of abstraction levels thereby providing a foundation for the security-by-design approach.;
Companion Proceedings of the 1st International Conference on the Art Science and Engineering of Programming;"There is a steady increase of digital networking in our world e. g. in the form of smart"" devices as part of the internet-of-things or more recently with daily video conferences. This progress is accompanied by weekly media reports on security incidents affecting the IT we use on a daily basis. In order to provide orientation in this seemingly ""insecure"" digital world it is necessary for every digital citizen to have a basic knowledge of the field of IT security. Current curricula for secondary CS education already try to cover some aspects of IT security - however practical reports suggest that some important security-related topics have not yet been considered. Based on this assumption we use a Qualitative Content Analysis to compare international as well as German secondary school curricula with an up-to-date body of knowledge of IT security to identify the gap to knowledge areas in current curricula.Our results show that there is not only a lack of more in-depth topics e. g. involving newer technologies like internet-of-things security the knowledge for the development of secure software - but also human factors in IT security are hardly considered in any curriculum. For further research the results support the adjustment of relevant IT security concepts for secondary CS education.""";
Proceedings of the 15th Workshop on Primary and Secondary Computing Education;Parsers are security-critical components of many software systems and verified parsing therefore has a key role to play in secure software design. However existing verified parsers for context-free grammars are limited in their expressiveness termination properties or performance characteristics. They are only compatible with a restricted class of grammars they are not guaranteed to terminate on all inputs or they are not designed to be performant on grammars for real-world programming languages and data formats.  In this work we present CoStar a verified parser that addresses these limitations. The parser is implemented with the Coq Proof Assistant and is based on the ALL(*) parsing algorithm. CoStar is sound and complete for all non-left-recursive grammars it produces a correct parse tree for its input whenever such a tree exists and it correctly detects ambiguous inputs. CoStar also provides strong termination guarantees it terminates without error on all inputs when applied to a non-left-recursive grammar. Finally CoStar achieves linear-time performance on a range of unambiguous grammars for commonly used languages and data formats.;
Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation;Security bug reports (SBR) depict potential security vulnerabilities in software systems. Bug tracking systems (BTS) usually contain huge numbers of bug reports including security-related ones. Malicious attackers could exploit these SBRs. Henceforth it is very critical to pinpoint SBRs swiftly and correctly. In this work we studied the security bug reports of the Chromium project. We looked into three main aspects of these bug reports namely: frequencies of reporting them how quickly they get fixed and is LDA effective in grouping these reports to known vulnerabilities types. We report our findings in these aspects.;
Proceedings of the 2020 European Symposium on Software Engineering;Future trustworthy computer systems should provide built-in support for at least the cornerstone security properties of confidentiality integrity and availability. Access control can help significantly towards achieving this. However in today's computing landscape traditional access control implemented only in software may be either insufficient or non-optimal. We discuss some of these situations. Furthermore fine-grained access control and usage control mechanisms implemented in software are themselves subject to attack and may impose heavy performance overheads. Can new hardware architecture improve the security achievable by software mechanisms for access control and usage control? If so what types of hardware support are most useful while retaining the flexibility of software protection mechanisms? What can software do to help hardware achieve the best results?With the trend towards Cloud Computing we discuss how new hardware architectural features for cloud servers can help protect the confidentiality and integrity of a cloud customer's code and data in his leased Virtual Machines -- even when the powerful underlying hypervisor may be compromised. This uses a new non-bypassable form of hardware access control. Without requiring new hardware we can also leverage the hardware trend towards manycore chips and the already available hardware virtualization features to enhance Cloud Security -- but with a few restrictions and some new software support.In general we would like to motivate collaborations between the software security and the hardware architecture communities to explore software-hardware co-design for security. What comes beyond access control in cloud computing and mobile computing ecosystems? The goal is to design future trustworthy systems that provide security protections at the levels needed when needed even with malware in the system.;
Proceedings of the 17th ACM Symposium on Access Control Models and Technologies;Conventional cyber defenses typically respond to detected attacks by rejecting them as quickly and decisively as possible but aborted attacks are missed learning opportunities for intrusion detection. A method of reimagining cyber attacks as free sources of live training data for machine learning-based intrusion detection systems (IDSes) is proposed and evaluated. Rather than aborting attacks against legitimate services adversarial interactions are selectively prolonged to maximize the defender's harvest of useful threat intelligence. Enhancing web services with deceptive attack-responses in this way is shown to be a powerful and practical strategy for improved detection addressing several perennial challenges for machine learning-based IDS in the literature including scarcity of training data the high labeling burden for (semi-)supervised learning encryption opacity and concept differences between honeypot attacks and those against genuine services. By reconceptualizing software security patches as feature extraction engines the approach conscripts attackers as free penetration testers and coordinates multiple levels of the software stack to achieve fast automatic and accurate labeling of live web data streams.Prototype implementations are showcased for two feature set models to extract security-relevant network- and system-level features from servers hosting enterprise-grade web applications. The evaluation demonstrates that the extracted data can be fed back into a network-level IDS for exceptionally accurate yet lightweight attack detection.;
Proceedings of the 11th ACM SIGSOFT International Workshop on Automating TEST Case Design Selection and Evaluation;In recent years many tools have been developed for fuzz testing that generates and executes test cases repeatedly. However many studies use different fuzzing targets and evaluation criteria and then it is difficult to compare the performance of the existing tools for fuzz testing. Therefore we prepared a unified collection of fuzzing targets and then compared 8 fuzzers with the benchmark. In comparison we compared the fuzzers based on the number of execution paths and branch coverage. The result shows that the number of execution paths is significantly different between the fuzzers. On the other hand the statistical difference is not confirmed between the branch converges of the fuzzers.;
Proceedings of the IEEE/ACM 1st International Conference on Automation of Software Test;Existing coverage-based fuzzers usually use the individual control flow graph (CFG) edge coverage to guide the fuzzing process which has shown great potential in finding vulnerabilities. However CFG edge coverage is not effective in discovering vulnerabilities such as use-after-free (UaF). This is because to trigger UaF vulnerabilities one needs not only to cover individual edges but also to traverse some (long) sequence of edges in a particular order which is challenging for existing fuzzers. To this end we propose to model UaF vulnerabilities as typestate properties and develop a typestate-guided fuzzer named UAFL for discovering vulnerabilities violating typestate properties. Given a typestate property we first perform a static typestate analysis to find operation sequences potentially violating the property. Our fuzzing process is then guided by the operation sequences in order to progressively generate test cases triggering property violations. In addition we also employ an information flow analysis to improve the efficiency of the fuzzing process. We have performed a thorough evaluation of UAFL on 14 widely-used real-world programs. The experiment results show that UAFL substantially outperforms the state-of-the-art fuzzers including AFL AFLFast FairFuzz MOpt Angora and QSYM in terms of the time taken to discover vulnerabilities. We have discovered 10 previously unknown vulnerabilities and received 5 new CVEs.;
Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering;In recent years the security landscape has changed with Web applications vulnerabilities becoming more prominent that vulnerabilities stemming from the lack of type safety such as buffer overruns. Many reports point to code injection attacks such as cross-site scripting and RSS injection as being the most common attacks against Web applications to date. With Web 2.0 existing security problems are further exacerbated by the advent of Ajax technology that allows one to create and compose HTML content from different sources within the browser at runtime as exemplified by customizable mashup pages like My Yahoo! or Live.comThis paper proposes a simple to support yet a powerful scheme for eliminating a wide range of script injection vulnerabilities in applications built on top of popular Ajax development frameworks such as the Dojo Toolkit prototype.js and AJAX.NET. Unlike other client-side runtime enforcement proposals the approach we are advocating requires only minor browser modifications. This is because our proposal can be viewed as a natural finer-grained extension of the same-origin policy for JavaScript already supported by the majority of mainstream browsers in which we treat individual user interface widgets as belonging to separate domainsFortunately in many cases no changes to the development process need to take place: for applications that are built on top of frameworks described above a slight framework modification will result in appropriate changes in the generated HTML completely obviating the need for manual code annotation. In this paper we demonstrate how these changes can prevent cross-site scripting and RSS injection attacks using the Dojo Toolkit a popular Ajax library as an example.;
Proceedings of the 2007 Workshop on Programming Languages and Analysis for Security;What you change is what you fuzz! In an empirical study of all fuzzer-generated bug reports in OSSFuzz we found that four in every five bugs have been introduced by recent code changes. That is 77% of 23k bugs are regressions. For a newly added project there is usually an initial burst of new reports at 2-3 bugs per day. However after that initial burst and after weeding out most of the existing bugs we still get a constant rate of 3-4 bug reports per week. The constant rate can only be explained by an increasing regression rate. Indeed the probability that a reported bug is a regression (i.e. we could identify the bug-introducing commit) increases from 20% for the first bug to 92% after a few hundred bug reports. In this paper we introduce regression greybox fuzzing (RGF) a fuzzing approach that focuses on code that has changed more recently or more often. However for any active software project it is impractical to fuzz sufficiently each code commit individually. Instead we propose to fuzz all commits simultaneously but code present in more (recent) commits with higher priority. We observe that most code is never changed and relatively old. So we identify means to strengthen the signal from executed code-of-interest. We also extend the concept of power schedules to the bytes of a seed and introduce Ant Colony Optimization to assign more energy to those bytes which promise to generate more interesting inputs. Our large-scale fuzzing experiment demonstrates the validity of our main hypothesis and the efficiency of regression greybox fuzzing. We conducted our experiments in a reproducible manner within Fuzzbench an extensible fuzzer evaluation platform. Our experiments involved 3+ CPU-years worth of fuzzing campaigns and 20 bugs in 15 open-source C programs available on OSSFuzz.;
Proceedings of the 19th ACM SIGPLAN International Workshop on Erlang;Today the proportion of software in society as a whole is steadily increasing. In addition to size of software increasing the number of cases dealing with personal information is also increasing. This shows the importance of weekly software security verification. However software security is very difficult in cases where libraries do not have source code. To solve this problem it is necessary to develop a technique for checking existing binary security weaknesses. To this end techniques for analyzing security weaknesses using intermediate languages are actively being discussed. In this paper we propose a system that translate binary code to intermediate language to effectively analyze existing security weaknesses within binary code.;
Proceedings of the ACM/IEEE 19th International Conference on Model Driven Engineering Languages and Systems;According to a 2011 survey in healthcare the most commonly reported breaches of protected health information involved employees snooping into medical records of friends and relatives. Logging mechanisms can provide a means for forensic analysis of user activity in software systems by proving that a user performed certain actions in the system. However logging mechanisms often inconsistently capture user interactions with sensitive data creating gaps in traces of user activity. Explicit design principles and systematic testing of logging mechanisms within the software development lifecycle may help strengthen the overall security of software. The objective of this research is to observe the current state of logging mechanisms by performing an exploratory case study in which we systematically evaluate logging mechanisms by supplementing the expected results of existing functional black-box test cases to include log output. We perform an exploratory case study of four open-source electronic health record (EHR) logging mechanisms: OpenEMR OSCAR Tolven eCHR and WorldVistA. We supplement the expected results of 30 United States government-sanctioned test cases to include log output to track access of sensitive data. We then execute the test cases on each EHR system. Six of the 30 (20%) test cases failed on all four EHR systems because user interactions with sensitive data are not logged. We find that viewing protected data is often not logged by default allowing unauthorized views of data to go undetected. Based on our results we propose a set of principles that developers should consider when developing logging mechanisms to ensure the ability to capture adequate traces of user activity.;
Proceedings of the 2014 Symposium and Bootcamp on the Science of Security;Many safety-related certification standards exist for developing safety-critical systems. System safety assessments are common practice and system certification according to a standard requires submitting relevant software safety information to appropriate authorities. The airworthiness standard RTCA DO-178B is the de-facto standard for certifying aerospace systems containing software. This research introduces an approach to improve communication and collaboration among safety engineers and software engineers by proposing a Unified Modeling Language (UML) profile that allows software engineers to model safety-related concepts and properties in UML the de-facto software modeling language. Key safety-related concepts are extracted from RTCA DO-178B and then a UML profile is defined to enable their precise modeling. We show that the profile improves the line of communication between safety engineers and software engineers for instance by allowing the automated generation of certification-related information from UML models. This is illustrated through a case study on developing an aircraft's navigation controller subsystem.;
Proceedings of the 10th International Conference on Model Driven Engineering Languages and Systems;Contemporary trusted execution environments provide a good foundation for implementing secure user credentials but these are not properly bound to the application instances that implement their use. This paper introduces a framework for application-specific credentials and provides a prototype implementation using TCG MTM and DRTM technologies. Measurements and a security analysis is presented for the realised architecture.;
Proceedings of the Fifth ACM Workshop on Scalable Trusted Computing;"We present a new approach to protect Java EE web applications against injection attacks which can handle large commercial systems. We first describe a novel approach to taint analysis for Java EE which can be characterized by strings only"" ""taint ranges"" and ""no bytecode instrumentation"". We then explain how to combine this method with static analysis based on the JOANA IFC framework. The resulting hybrid analysis will boost scalability and precision while guaranteeing protection against XSS. The approach has been implemented in the Juturna tool application examples and measurements are discussed.""";
Proceedings of the Third ACM Conference on Data and Application Security and Privacy;Pervasive computing environments are created to support human activities in different domains (e.g. home automation and healthcare). To do so applications orchestrate deployed services and devices. In a realistic setting applications are bound to conflict in their usage of shared resources e.g. controlling doors for security and fire evacuation purposes. These conflicts can have critical effects on the physical world putting people and assets at risk.This paper presents a domain-specific approach to architecturing conflict handling of pervasive computing resources. This approach covers the software development lifecycle and consists of enriching the description of a pervasive computing system with declarations for resource handling. These declarations are used to automate conflict detection manage the states of a pervasive computing system and orchestrate resource accesses accordingly at runtime. In effect our approach separates the application logic from resource conflict handling. Our approach has been implemented and validated on various building automation applications.;
Proceedings of the 11th IFIP WG 6.1 International Conference on Distributed Applications and Interoperable Systems;Decompilers are fundamental tools to perform security assessments of third-party software. The quality of decompiled code can be a game changer in order to reduce the time and effort required for analysis. This paper proposes a novel approach to restructure the control flow graph recovered from binary programs in a semantics-preserving fashion. The algorithm is designed from the ground up with the goal of producing C code that is both goto-free and drastically reducing the mental load required for an analyst to understand it. As a result the code generated with this technique is well-structured idiomatic readable easy to understand and fully exploits the expressiveness of C language. The algorithm has been implemented on top of the revng static binary analysis framework. The resulting decompiler revngc is compared on real-world binaries with state-of-the-art commercial and open source tools. The results show that our decompilation process introduces between 40% and 50% less extra cyclomatic complexity.;
Proceedings of the 2009 ICSE Workshop on Software Engineering in Health Care;Android packers have been widely adopted by developers to protect apps from being plagiarized. Meanwhile various unpacking tools unpack the apps through direct memory dumping. To defend against these off-the-shelf unpacking tools packers start to adopt virtual machine (VM) based protection techniques which replace the original Dalvik bytecode (DCode) with customized bytecode (PCode) in memory. This defeats the unpackers using memory dumping mechanisms. However little is known about whether such packers can provide enough protection to Android apps. In this paper we aim to shed light on these questions and take the first step towards demystifying the protections provided to the apps by the VM-based packers. We proposed novel program analysis techniques to investigate existing commercial VM-based packers including a learning phase and a deobfuscation phase.We aim at deobfuscating the VM-protection DCode in three scenarios recovering original DCode or its semantics with training apps and restoring the semantics without training apps. We also develop a prototype named Parema to automate much work of the deobfuscation procedure. By applying it to the online VM-based Android packers we reveal that all evaluated packers do not provide adequate protection and could be compromised.;
Proceedings of the 2013 International Conference on Software and System Process;Nowadays the use of container technologies is ubiquitous and thus the need to make them secure arises. Container technologies such as Docker provide several options to better improve container security one of those is the use of a Seccomp profile. A major problem with these profiles is that they are hard to maintain because of two different factors: they need to be updated quite often and present a complex and time consuming task to determine exactly what to update therefore not many people use them.The research goal of this paper is to make Seccomp profiles a viable technique in a production environment by proposing a reliable method to generate custom Seccomp profiles for arbitrary containerized application. This research focused on developing a solution with few requirements allowing for an easy integration with any environment with no human intervention.Results show that using a custom Seccomp profile can mitigate several attacks and even some zero day vulnerabilities on containerized applications. This represents a big step forward on using Seccomp in a production environment which would benefit users worldwide.;
Proceedings of the 2020 6th International Workshop on Container Technologies and Container Clouds;Assurance cases are structured arguments that are commonly used to reason about the safety of a product or service. Currently there is an ongoing push towards using assurance cases also for cybersecurity especially in safety critical domains like automotive. While the industry is faced with the challenge of defining a sound methodology to build security assurance cases the state of the art is rather immature. Therefore we have conducted a thorough investigation of the (external) constraints and (internal) needs that security assurance cases have to satisfy when used in the automotive industry. This has been done with 28 participants and in the context of two large automotive companies located in Europe: Company A is a passenger car manufacturer while Company B is a truck manufacturer. An extended version of this paper is available online at https://arxiv.org/abs/2003.14106.;
Proceedings of the 3rd International Conference on Computer Science and Application Engineering;Many modern defenses against code reuse rely on hiding sensitive data such as shadow stacks in a huge memory address space. While much more efficient than traditional integrity-based defenses these solutions are vulnerable to probing attacks which quickly locate the hidden data and compromise security. This has led researchers to question the value of information hiding in real-world software security. Instead we argue that such a limitation is not fundamental and that information hiding and integrity-based defenses are two extremes of a continuous spectrum of solutions. We propose a solution ProbeGuard that automatically balances performance and security by deploying an existing information hiding based baseline defense and then incrementally moving to more powerful integrity-based defenses by hotpatching when probing attacks occur. ProbeGuard is efficient provides strong security and gracefully trades off performance upon encountering more probing primitives.;
Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems;Constraint independence optimization is one of the most important constraint solving optimizations and widely used by symbolic executions. Constraint independence optimization divides the set of constraints into multiple independent subsets as the symbolic variables of constraint. But existing constraint independence optimization is not efficient for binary symbolic execution because the symbolic variables are coarse-grained. In this paper we propose a shape-inference-based approach to enhance constraint independence optimization.We propose a shape inference algorithm to split the symbolic variable into multiple fields and perform constraint independence optimization as the fields of symbolic variables. We implement a prototype system angr-shape based on the proposed approach and verify its effectiveness according to experimentation. Compared with state-of-the-art approach the experimental results demonstrate that the number of generated test cases increases by 2.37% and the time of constraint solving reduces by 14.00%.;
Proceedings of the 2020 9th International Conference on Software and Computer Applications;Trusted execution as offered by Intel's Software Guard Extensions (SGX) is considered as an enabler to protect the integrity and confidentiality of stateful workloads such as key-value stores and databases in untrusted environments. These systems are typically long running and require extension mechanisms built on top of dynamic loading as well as hot-patching to avoid downtimes and apply security updates faster. However such essential mechanisms are currently neglected or even missing in combination with trusted execution.We present sgx-dl a lean framework that enables dynamic loading of enclave code at the function level and hot-patching of dynamically loaded code. Additionally sgx-dl is the first framework to utilize the new SGX version 2 features and also provides a versioning mechanism for dynamically loaded code. Our evaluation shows that sgx-dl introduces a performance overhead of less than 5% and shrinks application downtime by an order of magnitude in the case of a database system.;
Proceedings of the 22nd International Middleware Conference;Public blockchains targeting Internet of Things (IoT) are gaining more traction every day with majority of them being built on top of the Ethereum infrastructure. However a growing number of these blockchains introduces security issues. There are 525 entries already in the Common Vulnerabilities and Exposure database related to Ethereum smart contracts. 479 of them are related to arithmetic errors which include integer overflow or underflow. This paper thus concentrates on analyzing arithmetic vulnerabilities found in existing public blockchains targeted at IoT applications. Furthermore the performance in terms of security and gas cost of smart contracts is analyzed with and without SafeMath library. In addition an improved SafeMath library is proposed that has better arithmetic coverage and requires lower gas consumption. Four security tools are used to analyze the arithmetic protection of the improved SafeMath library. The results show that the improved SafeMath library is able to cover 4 more arithmetic operations compared to the original one by using only two common conditions checks and is capable of saving 26 units of gas which is a significant amount in the long run.;
Proceedings of the 5th ACM SIGCHI Symposium on Engineering Interactive Computing Systems;Requirements engineering is recognized as a critical stage in software development lifecycle. Given the nature of Software Product Lines (SPL) the importance of requirements engineering is more pronounced as SPLs pose more complex challenges than development of a 'single' product. Several methods have been proposed in the literature which encompass activities for capturing requirements their variability and commonality. To investigate the maturity and effectiveness of the current requirements engineering approaches in software product lines we develop an evaluation framework containing a set of evaluation criteria and assess feature oriented requirements engineering methods based on the proposed criteria. As a result of this initial study we find out the majority of approaches lacks proper techniques for supporting the validation of family requirements models as well as dealing with delta requirements. Additionally capturing stakeholders' preferences and applying them during the course of software feature configuration have not been taken into account and addressed in the proposed approaches.;
Proceedings of the 16th International Software Product Line Conference - Volume 2;We propose a robust watermarking algorithm based on scale invariant feature transformation (SIFT) and pseudo-Zernike moment against geometric attacks. First the SIFT algorithm is used to extract stable feature points from the carrier image. Then the size and direction of each local feature region are adaptively determined according to the feature scale and direction. Finally the feature region with large feature scale non-overlapping is selected from it and the watermark is embedded into each local feature region by means of quantization modulation pseudo-Zernike moment amplitude method. The simulation results show that the proposed algorithm not only has good transparency but also has a strong ability to resist conventional signal processing and geometric attacks.;
Proceedings of the 2020 4th International Conference on Electronic Information Technology and Computer Engineering;In this paper I propose a method for detecting violation of a regulation or an illegal action by surveillance cameras and for preventing fabrication of video records by the cameras. In this method message digests of video records are signed and chained by blockchain for the integrity. There are some researches in which falsification of video is prevented by blockchain. However in the researches fabrication of the video is not considered. On the other hand cameras are classified in terms of both reliability and security in my method for making trust chains of cameras against fabrication. In this paper I also explain the condition for making the trust chains. A owner of a camera which shot violation of a regulation or an illegal action is rewarded with a fine for the violation or the penalty instead of bitcoin and a signer of a chain is also rewarded. The proposed method can make areas safe with small cost and terminate false accusations by fabrication of video records.;
Proceedings of the 2020 2nd International Conference on Blockchain Technology;Architecting software systems is an integral part of the software development lifecycle. However often the implementation of the resultant software ends up diverging from the designed architecture due to factors such as time pressures on the development team during implementation/evolution or the lack of architectural awareness on the part of (possibly new) programmers. In such circumstances the quality requirements addressed by the as-designed architecture are likely to be unaddressed by the as-implemented system.This paper reports on in-vivo case studies of the ACTool a tool which supports real-time Reflexion Modeling for architecture recovery and on-going consistency. It describes our experience conducting architectural recovery sessions on three deployed commercial software systems in two companies with the tool as a first step towards ongoing architecture consistency in these systems. Our findings provide the first in-depth characterization of real-time Reflexion-based architectural recovery in practice highlighting the architectural recovery agendas at play the modeling approaches employed the mapping approaches employed and characterizing the inconsistencies encountered. Our findings also discuss the usefulness of the ACTool for these companies.;
Proceedings of the 8th International ACM SIGSOFT Conference on Quality of Software Architectures;Side channels pose a significant threat to the confidentiality of software systems. Such vulnerabilities are challenging to detect and evaluate because they arise from non-functional properties of software such as execution times and require reasoning on multiple execution traces. Recently noninterference notions have been adapted in static analysis symbolic execution and greybox fuzzing techniques. However noninterference is a strict notion and may reject security even if the strength of information leaks are weak. A quantitative notion of security allows for the relaxation of noninterference and tolerates small (unavoidable) leaks. Despite progress in recent years the existing quantitative approaches have scalability limitations in practice.  In this work we present QFuzz a greybox fuzzing technique to quantitatively evaluate the strength of side channels with a focus on min entropy. Min entropy is a measure based on the number of distinguishable observations (partitions) to assess the resulting threat from an attacker who tries to compromise secrets in one try. We develop a novel greybox fuzzing equipped with two partitioning algorithms that try to maximize the number of distinguishable observations and the cost differences between them.  We evaluate QFuzz on a large set of benchmarks from existing work and real-world libraries (with a total of 70 subjects). QFuzz compares favorably to three state-of-the-art detection techniques. QFuzz provides quantitative information about leaks beyond the capabilities of all three techniques. Crucially we compare QFuzz to a state-of-the-art quantification tool and find that QFuzz significantly outperforms the tool in scalability while maintaining similar precision. Overall we find that our approach scales well for real-world applications and provides useful information to evaluate resulting threats. Additionally QFuzz identifies a zero-day side-channel vulnerability in a security critical Java library that has since been confirmed and fixed by the developers.;
Proceedings of the 36th International Conference on Computer-Aided Design;"When a software transformation or software security task needs to analyze a given program binary the first step is often disassembly. Since many modern disassemblers have become highly accurate on many binaries we believe reliable disassembler benchmarking requires standardizing the set of binaries used and the disassembly ground truth about these binaries. This paper presents (i) a first version of our work-in-progress disassembly benchmark suite which comprises $879$ binaries from diverse projects compiled with multiple compilers and optimization settings and (ii) a novel disassembly ground truth generator leveraging the notion of listing files'' which has broad support by clang gcc icc and msvc. In additional it presents our evaluation of four prominent open-source disassemblers using this benchmark suite and a custom evaluation system. Our entire system and all generated data are maintained openly on GitHub to encourage community adoption.""";
Proceedings of the 2021 13th International Conference on Machine Learning and Computing;Recently steganography tools for concealing messages in images have been widely used and internal mechanisms for hiding messages using steganography tools are mostly unknown to public. Therefore we adopted the reverse engineering for unveiling the information hiding algorithm and operation mechanism applied to 'Steg' steganography software using IDA tool. By reversing the steganography software we disclosed the internal steganographic mechanism used on 'Steg' software. Therefore we can propose a new approach for efficiently detecting and automatically extracting hidden messages in stego data using the software reversing technique.;
Proceedings of the 16th International Conference on Availability Reliability and Security;To protect the ownership of the digital content the robustness of the watermarking algorithm is the most important metric to assess its affectiveness. However few state-of-the-art watermarking algorithms can resist the combinations of the conventional attacks such as jpeg compression and geometric transformation. In this paper an improved robust image watermarking algorithm is thus proposed to address this issue. The watermark information is embedded in the low frequency domain of the wavelet transform by a quantization modulation method. When using watermark detection use matching the position information of the SIFT key points is used to calculate the affine transformation parameters and the edge point parameters and then inversely transform and reposition the detected image to recover the watermark synchronization information. Theoretical analysis and experimental results show that the proposed algorithm has high correlation accuracy and stable performance and can effectively recover the watermark synchronization of watermark images subjected to rotation scaling and translation attacks so that the watermark algorithm can correctly detect or extract watermarks.;
Proceedings of the 2020 3rd International Conference on Artificial Intelligence and Pattern Recognition;Watermark is a method to protect the intellectual property rights of digital media. The production of multimedia content has increased in recent years and the protection of copyright has put forward high requirements. Different watermarking methods are proposed to satisfy the trade-off between imperceptibility while maintaining appropriate embedded data capacity. In general the transform domain watermarking such as wavelet-based methods yields better results than spatial algorithms. Therefore this paper introduces a new measure. A block and content based localization and restoration image authentication scheme is proposed. In this scheme the watermark of each block is an encrypted form of its content features embedded in another block selected by the ergodic matrix of chaotic sequences. Experiments show that this scheme can detect and locate any tampering of 8X8 pixels and above and can restore 40% of the damaged to understandable images.;
Proceedings of the 2020 5th International Conference on Multimedia Systems and Signal Processing;Nowadays people's demand for Web services is increasing but in the process of obtaining these services there are some problems in the service which have not been detected resulting in a poor experience. Therefore this paper proposes a difference measurement method based on FSCS (Fixed Sized Candidate Set) algorithm which improves the traditional ART (Adaptive Random Testing) algorithm. By comparing the differences of each method in Web Services the farthest method is selected for testing which improves the testing efficiency and improves the service experience. The method first selects one of the multiple services that may have a potential error service for testing each time picks the farthest service in the combined service and then selects the farthest method from the service as a test case and then measures the differences between the methods in the service compare the test results with the expected results so that the problems in the service can be effectively detected. The experimental results show that the proposed method based on difference metric and adaptive random test can detect the existing methods in the service and improve the detection efficiency.;
Proceedings of the 2019 9th International Conference on Communication and Network Security;In spite of years of improvements to software security heap-related attacks still remain a severe threat. One reason is that many existing memory allocators fall short in a variety of aspects. For instance performance-oriented allocators are designed with very limited countermeasures against attacks but secure allocators generally suffer from significant performance overhead e.g. running up to 10x slower. This paper therefore introduces FreeGuard a secure memory allocator that prevents or reduces a wide range of heap-related security attacks such as heap overflows heap over-reads use-after-frees as well as double and invalid frees. FreeGuard has similar performance to the default Linux allocator with less than 2% overhead on average but provides significant improvement to security guarantees.;
Proceedings of the 7th ACM on Cyber-Physical System Security Workshop;Building secure software architectures requires taking several design decisions to achieve security requirements these decisions must be revised carefully before agreement given their impact on system vulnerability and mission-readiness. Architects customarily take these resolutions drawing upon specialized knowledge like architectural tactics for security developers also have key information on platforms and tools actual performance but their input may not be systematically considered to this end. This article presents Security Tactics Selection Poker (TaSPeR) a card game-based technique and consensus-building technique (based on Planning Poker) that allows development team members to identify argue for and choose among architectural security tactics according to objectives and priorities. We conducted an experimental process involving twenty-one practitioners from a security software unit to assess the technique effectiveness in several scenarios. Initial results show that TaSPeR (1) does support collaborative architectural decision-making (2) encourages stakeholders participation and (3) starts a group dynamics on how to act against threats. Thus the use of gamification techniques for architectures evaluation seems to be a promising approach that deserves further exploration.;
Proceedings of the 12th European Conference on Software Architecture: Companion Proceedings;Internet based application services become the essential part of peoples' daily activities. Web applications are a complex organized mess of codes the software industry often they are built-in extreme pressure to meet a deadline. Therefore it often retains the vulnerability holes from the development phase to the operational phase. Coding flaws improper input sanitization server misconfiguration etc. causes the application vulnerable to an attacker which may lead to service interruption and theft of valuable information. This paper conducts an empirical analysis of e-commerce based web applications to evaluate the current web application security scenario in Bangladesh. The most prominent web application security scanner named as Acunetix and Nikto were used to evaluate this study. A breakdown has conjured based on analytical results to find out the types of vulnerability. It is concluded that Cross-Site Request Forgery shows most frequent vulnerability where maximum apps were found having this vulnerability so aptly ranked as number one. However cross site scripting positioned top for high-level risk vulnerability in Bangladeshi e-commerce platform.;
Proceedings of the 12th International Conference on Management of Digital EcoSystems;The goal of obfuscation is to transform a program without affecting its functionality such that some secret information within the program can be hidden for as long as possible from an adversary armed with reverse engineering tools. Slicing is a form of reverse engineering which aims to abstract away a subset of program code based on a particular program point and is considered to be a potent program comprehension technique. Thus slicing could be used as a way of attacking obfuscated programs. It is challenging to manufacture obfuscating transforms that are provably resilient to slicing attacks.We show in this paper how we can utilise the information gained from slicing a program to aid us in designing obfuscations that are more resistant to slicing. We extend a previously proposed technique and provide proofs of correctness for our transforms. Finally we illustrate our approach with a number of obfuscating transforms and provide empirical results using software engineering metrics.;
Proceedings of the 34th International Conference on Software Engineering;Many security-critical services on mobile devices rely on Trusted Execution Environments (TEEs). However due to the proprietary and locked-down nature of TEEs the available information about these systems is scarce. In recent years we have witnessed several exploits targeting all major commercially used TEEs which raises questions about the capabilities of TEEs to provide the expected integrity and confidentiality guarantees. In this paper we evaluate the exploitability of TEEs by analyzing common flaws from the perspective of an adversary. We provide multiple vulnerable TEE applications for OP-TEE a reference implementation for TEEs and elaborate on the steps necessary for their exploitation on an Android system. Our vulnerable examples are inspired by real-world exploits seen in-the-wild on commercially used TEEs. With this work we provide developers and researchers with introductory knowledge to realistically assess the capabilities of TEEs. For these purposes we also make our examples publicly available.;
Proceedings of the 2020 6th International Conference on Computer and Technology Applications;A development of mobile technologies and their common use in business creates new challenges for people dealing with data security in the organization. This paper explores the types and nature of threats to the enterprise that result from the widespread use of business applications on smartphones (e.g. mobile CRM). The analysis has been focused on smartphones and tablets running on the Android operating system. We used STRIDE - a threat modeling technique commonly used to detect vulnerabilities in software security. We propose its modification to better design and implement solutions for the security of mobile devices. We also used the Data Flow Diagram and the Attack Tree concept to analyze threats. Our research will allow companies to detect threats typical only for the mobile devices. This will increase awareness and improve the corporate data protection process.;
Proceedings of the 18th International Conference on Advances in Mobile Computing &amp Multimedia;Security issues emerging out of the constantly evolving software applications became a huge challenge to software security experts. In this paper we propose a prototype to detect vulnerabilities by identifying their architectural sources and also use security patterns to mitigate the identified vulnerabilities. We emphasize the need to consider architectural relations to introduce an effective security solution. In this research we focused on the taint-style vulnerabilities that can induce injection-based attacks like XSS SQLI in web applications. With numerous tools available to detect the taint-style vulnerabilities in the web applications we scanned for the presence of repetition of a vulnerable code pattern in the software. Very importantly we attempted to identify the architectural source files or modules by developing a tool named ArT Analyzer. We conducted a case study on a leading health-care software by applying the proposed architectural taint analysis and identified the vulnerable spots. We could identify the architectural roots for those vulnerable spots with the use of our tool ArT Analyzer. We verified the results by sharing it with the lead software architect of the project. By adopting an architectural solution we avoided changes to be done on 252 different lines of code by merely introducing 2 lines of code changes at the architectural roots. Eventually this solution was integrated into the latest updated release of the health-care software.;
Proceedings of the 3rd International Conference on Cryptography Security and Privacy;It is widely known that return-oriented programming (ROP) attack can be mounted on x86 ARM and SPARC architectures. However it remained an open question if ROP was possible on RISC-V a new and promising free and open instruction set architecture (ISA). In this paper we present a novel ROP technique specific to RISC-V architecture. Our method relies on the processor's saved registers and its function calling convention. We use functional gadgets (that perform primitive operations) ended in a jump instruction to an address held in a saved register. The order of gadgets chaining is given by a novel gadget which we call the charger gadget which loads the saved registers with the gadgets? addresses from the stack. We constructed a library of gadgets extracted from the standard Linux libraries. Finally we evaluated our method by exploiting a buffer-overflow vulnerable application.;
Proceedings of the 2020 ACM SIGSAC Conference on Cloud Computing Security Workshop;Due to the open source and fragmentation of the Android system its security is increasingly challenged. Currently Android malware detection has certain deficiencies in large-scale and automation detection. In this paper we proposed an Android malware detection framework based on Convolutional Neural Network (CNN). We used static analysis tools and python scripts to automatically extract 1003 static features and transformed the features of each sample into a two-dimensional matrix as input to the CNN model. We selected 5000 malicious samples and 5000 benign samples for verification. The experimental results show that the detection accuracy of CNN reaches 99.68% which is much higher than other algorithms.;
Proceedings of the International Conference on Information Technology and Electrical Engineering 2018;Recent micro-architectural research has proposed various schemes to enhance processors with additional tags to track various properties of a program. Such a technique which is usually referred to as information flow tracking has been widely applied to secure software execution (e.g. taint tracking) protect software privacy and improve performance (e.g. control speculation).In this paper we propose a novel use of information flow tracking to obfuscate the whole control flow of a program with only modest performance degradation to defeat malicious code injection discourage software piracy and impede malware analysis. Specifically we exploit two common features in information flow tracking: the architectural support for automatic propagation of tags and violation handling of tag misuses. Unlike other schemes that use tags as oracles to catch attacks (e.g. taint tracking) or speculation failures we use the tags as flow-sensitive predicates to hide normal control flow transfers: the tags are used as predicates for control flow transfers to the violation handler where the real control flow transfer happens.We have implemented a working prototype based on Itanium processors by leveraging the hardware support for control speculation. Experimental results show that BOSH can obfuscate the whole control flow with only a mean of 26.7% (ranging from 4% to 59%) overhead on SPECINT2006. The increase in code size and compilation time is also modest.;
Proceedings of the 42nd Annual IEEE/ACM International Symposium on Microarchitecture;Software Engineering is primarily a human process and consideration of human factors in safety-related software systems should always be mindful of the role that software practitioners themselves play in the delivery of those systems. As a Software Engineering Project Manager I have had responsibility for most aspects of the software development lifecycle and for guiding the software practitioners towards a successful outcome. This paper explores some experiences managing the delivery of software into the public safety-related emergency services environment and the challenges of requirements analysis design and implementation of software-intensive public safety systems.;
Proceedings of the Twelfth Australian Workshop on Safety Critical Systems and Software and Safety-Related Programmable Systems - Volume 86;"Failure management is a particular challenge problem in the automotive domain. Today's cars host a network of 30 to 80 electronic control units (ECUs) distributed over up to five interconnected in-car networks supporting hundreds to thousands of softwaredefined functions. This high degree of distribution of hard- and software components is a key contributor to the difficulty of failure management in vehicle. This paper addresses comprehensive failure management starting from domain models for logical and deployment models of automotive software. These models capture interaction patterns as a critical part of both logical and deployment architectures introducing failure detection and mitigation as wrapper"" services to ""unmanaged services"" i.e. services without failure management. We show how these models can be embedded into an interaction-centric development process which captures failure management information across development phases. Finally we exploit the failure management models to verify that a particular architecture meets its requirements under the stated failure hypothesis.""";
Proceedings of the 4th International Workshop on Software Engineering for Automotive Systems;Augmented Reality (AR) enables smartphone users to interact with virtual content spatially overlaid on a continuously captured physical world. Under the current permission enforcement model in popular operating systems AR apps are given Internet permission at installation time and request camera permission and external storage write permission at runtime through a user's approval. With these permissions granted any Internet-enabled AR app could silently collect camera frames and derived visual information for malicious intent without a user's awareness. This raises serious concerns about the disclosure of private user data in their living environments.To give users more control over application usage of their camera frames and the information derived from them we introduce LensCap a split-process app design framework in which the app is split into a camera-handling visual process and a connectivity-handling network process. At runtime LensCap manages secured communications between split processes enacting fine-grained data usage monitoring. LensCap also allows both processes to present interactive user interfaces. With LensCap users can decide what forms of visual data can be transmitted to the network while still allowing visual data to be used for AR purposes on device. We prototype LensCap as an Android library and demonstrate its usability as a plugin in Unreal Engine. Performance evaluation results on five AR apps confirm that visual privacy can be preserved with an insignificant latency penalty (&lt 1.3 ms) at 60 FPS.;
Proceedings of the 19th Annual International Conference on Mobile Systems Applications and Services;As the most popular blockchain that supports smart contracts there are already more than 296 thousand kinds of cryptocurrencies built on Ethereum. However not all cryptocurrencies can be controlled by users. For example some money is permanently locked in wallets' accounts due to attacks. In this paper we conduct the first systematic investigation on locked cryptocurrencies in Ethereum. In particular we define three categories of accounts with locked cryptocurrencies and develop a novel tool named Clue to discover them. Results show that there are more than 216 million dollars value of cryptocurrencies locked in Ethereum. We also analyze the reasons (i.e. attacks/behaviors) why cryptocurrencies are locked. Because the locked cryptocurrencies can never be controlled by users avoid interacting with the accounts discovered by Clue and repeating the same mistakes again can help users to save money.;
Proceedings of the First ACM Workshop on Secure Execution of Untrusted Code;With the use of mobile phones malicious applications are constantly developing affecting the normal use of mobile phones by users. For the malicious application of Android platform a detection model based on combined features is proposed. The model extracts the dynamic and static features and select the importance of them. Selecting Combination Features from important features. Taking the combined features as new features and combing the single features to detect Android malicious applications. Experiments are carried out using different classification algorithm. which verifies the proposed Android malicious application detection model is feasible and superior and the detection accuracy is up to 97.12%.;
Proceedings of the 13th International Software Product Line Conference;Software security techniques rely on correct execution by the hardware. Securing hardware components has been challenging due to their complexity and the proportionate attack surface they present during their design manufacture deployment and operation. Recognizing that external communication represents one of the greatest threats to a system's security this paper introduces the TrustGuard containment architecture. TrustGuard contains malicious and erroneous behavior using a relatively simple and pluggable gatekeeping hardware component called the Sentry. The Sentry bridges a physical gap between the untrusted system and its external interfaces. TrustGuard allows only communication that results from the correct execution of trusted software thereby preventing the ill effects of actions by malicious hardware or software from leaving the system. The simplicity and pluggability of the Sentry which is implemented in less than half the lines of code of a simple in-order processor enables additional measures to secure this root of trust including formal verification supervised manufacture and supply chain diversification with less than a 15% impact on performance.;
